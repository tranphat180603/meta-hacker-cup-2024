[
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `N` and the color sequence `S`.\n2. Count the number of black blocks `B` and white blocks `W`.\n3. Check if it's impossible to make all blocks the same color by checking if both `B` and `W` are odd. If so, print `-1` and exit.\n4. If `B` is even, iterate through the blocks and find pairs of adjacent blocks that need to be inverted to make all blocks black.\n5. If `W` is even, iterate through the blocks and find pairs of adjacent blocks that need to be inverted to make all blocks white.\n6. Print the number of operations and the positions of the blocks that need to be inverted.\n\nCOMMENTED CODE:\n```python\n#\u30e9\u30a4\u30d6\u30e9\u30ea\u30a4\u30f3\u30dd\u30fc\u30c8\nfrom collections import defaultdict\n\n#\u5165\u529b\u53d7\u3051\u53d6\u308a\ndef getlist():\n\treturn list(map(int, input().split()))\n\n#\u51e6\u7406\u5185\u5bb9\ndef main():\n\t# read the number of blocks and the color sequence\n\tN = int(input())\n\tS = list(input())\n\n\t# count the number of black blocks and white blocks\n\tB = 0\n\tW = 0\n\tfor i in range(N):\n\t\tif S[i] == \"B\":\n\t\t\tB += 1\n\t\telse:\n\t\t\tW += 1\n\n\t# check if it's impossible to make all blocks the same color\n\tif B % 2 == 1 and W % 2 == 1:\n\t\t# print -1 and exit if impossible\n\t\tprint(-1)\n\t\treturn\n\n\t# if B is even, find pairs of adjacent blocks to invert to make all blocks black\n\tif B % 2 == 0:\n\t\tcnt = 0\n\t\tans = []\n\t\tfor i in range(N - 1):\n\t\t\tif S[i] == \"B\":\n\t\t\t\t# count the number of black blocks before inverting\n\t\t\t\tcnt += 1\n\t\t\t\tans.append(i + 1)\n\t\t\t\t# invert the colors of the current block and the next block\n\t\t\t\tS[i] = \"W\"\n\t\t\t\tif S[i + 1] == \"B\":\n\t\t\t\t\tS[i + 1] = \"W\"\n\t\t\t\telse:\n\t\t\t\t\tS[i + 1] = \"B\"\n\t\t# print the number of operations and the positions of the blocks that need to be inverted\n\t\tprint(cnt)\n\t\tif cnt!= 0:\n\t\t\tprint(\" \".join(list(map(str, ans))))\n\n\t# if W is even, find pairs of adjacent blocks to invert to make all blocks white\n\telse:\n\t\tcnt = 0\n\t\tans = []\n\t\tfor i in range(N - 1):\n\t\t\tif S[i] == \"W\":\n\t\t\t\t# count the number of white blocks before inverting\n\t\t\t\tcnt += 1\n\t\t\t\tans.append(i + 1)\n\t\t\t\t# invert the colors of the current block and the next block\n\t\t\t\tS[i] = \"B\"\n\t\t\t\tif S[i + 1] == \"W\":\n\t\t\t\t\tS[i + 1] = \"B\"\n\t\t\t\telse:\n\t\t\t\t\tS[i + 1] = \"W\"\n\t\t# print the number of operations and the positions of the blocks that need to be inverted\n\t\tprint(cnt)\n\t\tif cnt!= 0:\n\t\t\tprint(\" \".join(list(map(str, ans))))\n\nif __name__ == '__main__':\n\tmain()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Count the number of black and white blocks.\n3. If the number of black blocks is odd, invert the colors of all blocks to make the number of black blocks even.\n4. Iterate through the blocks, and for each pair of adjacent blocks with different colors, invert their colors and add the position of the left block to the `moves` list.\n5. After iterating through all blocks, check if the last two blocks have the same color. If they do, print the number of moves and the positions of the moves. Otherwise, print -1.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors of the blocks\nn = int(input())\ns = input()\n\n# Initialize an empty list to store the positions of the moves\nmoves = []\n\n# Initialize counters for the number of black and white blocks\nb = w = 0\n\n# Count the number of black and white blocks\nfor char in s:\n    if char == 'B':\n        b += 1\n    else:\n        w += 1\n\n# If the number of black blocks is odd, invert the colors of all blocks to make the number of black blocks even\nif b & 1:\n    # Use list comprehension to invert the colors of all blocks\n    s = [False if s[i] == 'W' else True for i in range(n)]\nelse:\n    # Use list comprehension to invert the colors of all blocks\n    s = [True if s[i] == 'W' else False for i in range(n)]\n\n# Iterate through the blocks, and for each pair of adjacent blocks with different colors, invert their colors and add the position of the left block to the moves list\nfor i in range(n - 1):\n    if s[i]:  # If the current block is black\n        continue\n    else:  # If the current block is white\n        # Invert the colors of the current block and the next block\n        s[i] = not s[i]\n        s[i + 1] = not s[i + 1]\n        # Add the position of the left block to the moves list\n        moves.append(i + 1)\n\n# After iterating through all blocks, check if the last two blocks have the same color\nelse:\n    # If the last two blocks have the same color, print the number of moves and the positions of the moves\n    if s[-1] == s[-2]:\n        print(len(moves))\n        print(*moves, sep=\" \")\n    # If the last two blocks do not have the same color, print -1\n    else:\n        print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string representing the colors of the blocks from the input.\n2. Initialize an empty list `ans` to store the positions of the blocks that need to be flipped.\n3. Try to make all blocks black by flipping the colors of adjacent blocks. If a block is already black, skip it. Otherwise, flip the colors of the current block and the next block, and add the position of the current block to `ans`.\n4. Check if the last block is black. If it is, print the length of `ans` and the positions in `ans`, and exit.\n5. Reset the string to its original state and repeat steps 3-4 to try to make all blocks white.\n6. If it's impossible to make all blocks have the same color, print -1.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks n and the string representing the colors of the blocks from the input\nn = int(stdin.readline().strip())\nstring = list(stdin.readline().strip())\n\n# Initialize an empty list ans to store the positions of the blocks that need to be flipped\ntemp = string[:]  # Create a copy of the string\nans = []\n\n# Try to make all blocks black by flipping the colors of adjacent blocks\nfor i in range(n - 1):\n    # If a block is already black, skip it\n    if string[i] == 'B':\n        pass\n    else:\n        # Flip the colors of the current block and the next block\n        string[i] = 'B'\n        string[i + 1] = counter(string[i + 1])\n        # Add the position of the current block to ans\n        ans.append(i + 1)\n\n# Check if the last block is black\nif string[-1] == 'B':\n    # Print the length of ans and the positions in ans\n    print(len(ans))\n    print(*ans)\n    # Exit\n    exit()\n\n# Reset the string to its original state\nstring = temp[:]\n\n# Repeat steps 3-4 to try to make all blocks white\nans = []\nfor i in range(n - 1):\n    # If a block is already white, skip it\n    if string[i] == 'W':\n        pass\n    else:\n        # Flip the colors of the current block and the next block\n        string[i] = 'W'\n        string[i + 1] = counter(string[i + 1])\n        # Add the position of the current block to ans\n        ans.append(i + 1)\n\n# Check if the last block is white\nif string[-1] == 'W':\n    # Print the length of ans and the positions in ans\n    print(len(ans))\n    print(*ans)\n    # Exit\n    exit()\n\n# If it's impossible to make all blocks have the same color, print -1\nprint(-1)\n\n# Function to flip the color of a block\ndef counter(c):\n    if c == 'B':\n        return 'W'\n    return 'B'\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The number of blocks (n) and the string representing the colors of the blocks.\n2. Initialize an empty list to store the positions of the blocks that need to be flipped.\n3. Iterate through the string of block colors from left to right.\n4. If a block is black and the next block is white, flip their colors and add the position of the next block to the list.\n5. If a block is white, do nothing.\n6. If a block is black and the next block is also black, flip the color of the current block and add the position of the next block to the list.\n7. Repeat steps 3-6 until the end of the string.\n8. Create a copy of the original string of block colors.\n9. Repeat steps 3-6 for the copied string, but this time, flip the colors of the blocks in the opposite direction.\n10. If the final string of block colors has all the same color, print the length of the list of positions and the positions themselves.\n11. If the final string of block colors has all the same color, but the list of positions is empty, print 0.\n12. If the final string of block colors does not have all the same color, print -1.\n\nCOMMENTED CODE:\n```python\nfrom sys import stdin\ninput = stdin.readline\n\ndef mp():return map(int,input().split())\ndef it():return int(input())\n\n# Read the number of blocks and the string of block colors\nn=it()\ns=list(input())\ns=s[:n]  # Trim the string to the correct length\n\n# Create a copy of the string of block colors\nk=s.copy()\n\n# Initialize an empty list to store the positions of the blocks that need to be flipped\nv=[]\n\n# Iterate through the string of block colors from left to right\nfor i in range(n-1):\n    # If a block is black and the next block is white, flip their colors and add the position of the next block to the list\n    if s[i]=='B' and s[i+1]=='W':\n        s[i],s[i+1]=s[i+1],s[i]  # Flip the colors\n        v.append(i+1)  # Add the position of the next block to the list\n    # If a block is white, do nothing\n    elif s[i]=='W':\n        pass\n    # If a block is black and the next block is also black, flip the color of the current block and add the position of the next block to the list\n    elif s[i]=='B' and s[i+1]==\"B\":\n        s[i]=\"W\"  # Flip the color of the current block\n        s[i+1]='W'  # Flip the color of the next block\n        v.append(i+1)  # Add the position of the next block to the list\n\n# Create a copy of the string of block colors\nk=s.copy()\n\n# Initialize an empty list to store the positions of the blocks that need to be flipped\nt=[]\n\n# Iterate through the string of block colors from left to right\nfor i in range(n-1):\n    # If a block is white and the next block is black, flip their colors and add the position of the next block to the list\n    if k[i]=='W' and k[i+1]=='B':\n        k[i],k[i+1]=k[i+1],k[i]  # Flip the colors\n        t.append(i+1)  # Add the position of the next block to the list\n    # If a block is black, do nothing\n    elif k[i]=='B':\n        pass\n    # If a block is white and the next block is also white, flip the color of the current block and add the position of the next block to the list\n    elif k[i]=='W' and k[i+1]==\"W\":\n        k[i]=\"B\"  # Flip the color of the current block\n        k[i+1]='B'  # Flip the color of the next block\n        t.append(i+1)  # Add the position of the next block to the list\n\n# If the final string of block colors has all the same color, print the length of the list of positions and the positions themselves\nif len(set(s))==1 :\n    print(len(v))\n    print(*v)\n# If the final string of block colors has all the same color, but the list of positions is empty, print 0\nelif len(set(k))==1:\n    print(len(t))\n    print(*t)\n# If the final string of block colors does not have all the same color, print -1\nelse:\n    print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Count the number of white blocks `lw` and black blocks `lb`.\n3. Check if the number of white blocks is even or the number of black blocks is even. If not, it's impossible to make all blocks have the same color, so print -1.\n4. If the number of white blocks is even, iterate through the string `s` and perform operations to make all blocks black.\n5. If the number of black blocks is even, iterate through the string `s` and perform operations to make all blocks white.\n6. Print the number of operations and the positions of the blocks that need to be flipped.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors of the blocks\na = int(input())\nb = input()\n\n# Get the length of the string\nl = len(b)\n\n# Count the number of white blocks and black blocks\nlw = b.count('W')\nlb = b.count('B')\n\n# Convert the string to a list so we can modify it\nb = [i for i in b]\n\n# Check if it's possible to make all blocks have the same color\nif lw % 2 == 0:\n    # If the number of white blocks is even, make all blocks black\n    ans = 0\n    arr = []\n    for i in range(l - 1):\n        # If the current block is white, flip it and the next block if necessary\n        if b[i] == 'W':\n            b[i] = 'B'\n            if b[i + 1] == 'W':\n                b[i + 1] = 'B'\n            else:\n                b[i + 1] = 'W'\n            # Increment the number of operations and add the position to the array\n            ans += 1\n            arr.append(i + 1)\n    # Print the number of operations and the positions\n    print(ans)\n    print(*arr)\nelif lb % 2 == 0:\n    # If the number of black blocks is even, make all blocks white\n    ans = 0\n    arr = []\n    for i in range(l - 1):\n        # If the current block is black, flip it and the next block if necessary\n        if b[i] == 'B':\n            b[i] = 'W'\n            if b[i + 1] == 'B':\n                b[i + 1] = 'W'\n            else:\n                b[i + 1] = 'B'\n            # Increment the number of operations and add the position to the array\n            ans += 1\n            arr.append(i + 1)\n    # Print the number of operations and the positions\n    print(ans)\n    print(*arr)\nelse:\n    # If it's impossible to make all blocks have the same color, print -1\n    print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The first line contains the number of blocks `n`, and the second line contains a string `s` representing the colors of the blocks.\n2. Count the total number of black blocks `tot` and calculate the number of blocks that need to be changed to make all blocks the same color.\n3. Initialize an empty list `to_change` to store the indices of blocks that need to be changed.\n4. Check if the number of blocks that need to be changed is even. If it is, proceed to change the blocks to the desired color.\n5. If the number of blocks that need to be changed is even, iterate through the string `x` and find pairs of adjacent blocks that need to be changed. Add the indices of these blocks to `to_change`.\n6. Print the length of `to_change` and the indices in `to_change`.\n7. If the number of blocks that need to be changed is odd, it is impossible to make all blocks the same color, so print -1.\n\nCOMMENTED CODE:\n```python\n# Read the input\nlength = int(input())  # number of blocks\nx = input()  # string representing the colors of the blocks\n\n# Count the total number of black blocks and calculate the number of blocks that need to be changed\ntot = 0  # total number of black blocks\nin_binary = []  # not used in this solution\nfor i in range(length):\n    if x[i] == 'B':  # if the block is black\n        tot += 1  # increment the total number of black blocks\n\n# Initialize an empty list to store the indices of blocks that need to be changed\nto_change = []\n\n# Check if the number of blocks that need to be changed is even\nif (length - tot) % 2 == 0:  # if the number of blocks that need to be changed is even\n    # Iterate through the string x and find pairs of adjacent blocks that need to be changed\n    for i in range(length - 1):\n        if x[i] == 'W':  # if the current block is white\n            to_change.append(i + 1)  # add the index of the current block to to_change\n            if x[i + 1] == 'W':  # if the next block is also white\n                x[i + 1] = 'B'  # invert the color of the next block\n            else:  # if the next block is black\n                x[i + 1] = 'W'  # invert the color of the next block\n\n    # Print the length of to_change and the indices in to_change\n    print(len(to_change))\n    for i in to_change:\n        print(i, end=\" \")  # print the indices in to_change\n\n    # change all to black\nelif tot % 2 == 0:  # if the total number of black blocks is even\n    # Iterate through the string x and find pairs of adjacent blocks that need to be changed\n    for i in range(length - 1):\n        if x[i] == 'B':  # if the current block is black\n            to_change.append(i + 1)  # add the index of the current block to to_change\n            if x[i + 1] == 'B':  # if the next block is also black\n                x[i + 1] = 'W'  # invert the color of the next block\n            else:  # if the next block is white\n                x[i + 1] = 'B'  # invert the color of the next block\n\n    # Print the length of to_change and the indices in to_change\n    print(len(to_change))\n    for i in to_change:\n        print(i, end=\" \")  # print the indices in to_change\n\nelse:  # if the number of blocks that need to be changed is odd\n    # It is impossible to make all blocks the same color, so print -1\n    print(\"-1\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Create two copies of the string `s`, `s1` and `s2`, and reverse them. This is done to handle the case where the number of white blocks is odd, as we will need to alternate between the two strings to find a valid sequence of operations.\n3. Initialize an empty list `ans` to store the positions of the blocks that need to be inverted.\n4. Iterate over the blocks from left to right (or right to left for `s2`).\n5. If the current block is white (or black for `s2`), append its position to `ans` and invert the color of the next block.\n6. After the loop, check if the last block is black (or white for `s2`). If it is, print the length of `ans` and the positions in `ans` separated by spaces.\n7. If the last block is not the desired color, it means that it is impossible to make all blocks have the same color, so print -1.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors of the blocks\nn = int(input())\ns = list(reversed(input()))\n# Create two copies of the string s, s1 and s2, and reverse them\ns1 = s[::-1]\ns2 = s[::-1]\n# Initialize an empty list to store the positions of the blocks that need to be inverted\nans = []\n# Iterate over the blocks from left to right (or right to left for s2)\nfor i in range(n-1):\n    # If the current block is white (or black for s2), append its position to ans and invert the color of the next block\n    if s1[i] == 'W':\n        ans.append(i+1)\n        if s1[i+1] == 'W':\n            s1[i+1] = 'B'\n        else:\n            s1[i+1] = 'W'\n# After the loop, check if the last block is black (or white for s2)\nif s1[n-1] == 'B':\n    # If it is, print the length of ans and the positions in ans separated by spaces\n    print(len(ans))\n    print(*ans, sep=' ')\nelse:\n    # If the last block is not the desired color, reset ans\n    ans = []\n    # Iterate over the blocks from left to right (or right to left for s2)\n    for i in range(n-1):\n        # If the current block is black (or white for s2), append its position to ans and invert the color of the next block\n        if s2[i] == 'B':\n            ans.append(i+1)\n            if s2[i+1] == 'B':\n                s2[i+1] = 'W'\n            else:\n                s2[i+1] = 'B'\n    # After the loop, check if the last block is white (or black for s2)\n    if s2[n-1] == 'W':\n        # If it is, print the length of ans and the positions in ans separated by spaces\n        print(len(ans))\n        print(*ans, sep=' ')\n    else:\n        # If the last block is not the desired color, it means that it is impossible to make all blocks have the same color, so print -1\n        print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The first line contains the number of blocks `n`, and the second line contains a string `s` representing the colors of the blocks.\n2. Check if `n` is odd: If `n` is odd, it's possible to make all blocks the same color by inverting the colors of every other block. Determine the target color `t` based on the count of white blocks.\n3. Iterate through the blocks: For each pair of adjacent blocks, check if they have the same color as the target color `t`. If not, invert their colors and add the position of the left block to the result array.\n4. If `n` is even: Check if the count of white blocks is odd. If it is, it's impossible to make all blocks the same color, so print -1.\n5. If `n` is even and the count of white blocks is even: Create two arrays to store the positions of the blocks to be inverted for each possible target color.\n6. Iterate through the blocks: For each pair of adjacent blocks, check if they have the same color as the target color `t`. If not, invert their colors and add the position of the left block to the corresponding array.\n7. Compare the lengths of the two arrays: Print the length of the shorter array and the corresponding positions.\n\nCOMMENTED CODE:\n```python\n# Read the input\nn = int(input())\ns = list(input())\n\n# Check if n is odd\nif n % 2 == 1:\n    # Determine the target color t based on the count of white blocks\n    t = 'W' if s.count('W') % 2 == 1 else 'B'\n    o = 'B' if t == 'W' else 'W'\n\n    # Initialize variables to store the result\n    c = 0\n    array = []\n\n    # Iterate through the blocks\n    for i in range(n - 1):\n        # Check if the current block and the next block have the same color as the target color t\n        if s[i] == o and s[i + 1] == o:\n            # If they do, invert their colors and add the position of the left block to the result array\n            s[i] = t\n            s[i + 1] = t\n            c += 1\n            array.append(i + 1)\n        elif s[i] == o and s[i + 1] == t:\n            # If they don't, invert their colors and add the position of the left block to the result array\n            s[i], s[i + 1] = s[i + 1], s[i]\n            c += 1\n            array.append(i + 1)\n\n    # Print the result\n    print(c)\n    print(*array)\n\n# If n is even\nif n % 2 == 0:\n    # Check if the count of white blocks is odd\n    if s.count('W') % 2 == 1:\n        # If it is, it's impossible to make all blocks the same color, so print -1\n        print(-1)\n    else:\n        # Create two arrays to store the positions of the blocks to be inverted for each possible target color\n        r = s.copy()\n        t = 'W'\n        o = 'B'\n        c1 = 0\n        array1 = []\n\n        # Iterate through the blocks\n        for i in range(n - 1):\n            # Check if the current block and the next block have the same color as the target color t\n            if s[i] == o and s[i + 1] == o:\n                # If they do, invert their colors and add the position of the left block to the first array\n                s[i] = t\n                s[i + 1] = t\n                c1 += 1\n                array1.append(i + 1)\n            elif s[i] == o and s[i + 1] == t:\n                # If they don't, invert their colors and add the position of the left block to the first array\n                s[i], s[i + 1] = s[i + 1], s[i]\n                c1 += 1\n                array1.append(i + 1)\n\n        # Create the second array\n        s = r\n        array = []\n        t = 'B'\n        o = 'W'\n        c2 = 0\n\n        # Iterate through the blocks\n        for i in range(n - 1):\n            # Check if the current block and the next block have the same color as the target color t\n            if s[i] == o and s[i + 1] == o:\n                # If they do, invert their colors and add the position of the left block to the second array\n                s[i] = t\n                s[i + 1] = t\n                c2 += 1\n                array.append(i + 1)\n            elif s[i] == o and s[i + 1] == t:\n                # If they don't, invert their colors and add the position of the left block to the second array\n                s[i], s[i + 1] = s[i + 1], s[i]\n                c2 += 1\n                array.append(i + 1)\n\n        # Compare the lengths of the two arrays\n        if c1 < c2:\n            # Print the length of the shorter array and the corresponding positions\n            print(c1)\n            print(*array1)\n        else:\n            print(c2)\n            print(*array)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Count the number of white and black blocks.\n3. Convert the string `s` into a list of integers where 0 represents a white block and 1 represents a black block.\n4. Check if it's impossible to make all blocks the same color by checking if both counts of white and black blocks are odd.\n5. If all blocks are already the same color, print 0 and exit.\n6. If all blocks are white, iterate through the list and invert the colors of adjacent blocks that are white, and add their positions to the answer list.\n7. If the first and last blocks are not the same color, add the positions of every other block to the answer list.\n8. Print the length of the answer list and the positions in the list.\n9. If all blocks are black, repeat steps 6 and 7.\n10. If the first and last blocks are not the same color, add the positions of every other block to the answer list.\n\nCOMMENTED CODE:\n```python\nimport sys \ninput=sys.stdin.readline \n\n# Read the input: The number of blocks n and the string s representing the colors of the blocks.\nn=int(input())\ns=input().strip()\n\n# Convert the string s into a list of characters\ns=list(s)\n\n# Count the number of white and black blocks\na=s.count('W')\nb=s.count(\"B\")\n\n# Convert the list of characters into a list of integers where 0 represents a white block and 1 represents a black block.\nfor i in range(n):\n    if s[i]=='W': \n        s[i]=0 # White block becomes 0\n    else:\n        s[i]=1 # Black block becomes 1\n\n# Check if it's impossible to make all blocks the same color by checking if both counts of white and black blocks are odd.\nif a&1 and b&1:\n    # If it's impossible, print -1 and exit.\n    print(-1)\n    exit()\n\n# If all blocks are already the same color, print 0 and exit.\nif a%2==0: \n    # All blocks are white\n    ans=[]\n    for i in range(n-1):\n        if s[i]==0:\n            # Invert the colors of adjacent blocks that are white\n            s[i]=1-s[i]\n            s[i+1]=1-s[i+1]\n            # Add the position of the left block to the answer list\n            ans.append(i+1)\n            # print(s)\n    \n    # If the first and last blocks are not the same color, add the positions of every other block to the answer list.\n    if s[0]!=s[-1]:\n        for i in range(0,n-1,2):\n            ans.append(i+1)\n    # Print the length of the answer list and the positions in the list.\n    print(len(ans))\n    print(*ans)\nelif b%2==0:\n    # All blocks are black\n    ans=[]\n    for i in range(n-1):\n        if s[i]==1:\n            # Invert the colors of adjacent blocks that are black\n            s[i]=1-s[i]\n            s[i+1]=1-s[i+1]\n            # Add the position of the left block to the answer list\n            ans.append(i+1)\n    # print(s)\n    # If the first and last blocks are not the same color, add the positions of every other block to the answer list.\n    if s[0]!=s[-1]:\n        for i in range(0,n-1,2):\n            ans.append(i+1)\n    # Print the length of the answer list and the positions in the list.\n    print(len(ans))\n    print(*ans)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Initialize an empty list `res` to store the final sequence of operations.\n3. Initialize a flag `changes` to track if any changes are made in the current iteration.\n4. Iterate through the blocks, checking for consecutive blocks of the same color (three blocks in a row) and invert their colors if found.\n5. If any changes are made, update the `changes` flag and continue to the next iteration.\n6. Once no more changes are made, proceed to the next step.\n7. Initialize a list `res1` to store the sequence of operations for making all blocks of the same color.\n8. Iterate through the blocks, checking for consecutive blocks of the same color (two blocks in a row) and invert their colors if found.\n9. If a pair of blocks of the same color is found, add the position of the left block to `res1` and update the colors of the blocks.\n10. If all blocks are of the same color, add `res1` to `res` and proceed to the next step.\n11. Repeat steps 7-10 for making all blocks of the opposite color.\n12. If `res` is not empty, print the length of the first sequence in `res` and the sequence itself.\n13. If `subans` is not empty, print the length of `subans` and the sequence itself.\n14. If both `res` and `subans` are empty, print -1.\n\nCOMMENTED CODE:\n```python\nn = int(input())  # Read the number of blocks\ninp = list(input())  # Read the string representing the colors of the blocks\nres = []  # Initialize an empty list to store the final sequence of operations\nres1 = []  # Initialize a list to store the sequence of operations for making all blocks of the same color\nsubans = []  # Initialize a list to store the sequence of operations for making all blocks of the same color\nind = 0  # Initialize an index to track the current block\nchanges = True  # Initialize a flag to track if any changes are made in the current iteration\n\n# Iterate through the blocks, checking for consecutive blocks of the same color (three blocks in a row) and invert their colors if found\nwhile changes:\n    changes = False  # Reset the flag at the beginning of each iteration\n    ind = 0  # Reset the index at the beginning of each iteration\n    while ind < n - 2:  # Iterate through the blocks\n        if inp[ind] == 'B' and inp[ind + 1] == 'W' and inp[ind + 2] == 'B':  # Check for consecutive blocks of the same color\n            inp[ind] = 'W'  # Invert the color of the left block\n            inp[ind + 1] = 'W'  # Invert the color of the middle block\n            inp[ind + 2] = 'W'  # Invert the color of the right block\n            subans.append(ind + 1)  # Add the position of the left block to the sequence\n            subans.append(ind + 2)  # Add the position of the middle block to the sequence\n            changes = True  # Update the flag\n        if inp[ind] == 'W' and inp[ind + 1] == 'B' and inp[ind + 2] == 'W':  # Check for consecutive blocks of the same color\n            inp[ind] = 'B'  # Invert the color of the left block\n            inp[ind + 1] = 'B'  # Invert the color of the middle block\n            inp[ind + 2] = 'B'  # Invert the color of the right block\n            subans.append(ind + 1)  # Add the position of the left block to the sequence\n            subans.append(ind + 2)  # Add the position of the middle block to the sequence\n            changes = True  # Update the flag\n        ind += 1  # Move to the next block\n\n# Once no more changes are made, proceed to the next step\nind = 0\nbf = inp[:]  # Create a copy of the input list\nwhile ind < n - 1:  # Iterate through the blocks\n    if bf[ind] == bf[ind + 1] == 'W':  # Check for consecutive blocks of the same color\n        res1.append(ind + 1)  # Add the position of the left block to the sequence\n        bf[ind] = 'B'  # Invert the color of the left block\n        bf[ind + 1] = 'B'  # Invert the color of the middle block\n        ind += 2  # Move to the next pair of blocks\n    else:\n        if bf[ind] == 'W':  # Check if the current block is white\n            bf[ind] = 'B'  # Invert the color of the current block\n            bf[ind + 1] = 'B' if bf[ind + 1] == 'W' else 'W'  # Invert the color of the next block\n            res1.append(ind + 1)  # Add the position of the current block to the sequence\n        ind += 1  # Move to the next block\n\n# If all blocks are of the same color, add the sequence to res\nif 'W' not in bf:\n    res.append(res1)\n\n# Repeat the process for making all blocks of the opposite color\nind = 0\nres1 = []\nbf = inp[:]\nwhile ind < n - 1:  # Iterate through the blocks\n    if bf[ind] == bf[ind + 1] == 'B':  # Check for consecutive blocks of the same color\n        res1.append(ind + 1)  # Add the position of the left block to the sequence\n        bf[ind] = 'W'  # Invert the color of the left block\n        bf[ind + 1] = 'W'  # Invert the color of the middle block\n        ind += 2  # Move to the next pair of blocks\n    else:\n        if bf[ind] == 'B':  # Check if the current block is black\n            bf[ind] = 'W'  # Invert the color of the current block\n            bf[ind + 1] = 'W' if bf[ind + 1] == 'B' else 'B'  # Invert the color of the next block\n            res1.append(ind + 1)  # Add the position of the current block to the sequence\n        ind += 1  # Move to the next block\n\n# If all blocks are of the opposite color, add the sequence to res\nif 'B' not in bf:\n    res.append(res1)\n\n# Print the result\nif 'W' not in inp or 'B' not in inp:\n    print(len(subans))  # Print the length of the sequence\n    print(*subans)  # Print the sequence\nelse:\n    if len(res) == 0 and len(subans) == 0:\n        print(-1)  # Print -1 if no sequence is found\n    else:\n        if len(res) == 0:\n            if 'W' not in inp or 'B' not in inp:\n                print(len(subans))  # Print the length of the sequence\n                print(*subans)  # Print the sequence\n            else:\n                print(-1)  # Print -1 if no sequence is found\n        elif len(subans) == 0:\n            print(len(res[0]))  # Print the length of the sequence\n            print(*res[0])  # Print the sequence\n        else:\n            print(len(subans) + len(res[0]))  # Print the length of the combined sequence\n            print(*(subans + res[0]))  # Print the combined sequence\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the sequence of block colors `s`.\n2. Count the number of black blocks `sB` and white blocks `sW`.\n3. Check if it's impossible to make all blocks the same color by verifying if both `sB` and `sW` are odd or if `sB` is less than `sW` and both are even.\n4. If it's impossible, print -1 and exit.\n5. If `sW` is odd and `sB` is even, invert all block colors.\n6. Iterate through the sequence of block colors and perform operations to make all blocks the same color.\n7. If two adjacent blocks are white, invert their colors and add the position of the left block to the output list.\n8. If two adjacent blocks are black and white, swap their colors and add the position of the left block to the output list.\n9. Print the number of operations and the positions of the blocks that were inverted.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the sequence of block colors\nn = int(input())\ns = list(input())\n\n# Count the number of black blocks and white blocks\nsB = 0\nsW = 0\nfor i in range(len(s)):\n    if s[i] == 'W':\n        sW += 1\n    else:\n        sB += 1\n\n# Check if it's impossible to make all blocks the same color\nif sW % 2 == 1 and sB % 2 == 1:\n    # If both counts are odd, it's impossible to make all blocks the same color\n    print(-1)\n    exit()\nif (sW % 2 == 1 and sB % 2 == 0) or (sW % 2 == 0 and sB % 2 == 0 and sB < sW):\n    # If sW is odd and sB is even, or if both are even but sB is less than sW, invert all block colors\n    for i in range(len(s)):\n        if s[i] == 'W':\n            s[i] = 'B'\n        else:\n            s[i] = 'W'\n\n# Initialize an empty list to store the positions of the blocks that were inverted\nout = []\n\n# Iterate through the sequence of block colors and perform operations to make all blocks the same color\nfor i in range(len(s) - 1):\n    if s[i] == 'W' and s[i + 1] == 'W':\n        # If two adjacent blocks are white, invert their colors and add the position of the left block to the output list\n        s[i] = 'B'\n        s[i + 1] = 'B'\n        out.append(str(i + 1))\n    elif s[i] == 'W' and s[i + 1] == 'B':\n        # If two adjacent blocks are black and white, swap their colors and add the position of the left block to the output list\n        s[i], s[i + 1] = s[i + 1], s[i]\n        out.append(str(i + 1))\n\n# Print the number of operations and the positions of the blocks that were inverted\nprint(len(out))\nprint(' '.join(out))\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Initialize two empty lists `ans1` and `ans2` to store the indices of the blocks that need to be flipped to make all blocks black and white respectively.\n3. Initialize a counter `count` to keep track of the number of operations performed.\n4. Iterate through the string `s` from left to right. If two adjacent blocks are both black, skip them. If two adjacent blocks are both white, skip them. If one block is black and the next is white, flip the black block and increment the counter and `ans1` list.\n5. If all blocks are black after the first iteration, print the count and the indices in `ans1` if the count is not zero.\n6. If not all blocks are black, iterate through the string again. If two adjacent blocks are both white, skip them. If two adjacent blocks are both black, skip them. If one block is white and the next is black, flip the white block and increment the counter and `ans2` list.\n7. If all blocks are white after the second iteration, print the count and the indices in `ans2` if the count is not zero.\n8. If not all blocks are white, print -1.\n\nCOMMENTED CODE:\n```python\nn = int(input())  # Read the number of blocks\nstring = input()  # Read the string representing the colors of the blocks\ns = list(string)  # Convert the string to a list for easier manipulation\n\n# Initialize two empty lists to store the indices of the blocks that need to be flipped\nans1 = []\nans2 = []\n\n# Initialize a counter to keep track of the number of operations performed\ncount = 0\n\n# First iteration to make all blocks black\ni = 0\nwhile i < n-1:\n    # If two adjacent blocks are both black, skip them\n    if s[i] == 'B' and s[i+1] == 'B':\n        i+=2\n    \n    # If two adjacent blocks are both white, skip them\n    elif s[i] == 'W' and s[i+1] == 'W':\n        i+=2\n    \n    # If one block is black and the next is white, flip the black block\n    elif s[i] == 'B' and s[i+1] == 'W':\n        i+=1\n    \n    # If one block is white and the next is black, flip the white block and increment the counter and ans1 list\n    elif s[i] == 'W' and s[i+1] == 'B':\n        s[i],s[i+1] = s[i+1],s[i]  # Flip the blocks\n        count+=1\n        ans1.append(i+1)  # Store the index of the flipped block\n        i+=1\n        \n    else:\n        # If two adjacent blocks are both black, flip them and increment the counter and ans1 list\n        s[i],s[i+1] = 'W','W'\n        count+=1\n        ans1.append(i+1)  # Store the index of the flipped block\n        i+=2\n\n# Check if all blocks are black\nif s.count('W')==0:\n    print(count)  # Print the count\n    if count!=0:\n        for i in ans1:\n            print(i,end=' ')  # Print the indices in ans1\n        print()\n\n# Second iteration to make all blocks white\nelse:\n    i = 0\n    count = 0\n    s = list(string)  # Convert the string to a list for easier manipulation\n    while i < n-1:\n        # If two adjacent blocks are both white, skip them\n        if s[i] == 'W' and s[i+1] == 'W':\n            i+=2\n        \n        # If two adjacent blocks are both black, skip them\n        elif s[i] == 'B' and s[i+1] == 'B':\n            i+=2\n        \n        # If one block is white and the next is black, flip the white block\n        elif s[i] == 'W' and s[i+1] == 'B':\n            i+=1\n        \n        # If one block is black and the next is white, flip the black block and increment the counter and ans2 list\n        elif s[i] == 'B' and s[i+1] == 'W':\n            s[i],s[i+1] = s[i+1],s[i]  # Flip the blocks\n            count+=1\n            ans2.append(i+1)  # Store the index of the flipped block\n            i+=1\n            \n        else:\n            # If two adjacent blocks are both white, flip them and increment the counter and ans2 list\n            s[i],s[i+1] = 'B','B'\n            count+=1\n            ans2.append(i+1)  # Store the index of the flipped block\n            i+=2\n\n# Check if all blocks are white\nif s.count('B')==0:\n    print(count)  # Print the count\n    \n    if count!=0:\n        for i in ans2:\n            print(i,end=' ')  # Print the indices in ans2\n        print()\n    \nelse:\n    print(-1)  # Print -1 if not all blocks are white\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the color sequence `t` from the input.\n2. Convert the color sequence `t` into a list of integers `m`, where `m[i]` is 0 if the `i-th` block is white and 1 if it's black.\n3. Initialize an empty list `r` to store the indices of blocks that need to be flipped.\n4. Iterate through the list `m` from the second element to the second last element. If the current element is different from the previous one, add the current index to `r`, flip the current and next elements in `m`, and continue to the next iteration.\n5. After the loop, check if the first and last elements of `m` are different. If they are and the total number of blocks `n` is odd, flip the elements in `m` in pairs starting from the first element until the middle of the list.\n6. Check if the sum of elements in `m` is equal to `n` or 0. If it is, set a flag `f` to `True`.\n7. If `f` is `True` or the sum of elements in `m` is equal to `n` or 0, print the length of `r` and the elements in `r` if `r` is not empty. Otherwise, print -1.\n\nCOMMENTED CODE:\n```python\nn = int(input())  # Read the number of blocks\nt = list(input())  # Read the color sequence\nr = []  # Initialize an empty list to store the indices of blocks that need to be flipped\nf = False  # Initialize a flag to check if it's possible to make all blocks the same color\nm = [0 if i == 'W' else 1 for i in t]  # Convert the color sequence into a list of integers\n\n# Iterate through the list m to find the indices of blocks that need to be flipped\nfor i in range(1, len(m) - 1):\n    if m[i]!= m[i - 1]:  # Check if the current element is different from the previous one\n        r.append(i + 1)  # Add the current index to r\n        m[i] ^= 1  # Flip the current element\n        m[i + 1] ^= 1  # Flip the next element\n\n# Check if the first and last elements of m are different\nif m[0]!= m[-1]:\n    if len(t) % 2!= 0:  # Check if the total number of blocks is odd\n        # Flip the elements in m in pairs starting from the first element until the middle of the list\n        for i in range(0, len(m), 2):\n            if i + 1 < len(m):\n                r.append(i + 1)  # Add the current index to r\n                m[i] ^= 1  # Flip the current element\n                m[i + 1] ^= 1  # Flip the next element\n\n# Check if it's possible to make all blocks the same color\nif f or sum(m) == n or sum(m) == 0:\n    print(len(r))  # Print the length of r\n    if len(r):\n        for i in r:\n            print(i, end=' ')  # Print the elements in r\n        print()\nelse:\n    print(-1)  # Print -1 if it's impossible to make all blocks the same color\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The first step is to read the number of blocks (n) and the string representing the colors of the blocks (s).\n2. Count the number of black and white blocks: Initialize two counters (b and w) to count the number of black and white blocks, respectively.\n3. Check if it's impossible to make all blocks the same color: If the number of black blocks and white blocks are both odd, it's impossible to make all blocks the same color, so print -1.\n4. Check if all blocks are already the same color: If either all blocks are black or all blocks are white, no operations are needed, so print 0.\n5. Determine the target color: If the number of black blocks and white blocks are both even, choose the color with the smaller count as the target color. Otherwise, choose the color with the smaller count modulo 2 as the target color.\n6. Perform operations to make all blocks the target color: Iterate through the blocks and perform operations to make all blocks the target color. If a block is already the target color, skip it. If two adjacent blocks are not the target color, invert their colors and add the index of the left block to the operations list.\n7. Print the number of operations and the operations list: Print the number of operations and the list of indices of the blocks that were inverted.\n\nCOMMENTED CODE:\n```python\n# Read the input\nn = int(input())  # number of blocks\ns = list(input().strip())  # string representing the colors of the blocks\n\n# Count the number of black and white blocks\nb = 0  # counter for black blocks\nw = 0  # counter for white blocks\nfor i in range(n):\n    if s[i] == \"B\":  # if the block is black\n        b += 1  # increment the black block counter\n    else:  # if the block is white\n        w += 1  # increment the white block counter\n\n# Check if it's impossible to make all blocks the same color\nif b % 2 == 1 and w % 2 == 1:  # if both black and white blocks are odd\n    print(-1)  # it's impossible to make all blocks the same color\nelif b == 0 or w == 0:  # if all blocks are already the same color\n    print(0)  # no operations are needed\n\nelse:  # if it's possible to make all blocks the same color\n    # Determine the target color\n    if b % 2 == 0 and w % 2 == 0:  # if both black and white blocks are even\n        if b < w:  # if there are fewer black blocks\n            target_color = \"B\"  # the target color is black\n        else:  # if there are fewer white blocks\n            target_color = \"W\"  # the target color is white\n    elif b % 2 == 0:  # if there are even black blocks\n        target_color = \"B\"  # the target color is black\n    else:  # if there are even white blocks\n        target_color = \"W\"  # the target color is white\n\n    # Perform operations to make all blocks the target color\n    op = []  # list to store the operations\n    for i in range(n - 1):  # iterate through the blocks\n        if s[i]!= target_color:  # if the block is not the target color\n            if s[i] < target_color:  # if the block is white and the target color is black\n                s[i], s[i + 1] = s[i + 1], s[i]  # invert the colors of the two blocks\n                op.append(i + 1)  # add the index of the left block to the operations list\n            elif s[i] == s[i + 1] == \"B\":  # if the two blocks are both black\n                s[i], s[i + 1] = \"W\", \"W\"  # invert the colors of the two blocks\n                op.append(i + 1)  # add the index of the left block to the operations list\n\n    # Print the number of operations and the operations list\n    print(len(op))  # print the number of operations\n    print(\" \".join(map(str, op)))  # print the operations list\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n\n1. Read the number of blocks and the initial color configuration from the input.\n2. Create a copy of the initial color configuration to check for the opposite color.\n3. Initialize an empty list to record the changes made during the operations.\n4. Perform a depth-first search (DFS) to find a sequence of operations that makes all blocks the same color, starting with white.\n5. If the DFS with white as the target color is successful, print the number of operations and the positions of the blocks that need to be changed.\n6. If the DFS with white as the target color fails, reset the color configuration to its initial state and repeat steps 4-5 with black as the target color.\n7. If both DFS attempts fail, print -1 to indicate that it's impossible to make all blocks the same color.\n\nCOMMENTED CODE:\n\n```python\ndef paint(blocks, num, colour, idx, changelist):\n    # Base case: if we've reached the end of the blocks\n    if (idx == num - 1):\n        # If the last block is the target color, return True\n        if (blocks[idx] == colour):\n            return True\n        # If the last block is not the target color, return False\n        else:\n            return False\n\n    # If the current block is the target color, recursively check the next block\n    if (blocks[idx] == colour):\n        return paint(blocks, num, colour, idx + 1, changelist)\n    # If the current block is not the target color, invert its color and the next block's color\n    else:\n        blocks[idx] = colour\n        # If the next block is black, invert its color\n        if (blocks[idx + 1] == \"B\"):\n            blocks[idx + 1] = \"W\"\n        # If the next block is white, invert its color\n        else:\n            blocks[idx + 1] = \"B\"\n        # Add the current index to the changelist\n        changelist.append(idx)\n        # Recursively check the next block\n        return paint(blocks, num, colour, idx + 1, changelist)\n\n\nif __name__ == \"__main__\":\n    # Read the number of blocks from the input\n    num = int(input())\n    # Read the initial color configuration from the input\n    blocks = list(str(input()))\n    # Create a copy of the initial color configuration to check for the opposite color\n    dblocks = blocks.copy()\n    # Initialize an empty list to record the changes made during the operations\n    changelist = list()\n    # Try to make all blocks white\n    col = \"W\"\n    val = paint(blocks, num, col, 0, changelist)\n    # If the DFS with white as the target color is successful, print the number of operations and the positions of the blocks that need to be changed\n    if (val == True):\n        print(len(changelist))\n        for i in changelist:\n            print(i + 1, end=\" \")\n        exit(0)\n    # If the DFS with white as the target color fails, reset the color configuration to its initial state and try to make all blocks black\n    changelist = list()\n    col = \"B\"\n    val = paint(dblocks, num, col, 0, changelist)\n    # If the DFS with black as the target color is successful, print the number of operations and the positions of the blocks that need to be changed\n    if (val == True):\n        print(len(changelist))\n        for i in changelist:\n            print(i + 1, end=\" \")\n        exit(0)\n    # If both DFS attempts fail, print -1 to indicate that it's impossible to make all blocks the same color\n    else:\n        print(\"-1\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the color sequence `s` from the input.\n2. Initialize two lists `ans1` and `ans2` to store the indices of blocks to be flipped to make all blocks black and white, respectively.\n3. Iterate through the blocks from left to right, flipping the color of the current block and the next block if they are different.\n4. If the last block is white after flipping, print the length of `ans1` and the indices in `ans1` if it's not empty.\n5. Otherwise, iterate through the blocks again, flipping the color of the current block and the next block if they are different, and store the indices in `ans2`.\n6. If the last block is not white after flipping, print the length of `ans2` and the indices in `ans2` if it's not empty. Otherwise, print -1.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks n and the color sequence s from the input\nn = int(input())\ns1 = list(input())  # Convert the input string to a list for easier manipulation\ns2 = s1[:]  # Create a copy of the original list\n\n# Initialize two lists to store the indices of blocks to be flipped\nans1 = []\nans2 = []\n\n# Iterate through the blocks from left to right, flipping the color of the current block and the next block if they are different\nfor i in range(n - 1):\n    if s1[i] == 'B':  # If the current block is black\n        s1[i] = 'W'  # Flip its color to white\n        if s1[i + 1] == 'B':  # If the next block is black\n            s1[i + 1] = 'W'  # Flip its color to white\n        else:  # If the next block is white\n            s1[i + 1] = 'B'  # Flip its color to black\n        ans1.append(i + 1)  # Store the index of the block that was flipped\n\n# Check if the last block is white after flipping\nif s1[n - 1] == 'W':\n    print(len(ans1))  # Print the length of ans1\n    if len(ans1) > 0:  # If ans1 is not empty\n        print(*ans1)  # Print the indices in ans1\n\nelse:\n    # Iterate through the blocks again, flipping the color of the current block and the next block if they are different, and store the indices in ans2\n    for i in range(n - 1):\n        if s2[i] == 'W':  # If the current block is white\n            s2[i] = 'B'  # Flip its color to black\n            if s2[i + 1] == 'W':  # If the next block is white\n                s2[i + 1] = 'B'  # Flip its color to black\n            else:  # If the next block is black\n                s2[i + 1] = 'W'  # Flip its color to white\n            ans2.append(i + 1)  # Store the index of the block that was flipped\n\n    # Check if the last block is not white after flipping\n    if s2[n - 1]!= 'W':\n        print(len(ans2))  # Print the length of ans2\n        if len(ans2) > 0:  # If ans2 is not empty\n            print(*ans2)  # Print the indices in ans2\n    else:\n        print(\"-1\")  # Print -1 if it's impossible to make all blocks have the same color\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Convert the string `s` into a list of integers `l` where 0 represents a black block and 1 represents a white block.\n3. Check if all blocks have the same color by converting the list `l` back into a set of integers. If the length of the set is 1, it means all blocks have the same color, and we can print 0 as the number of operations.\n4. Initialize an empty list `p` to store the positions of the blocks that need to be flipped, and a counter `c` to count the number of operations.\n5. Iterate through the list `s` (or `l`) from left to right. If the current block is black (0), continue to the next block. Otherwise, flip the current block and the next block by changing their values in `s` and `l`, and append the position of the current block to `p`. Increment `c` by 1.\n6. After the iteration, check if all blocks have the same color by converting the list `s` (or `l`) back into a set of integers. If the length of the set is 1, it means all blocks have the same color, and we can print `c` as the number of operations and `p` as the positions of the blocks that need to be flipped.\n7. If the length of the set is not 1, it means it is impossible to make all blocks have the same color, so we print -1.\n\nCOMMENTED CODE:\n```python\nn=int(input())  # Read the number of blocks\ns=input()  # Read the string representing the colors of the blocks\nl=list(s)  # Convert the string s into a list of integers\ns=list(s)  # Convert the string s into a list of integers (for flipping)\nfor i in range(n):  # Convert the list s into a list of integers where 0 represents a black block and 1 represents a white block\n    if s[i]=='W':  # If the current block is white\n        s[i]=1  # Convert it to 1\n        l[i]=1  # Convert it to 1 in the other list\n    else:  # If the current block is black\n        s[i]=0  # Convert it to 0\n        l[i]=0  # Convert it to 0 in the other list\nf=1  # Initialize a flag to check if all blocks have the same color\np=[]  # Initialize an empty list to store the positions of the blocks that need to be flipped\nc=0  # Initialize a counter to count the number of operations\nfor i in range(n-1):  # Iterate through the list s from left to right\n    if s[i]==1:  # If the current block is white\n        continue  # Skip to the next block\n    else:  # If the current block is black\n        p.append(i+1)  # Append the position of the current block to p\n        s[i]=1-s[i]  # Flip the current block\n        s[i+1]=1-s[i+1]  # Flip the next block\n        c+=1  # Increment c by 1\n    #print(s)  # Print the list s after flipping\n    #print(p)  # Print the list p\nif len(set(s))==1:  # Check if all blocks have the same color\n    print(c)  # Print c as the number of operations\n    if c>0:  # If c is greater than 0\n        print(*p)  # Print p as the positions of the blocks that need to be flipped\nelse:  # If all blocks do not have the same color\n    p=[]  # Initialize an empty list to store the positions of the blocks that need to be flipped\n    c=0  # Initialize a counter to count the number of operations\n    #print('l',l)  # Print the list l\n    for i in range(n-1):  # Iterate through the list l from left to right\n        if l[i]==0:  # If the current block is black\n            continue  # Skip to the next block\n        else:  # If the current block is white\n            p.append(i+1)  # Append the position of the current block to p\n            l[i]=1-l[i]  # Flip the current block\n            l[i+1]=1-l[i+1]  # Flip the next block\n            c+=1  # Increment c by 1\n    if len(set(l))==1:  # Check if all blocks have the same color\n        print(c)  # Print c as the number of operations\n        if c>0:  # If c is greater than 0\n            print(*p)  # Print p as the positions of the blocks that need to be flipped\n    else:  # If all blocks do not have the same color\n        print(-1)  # Print -1\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `sq` representing the colors of the blocks.\n2. Count the number of black and white blocks.\n3. Check if all blocks are of the same color. If so, print 0 and exit.\n4. Check if the number of black and white blocks is both odd. If so, it's impossible to make all blocks the same color, so print -1 and exit.\n5. Determine the target color `c_to` and the other color `other`.\n6. Initialize an empty list `ans` to store the indices of the blocks that need to be flipped.\n7. Iterate through the blocks pair-wise, flipping the colors of adjacent blocks if they are different and the color is not the target color.\n8. After each pair-wise iteration, check if all blocks are of the target color. If so, print the length of `ans`, add 1 to each index in `ans`, and print the resulting list of indices, then exit.\n9. If not all blocks are of the target color after the pair-wise iteration, repeat steps 7 and 8 until all blocks are of the target color or it's impossible to make all blocks the same color.\n\nCOMMENTED CODE:\n```python\nn = int(input())  # Read the number of blocks\nsq = input().strip()  # Read the string representing the colors of the blocks\nsq = list(sq)  # Convert the string to a list for easier manipulation\n\n# Count the number of black and white blocks\nb, w = (0, 0)\nfor ch in sq:\n    if ch == 'B':\n        b += 1\n    else:\n        w += 1\n\n# Check if all blocks are of the same color\nif b == 0 or w == 0:\n    print(0)  # If all blocks are of the same color, print 0 and exit\n    exit(0)\n\n# Check if the number of black and white blocks is both odd\nelif b & 1 == 1 and w & 1 == 1:\n    print(-1)  # If the number of black and white blocks is both odd, it's impossible to make all blocks the same color\n    exit(0)\n\n# Determine the target color and the other color\nc_to = None\nother = None\nif b & 1:  # If the number of black blocks is odd, make black the target color\n    c_to = 'B'\n    other = 'W'\nelse:  # Otherwise, make white the target color\n    c_to = 'W'\n    other = 'B'\n\nans = []  # Initialize an empty list to store the indices of the blocks that need to be flipped\n\n# Iterate through the blocks pair-wise, flipping the colors of adjacent blocks if they are different and the color is not the target color\nwhile True:\n    for i in range(1, n):\n        if sq[i-1]!= sq[i] and sq[i-1] == other:  # If the colors of adjacent blocks are different and the color is not the target color\n            sq[i-1] = sq[i]  # Flip the color of the first block\n            sq[i] = other  # Flip the color of the second block\n            ans.append(i-1)  # Add the index of the first block to the list of indices\n\n        if sq[i-1] == sq[i] and sq[i-1]!= c_to:  # If the colors of adjacent blocks are the same and not the target color\n            sq[i-1] = sq[i] = c_to  # Flip the colors of both blocks to the target color\n            ans.append(i-1)  # Add the index of the first block to the list of indices\n\n    cc = sq.count(other)  # Count the number of blocks with the other color\n    # print(sq)  # Uncomment this line for debugging purposes\n    if cc == 0 or cc == n:  # If all blocks are of the target color or all blocks are of the other color\n        print(len(ans))  # Print the length of the list of indices\n        ans = list(map(lambda x: x + 1, ans))  # Add 1 to each index in the list\n        print(*ans)  # Print the list of indices\n        exit(0)  # Exit the program\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Initialize an empty list `fs` to store the indices of the blocks that need to be flipped.\n3. Iterate through the string `s` from left to right, considering each block and its adjacent blocks.\n4. If the current block and its adjacent blocks have the same color, move to the next block.\n5. If the current block and its adjacent block have different colors, flip the color of the adjacent block and add its index to the list `fs`.\n6. After iterating through the entire string, check if the last three blocks have the same color. If they do, print the length of `fs` and the indices in `fs` if it's not empty.\n7. If the last three blocks do not have the same color, check if the total number of blocks is even. If it is, print -1. Otherwise, add the indices of all odd-numbered blocks to `fs` and print the length of `fs` and the indices in `fs` if it's not empty.\n\nCOMMENTED CODE:\n```python\nn = int(input())  # Read the number of blocks\ns = list(input())  # Read the string representing the colors of the blocks\n\ndef inv(si):  # Function to invert the color of a block\n    if si == \"W\":  # If the block is white, invert it to black\n        return \"B\"\n    else:  # If the block is black, invert it to white\n        return \"W\"\n\nfs = []  # Initialize an empty list to store the indices of blocks to flip\ni = 0  # Initialize a counter to iterate through the string\nwhile i < n-2:  # Iterate through the string, considering each block and its adjacent blocks\n    b = s[i]  # Get the color of the current block\n    s1 = s[i+1]  # Get the color of the next block\n    s2 = s[i+2]  # Get the color of the block after the next block\n\n    if b == s1 and s1 == s2:  # If the current block and its adjacent blocks have the same color\n        i+=2  # Move to the next block\n    elif b == s1:  # If the current block and the next block have the same color\n        i+=1  # Move to the next block\n    elif b!= s1:  # If the current block and the next block have different colors\n        s[i+1] = inv(s[i+1])  # Flip the color of the next block\n        s[i+2] = inv(s[i+2])  # Flip the color of the block after the next block\n        fs.append(i+1+1)  # Add the index of the next block to the list\n        i+=1  # Move to the next block\n\nif (s[n-3] == s[n-2] and s[n-2] == s[n-1]):  # Check if the last three blocks have the same color\n    print(len(fs))  # Print the length of the list\n    if (len(fs) > 0):  # If the list is not empty\n        print(*fs)  # Print the indices in the list\nelse:  # If the last three blocks do not have the same color\n    if len(s) % 2 == 0:  # Check if the total number of blocks is even\n        print(-1)  # Print -1 if the total number of blocks is even\n    else:  # If the total number of blocks is odd\n        for i in range(0, n-1, 2):  # Iterate through the string, considering every other block\n            fs.append(i+1)  # Add the index of the block to the list\n        print(len(fs))  # Print the length of the list\n        if (len(fs) > 0):  # If the list is not empty\n            print(*fs)  # Print the indices in the list\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the color sequence of the blocks from the input.\n2. Define a function `foo` that takes the color sequence, a target color `c1`, and an alternate color `c2` as parameters.\n3. Initialize a counter `c` to keep track of the number of operations and an empty list `st` to store the positions of the blocks that need to be flipped.\n4. Iterate through the color sequence from left to right. If the current block is of the target color `c1`, skip it. Otherwise, flip the current block and the next block, update the counter `c`, and append the position of the current block to the list `st`.\n5. After the iteration, check if the last block is of the alternate color `c2`. If it is, return `-1` to indicate that it's impossible to make all blocks have the same color. Otherwise, return the counter `c` and the list `st` as a string of space-separated positions.\n6. Call the `foo` function twice with different target colors `c1` and alternate colors `c2` to find the minimum number of operations required to make all blocks have the same color.\n7. If both calls return valid results, print the minimum number of operations and the corresponding positions. Otherwise, print `-1` to indicate that it's impossible to make all blocks have the same color.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the color sequence from the input\nn = int(input())\narr = list(input().strip())\n\n# Define a function to find the minimum number of operations required to make all blocks have the same color\ndef foo(arr, c1, c2):\n    global n\n    # Initialize a counter to keep track of the number of operations and an empty list to store the positions of the blocks that need to be flipped\n    c = 0\n    st = []\n    # Iterate through the color sequence from left to right\n    for i in range(n-1):\n        # If the current block is of the target color, skip it\n        if arr[i] == c1:\n            continue\n        else:\n            # Flip the current block and the next block, update the counter, and append the position of the current block to the list\n            arr[i] = c1\n            arr[i+1] = c1 if arr[i+1] == c2 else c2\n            c += 1\n            st.append(i+1)\n    # Check if the last block is of the alternate color\n    if arr[-1] == c2:\n        # If it is, return -1 to indicate that it's impossible to make all blocks have the same color\n        return(-1, -1)\n    else:\n        # Otherwise, return the counter and the list as a string of space-separated positions\n        return(c,''.join(map(str, st)))\n\n# Call the foo function twice with different target colors and alternate colors\na, b = foo(list(arr), 'B','W')\nc, d = foo(list(arr), 'W','B')\n\n# Print the minimum number of operations and the corresponding positions\nif a!=-1:\n    print(a)\n    print(b)\nelif c!=-1:\n    print(c)\n    print(d)\nelse:\n    print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The first step is to read the number of blocks (n) and the string representing the colors of the blocks.\n2. Check if it's impossible to make all blocks the same color: If the number of white blocks and the number of black blocks are both odd, it's impossible to make all blocks the same color, so print -1.\n3. Determine the target color: If the number of black blocks is even, the target color is black; otherwise, the target color is white.\n4. Initialize an empty list to store the operations: Create an empty list to store the positions of the blocks that need to be flipped.\n5. Iterate through the blocks: Iterate through the blocks from left to right.\n6. Check if the current block and the next block need to be flipped: If the current block and the next block have different colors and the next block is the target color, add the position of the next block to the list of operations and flip the colors of the current block and the next block.\n7. Print the number of operations and the positions of the blocks that need to be flipped: Print the number of operations and the positions of the blocks that need to be flipped.\n\nCOMMENTED CODE:\n```python\n# Read the input\namount = int(input())\nline = list(input())\n\n# Check if it's impossible to make all blocks the same color\nif line.count('W') % 2 == 1 and line.count('B') % 2 == 1:\n    # If the number of white blocks and the number of black blocks are both odd, it's impossible to make all blocks the same color\n    print(-1)\nelif line.count('B') % 2 == 0:\n    # If the number of black blocks is even, the target color is black\n    ans = []\n    for i in range(amount - 1):\n        # Iterate through the blocks\n        if line[i] == 'B' and line[i + 1] == 'B':\n            # If the current block and the next block are both black, no operation is needed\n            pass\n        elif line[i] == 'B' and line[i + 1] == 'W':\n            # If the current block is black and the next block is white, flip the colors of the current block and the next block\n            ans.append(i + 1)\n            line[i] = 'W'\n            line[i + 1] = 'B'\n    # Print the number of operations and the positions of the blocks that need to be flipped\n    print(len(ans))\n    print(*ans)\nelse:\n    # If the number of black blocks is odd, the target color is white\n    ans = []\n    for i in range(amount - 1):\n        # Iterate through the blocks\n        if line[i] == 'W' and line[i + 1] == 'W':\n            # If the current block and the next block are both white, no operation is needed\n            pass\n        elif line[i] == 'W' and line[i + 1] == 'B':\n            # If the current block is white and the next block is black, flip the colors of the current block and the next block\n            ans.append(i + 1)\n            line[i], line[i + 1] = line[i + 1], line[i]\n    # Print the number of operations and the positions of the blocks that need to be flipped\n    print(len(ans))\n    print(*ans)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Initialize two dictionaries `d` to store the indices of black and white blocks.\n3. Iterate through the string `s` and append the indices of black and white blocks to their respective dictionaries.\n4. Calculate the number of black and white blocks (`lb` and `lw`) and check if it's impossible to make all blocks the same color by checking if one color has an odd number of blocks and the other has an even number of blocks.\n5. If it's impossible, print -1. Otherwise, proceed to the next step.\n6. If all blocks are already the same color, print 0.\n7. Otherwise, determine which color has an odd number of blocks (`b` is True if black has an odd number of blocks, `c` is True if white has an odd number of blocks).\n8. If `b` is False, iterate through the black blocks and append the indices of every other black block to the `pos` list.\n9. If `b` is True, iterate through the white blocks and append the indices of every other white block to the `pos` list.\n10. Print the length of the `pos` list and the elements of the `pos` list.\n\nCOMMENTED CODE:\n```python\nn = int(input())  # Read the number of blocks\ns = input()  # Read the string representing the colors of the blocks\n\n# Initialize two dictionaries to store the indices of black and white blocks\nd = {'B': [], 'W': []}\nfor i, e in enumerate(s):  # Iterate through the string\n    d[e].append(i)  # Append the index of the block to its respective dictionary\n\n# Calculate the number of black and white blocks\nlb, lw = len(d['B']), len(d['W'])\n\n# Check if it's impossible to make all blocks the same color\nb, c = lb % 2!= 0, lw % 2!= 0\nif b and c:  # If one color has an odd number of blocks and the other has an even number of blocks\n    print(-1)  # Print -1\nelif (lb and not lw) or (lw and not lb):  # If all blocks are already the same color\n    print(0)  # Print 0\nelse:\n    # Determine which color has an odd number of blocks\n    if not b:\n        B = d['B']  # If white has an odd number of blocks\n        pos = []  # Initialize the pos list\n        i = 0  # Initialize the index\n        while i < lb:  # Iterate through the black blocks\n            for y in range(B[i], B[i + 1]):  # Iterate through the current group of black blocks\n                pos.append(y + 1)  # Append the index of the block to the pos list\n            i += 2  # Move to the next group of black blocks\n    else:\n        W = d['W']  # If black has an odd number of blocks\n        pos = []  # Initialize the pos list\n        i = 0  # Initialize the index\n        while i < lw:  # Iterate through the white blocks\n            for y in range(W[i], W[i + 1]):  # Iterate through the current group of white blocks\n                pos.append(y + 1)  # Append the index of the block to the pos list\n            i += 2  # Move to the next group of white blocks\n    print(len(pos))  # Print the length of the pos list\n    print(*pos)  # Print the elements of the pos list\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The first step is to read the number of blocks (n) and the string representing the colors of the blocks (BlackWhite).\n2. Count the number of black and white blocks: We need to count the number of black and white blocks to determine the parity of their counts.\n3. Initialize the number of operations: We initialize a variable k to keep track of the number of operations.\n4. Check if all blocks are already the same color: If all blocks are already black or all blocks are already white, we print 0 and exit.\n5. Check if it's impossible to make all blocks the same color: If the number of black blocks and white blocks have different parities, it's impossible to make all blocks the same color, so we print -1 and exit.\n6. Determine the target color: Based on the parity of the counts of black and white blocks, we determine the target color (black or white).\n7. Perform operations to make all blocks the target color: We use the turnBlack or turnWhite function to perform operations to make all blocks the target color.\n8. Print the number of operations and the positions of the blocks to be flipped: After performing the operations, we print the number of operations and the positions of the blocks to be flipped.\n\nCOMMENTED CODE:\n```python\ndef countWhite(s):\n    # Count the number of white blocks in the string\n    i = 0\n    for elem in s:\n        if elem == \"W\":\n            i += 1\n    return i\n\ndef countBlack(s):\n    # Count the number of black blocks in the string\n    i = 0\n    for elem in s:\n        if elem == \"B\":\n            i += 1\n    return i\n\ndef stringToList(s):\n    # Convert a string to a list\n    list = []\n    for elem in s:\n        list.append(elem)\n    return list\n\ndef listToString(l):\n    # Convert a list to a string\n    string = \"\"\n    for elem in l:\n        string += \"%s \" % (elem)\n    return string\n\ndef swap(char):\n    # Swap the color of a block\n    if char == \"W\":\n        char = \"B\"\n    elif char == \"B\":\n        char = \"W\"\n    return char\n\ndef turnBlack(l):\n    # Perform operations to make all blocks black\n    global k\n    list = []\n    for i in range(0, len(l)):\n        if l[i] == \"W\":\n            k += 1\n            list.append(i + 1)\n            l[i] = \"B\"\n            l[i + 1] = swap(l[i + 1])\n    return list\n\ndef turnWhite(l):\n    # Perform operations to make all blocks white\n    global k\n    list = []\n    for i in range(0, len(l)):\n        if l[i] == \"B\":\n            k += 1\n            list.append(i + 1)\n            l[i] = \"W\"\n            l[i + 1] = swap(l[i + 1])\n    return list\n\nn = int(input())\nBlackWhite = input()\n\nuseThis = stringToList(BlackWhite)\n\n# Count the number of black and white blocks\nnB = countBlack(BlackWhite)\nnW = countWhite(BlackWhite)\n\nk = 0\n\n# Check if all blocks are already the same color\nif nB == 0 or nW == 0:\n    print(k)\nelif nB % 2!= 0 and nW % 2!= 0:\n    # If it's impossible to make all blocks the same color, print -1\n    print(-1)\nelif nB % 2 == 0 and nW % 2 == 0:\n    # If both counts have the same parity, make all blocks black\n    x = turnBlack(useThis)\n    print(k)\n    print(listToString(x))\nelif nB % 2 == 0 and nW % 2!= 0:\n    # If the count of black blocks has even parity and the count of white blocks has odd parity, make all blocks white\n    y = turnWhite(useThis)\n    print(k)\n    print(listToString(y))\nelif nB % 2!= 0 and nW % 2 == 0:\n    # If the count of black blocks has odd parity and the count of white blocks has even parity, make all blocks black\n    z = turnBlack(useThis)\n    print(k)\n    print(listToString(z))\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Check if it's impossible to make all blocks have the same color by verifying if the counts of \"B\" and \"W\" are both even or both odd. If so, print -1 and exit.\n3. Determine the target color `m` to make all blocks the same, which is the color that appears more frequently.\n4. Initialize an empty list `b` to store the positions of blocks that need to be flipped.\n5. Iterate through the blocks from left to right, checking if the current block's color is different from the target color `m`.\n6. If the current block's color is different from `m`, append its position to the list `b`, flip its color, and flip the color of the next block if it's different from `m`.\n7. Print the length of `b` and the positions in `b` if it's not empty.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors\nn = int(input())\ns = input()\n\n# Convert the string to a list for easier manipulation\na = list(s)\n\n# Check if it's impossible to make all blocks have the same color\nif (a.count(\"B\") % 2) * (a.count(\"W\") % 2):\n    # If both counts are odd or both are even, it's impossible\n    print(-1)\n    exit()\n\n# Determine the target color to make all blocks the same\n# The target color is the one that appears more frequently\nif a.count(\"B\") % 2:\n    m = \"W\"  # Target color is \"W\" if \"B\" appears more frequently\nelse:\n    m = \"B\"  # Target color is \"B\" if \"W\" appears more frequently\n\n# Initialize an empty list to store the positions of blocks that need to be flipped\nb = []\n\n# Iterate through the blocks from left to right\nfor i in range(n - 1):\n    # Check if the current block's color is different from the target color\n    if a[i] == m:\n        # If the current block's color is different from the target color\n        b.append(i + 1)  # Append its position to the list\n        # Flip the current block's color\n        if a[i] == \"W\":\n            a[i] = \"B\"\n        else:\n            a[i] = \"W\"\n        # Flip the next block's color if it's different from the target color\n        if a[i + 1] == \"W\":\n            a[i + 1] = \"B\"\n        else:\n            a[i + 1] = \"W\"\n\n# Print the length of the list and the positions in the list if it's not empty\nprint(len(b))\nif len(b):\n    print(*b)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The first step is to read the number of blocks (n) and the string representing the colors of the blocks.\n2. Convert the string to a list of boolean values: Convert the string of 'B' and 'W' characters to a list of boolean values, where True represents a black block and False represents a white block.\n3. Count the number of black and white blocks: Count the number of True and False values in the list to determine the number of black and white blocks.\n4. Check if it's possible to make all blocks the same color: If the number of black blocks is odd and the number of white blocks is odd, it's impossible to make all blocks the same color, so return None.\n5. Determine the target color: If the number of black blocks is even, the target color is black; otherwise, the target color is white.\n6. Initialize an empty list to store the flip operations: Initialize an empty list to store the indices of the blocks that need to be flipped.\n7. Iterate through the blocks: Iterate through the blocks from left to right.\n8. Check if the current block and the next block have different colors: If the current block and the next block have different colors, flip them and add the current index to the list of flip operations.\n9. If the current block and the next block have the same color, flip them and add the current index to the list of flip operations.\n10. Return the list of flip operations: Return the list of flip operations.\n\nCOMMENTED CODE:\n```python\nfrom sys import stdin\n\n# noinspection PyShadowingBuiltins\ninput = lambda: stdin.readline().rstrip(\"\\r\\n\")\ninput_a = lambda fun: map(fun, stdin.readline().split())\n\n\ndef read():\n    n = int(input())\n    s = input()\n    return n, s\n\n\ndef solve(n, s: str):\n    # Convert the string to a list of boolean values\n    s = [True if x == 'B' else False for x in s]\n    \n    # Count the number of black and white blocks\n    b, w = s.count(True), s.count(False)\n    \n    # Check if it's possible to make all blocks the same color\n    if b % 2!= 0 and w % 2!= 0:\n        return None\n\n    # Determine the target color\n    letter = True if b % 2 == 0 else False\n    \n    # Initialize an empty list to store the flip operations\n    flips = []\n    \n    # Iterate through the blocks\n    for i in range(n - 1):\n        # Check if the current block and the next block have different colors\n        if s[i] == letter:\n            # If the current block and the next block have different colors, flip them and add the current index to the list of flip operations\n            if s[i]!= s[i + 1]:\n                s[i], s[i + 1] = s[i + 1], s[i]\n            # If the current block and the next block have the same color, flip them and add the current index to the list of flip operations\n            else:\n                s[i] = s[i + 1] = not letter\n            flips.append(i + 1)\n    \n    # Return the list of flip operations\n    return flips\n\n\nresult = solve(*read())\nif result is None:\n    print(-1)\nelse:\n    print(len(result))\n    print(*result)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Create a copy of the string `s` and store it in `t`. This is done to simulate the operations on the original string `s` and the inverted string `t`.\n3. Initialize two empty lists `ans1` and `ans2` to store the positions of the blocks that need to be inverted to make all blocks black and white, respectively.\n4. Iterate through the string `s` and `t` from left to right, considering each pair of adjacent blocks.\n5. For each pair of blocks, check if the colors need to be inverted to make all blocks the same color. If so, update the corresponding list `ans1` or `ans2` with the position of the block that needs to be inverted.\n6. After iterating through all pairs of blocks, check the color of the last block in `s` and `t`. If they are different, it is impossible to make all blocks the same color, so print -1. Otherwise, print the length of the longer list `ans1` or `ans2` and the positions of the blocks that need to be inverted.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors of the blocks\nn = int(input())\ns = list(input())  # Convert the input string to a list for easier manipulation\n\n# Create a copy of the string s to simulate operations\nt = s.copy()\n\n# Initialize two empty lists to store the positions of blocks that need to be inverted\nans1 = []  # List to store positions for making all blocks black\nans2 = []  # List to store positions for making all blocks white\n\n# Iterate through the string s and t from left to right, considering each pair of adjacent blocks\nfor i in range(n - 1):\n    # Check if the colors need to be inverted to make all blocks black\n    if s[i] == 'W':  # If the current block is white\n        if s[i + 1] == 'B':  # And the next block is black\n            # Invert the color of the next block\n            s[i + 1] = 'W'\n            # Add the position of the next block to the list ans1\n            ans1.append(i + 1)\n    # Check if the colors need to be inverted to make all blocks white\n    if t[i] == 'B':  # If the current block is black\n        if t[i + 1] == 'B':  # And the next block is also black\n            # Invert the color of the next block\n            t[i + 1] = 'W'\n            # Add the position of the next block to the list ans2\n            ans2.append(i + 1)\n\n# Check the color of the last block in s and t\nif s[-1] == 'B':  # If the last block in s is black\n    # Print the length of the list ans1 and the positions of the blocks that need to be inverted\n    print(len(ans1))\n    print(' '.join(map(str, ans1)))\nelif t[-1] == 'W':  # If the last block in t is white\n    # Print the length of the list ans2 and the positions of the blocks that need to be inverted\n    print(len(ans2))\n    print(' '.join(map(str, ans2)))\nelse:\n    # If the last blocks in s and t are different, it is impossible to make all blocks the same color\n    print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the color sequence `s` from the input.\n2. Convert the color sequence into a list of integers `l`, where 0 represents a white block and 1 represents a black block.\n3. Initialize a flag `f` to 0, which will be used to track whether it's possible to make all blocks the same color.\n4. Try to make all blocks black by iterating through the list and inverting the colors of adjacent blocks. Store the positions of the blocks to be inverted in the list `ans`.\n5. Check if all blocks are now black by verifying that the length of the set of `l` is 1. If so, set `f` to 1.\n6. If `f` is still 0, try to make all blocks white by iterating through the list and inverting the colors of adjacent blocks. Store the positions of the blocks to be inverted in the list `ans`.\n7. Check if all blocks are now white by verifying that the length of the set of `l` is 1. If so, set `f` to 1.\n8. If `f` is 1, print the length of `ans` and the elements of `ans`.\n9. If `f` is still 0, print -1.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks n and the color sequence s from the input\nn = int(input())\nl = list(input())  # Convert the color sequence into a list of characters\n\n# Initialize a flag f to 0, which will be used to track whether it's possible to make all blocks the same color\nf = 0\n\n# Create a copy of the list l to avoid modifying the original list\nl1 = l[:]\n\n# Try to make all blocks black by iterating through the list and inverting the colors of adjacent blocks\nif f == 0:\n    ans = []  # Initialize an empty list to store the positions of the blocks to be inverted\n    for i in range(n-1):\n        # If the current block is white, invert its color and the color of the next block\n        if l[i]=='B':\n            l[i] = 0  # Convert 'B' to 0\n        else:\n            l[i] = 1  # Convert 'W' to 1\n        l[i+1] = abs(1-l[i+1])  # Invert the color of the next block\n        ans.append(i+1)  # Store the position of the current block in the list ans\n    # Check if all blocks are now black by verifying that the length of the set of l is 1\n    if len(set(l))==1:\n        f = 1  # If all blocks are black, set f to 1\n\n# Reset the list l to its original state\nl = l1[:]\n\n# Try to make all blocks white by iterating through the list and inverting the colors of adjacent blocks\nif f==0:\n    ans = []  # Initialize an empty list to store the positions of the blocks to be inverted\n    for i in range(n-1):\n        # If the current block is black, invert its color and the color of the next block\n        if l[i]==0:\n            l[i] = 1  # Convert 0 to 1\n        else:\n            l[i] = 0  # Convert 1 to 0\n        l[i+1] = abs(1-l[i+1])  # Invert the color of the next block\n        ans.append(i+1)  # Store the position of the current block in the list ans\n    # Check if all blocks are now white by verifying that the length of the set of l is 1\n    if len(set(l))==1:\n        f = 1  # If all blocks are white, set f to 1\n\n# If f is 1, print the length of ans and the elements of ans\nif f==1:\n    print(len(ans))  # Print the length of ans\n    print(*ans)  # Print the elements of ans\nelse:\n    print(-1)  # If f is still 0, print -1\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Initialize variables: `b` and `w` to count the number of black and white blocks respectively, and `p` to store the colors of the blocks as a list.\n3. Iterate through the string `s` to populate the list `p` and update the counts `b` and `w`.\n4. Check if it's possible to make all blocks the same color by checking if `b` and `w` have the same parity.\n5. If `b` and `w` have the same parity, it's possible to make all blocks the same color. Initialize `steps` to 0 and `op` to an empty list.\n6. Iterate through the list `p` to find pairs of adjacent blocks with different colors. For each pair, invert the colors and increment `steps` by 1. Append the position of the left block in the pair to `op`.\n7. Print the number of steps and the positions of the blocks that need to be inverted.\n8. If `b` and `w` have different parities, it's impossible to make all blocks the same color. Print -1.\n\nCOMMENTED CODE:\n```python\nimport math\n\ndef main():\n    # Read the input: The number of blocks `n` and the string `s` representing the colors of the blocks.\n    n = int(input())\n    s = str(input())\n\n    # Initialize variables: `b` and `w` to count the number of black and white blocks respectively, and `p` to store the colors of the blocks as a list.\n    b = 0\n    w = 0\n    p = []\n\n    # Iterate through the string `s` to populate the list `p` and update the counts `b` and `w`.\n    for i in range(n):\n        if s[i] == 'B':\n            # If the block is black, append 1 to `p` and increment `b`.\n            p.append(1)\n            b += 1\n        else:\n            # If the block is white, append 0 to `p` and increment `w`.\n            p.append(0)\n            w += 1\n\n    # Check if it's possible to make all blocks the same color by checking if `b` and `w` have the same parity.\n    steps = -1\n    op = []\n    if b % 2 == 0:\n        # If `b` has even parity, it's possible to make all blocks black.\n        steps = 0\n        for i in range(n - 1):\n            # Iterate through the list `p` to find pairs of adjacent blocks with different colors.\n            if p[i] == 1:\n                # If the current block is black, increment `steps` by 1 and append the position of the left block in the pair to `op`.\n                steps += 1\n                op.append(i + 1)\n                # Invert the colors of the current block and the next block.\n                p[i] = 1 - p[i]\n                p[i + 1] = 1 - p[i + 1]\n    elif w % 2 == 0:\n        # If `w` has even parity, it's possible to make all blocks white.\n        steps = 0\n        for i in range(n - 1):\n            # Iterate through the list `p` to find pairs of adjacent blocks with different colors.\n            if p[i] == 0:\n                # If the current block is white, increment `steps` by 1 and append the position of the left block in the pair to `op`.\n                steps += 1\n                op.append(i + 1)\n                # Invert the colors of the current block and the next block.\n                p[i] = 1 - p[i]\n                p[i + 1] = 1 - p[i + 1]\n\n    # Print the number of steps and the positions of the blocks that need to be inverted.\n    print(steps)\n    if steps >= 0:\n        print(' '.join([str(x) for x in op]))\n\n\nif __name__ == '__main__':\n    main()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Initialize two empty lists `ans` and `ans1` to store the sequences of operations for making all blocks black and white, respectively.\n3. Define a helper function `func` that takes the current state of the blocks `ss`, the list of operations `l`, and the target color `c`.\n4. In the `func` function, iterate over the blocks and perform the following steps:\n   - If the current block is the target color, invert its color and the color of the next block.\n   - Add the index of the current block to the list of operations `l`.\n5. After the iteration, check if all blocks have the same color. If they do, return the list of operations `l`.\n6. If not, return an empty list.\n7. Call the `func` function twice with different target colors (\"B\" and \"W\") and store the results in `ans` and `ans1`, respectively.\n8. Check the following conditions:\n   - If all blocks are already the same color, print 0.\n   - If both `ans` and `ans1` are empty, print -1.\n   - Otherwise, print the length of the non-empty list and the list of operations.\n\nCOMMENTED CODE:\n```python\ndef func(ss, l, c):  # Helper function to find a sequence of operations\n    if c == \"W\":  # If the target color is white\n        c1 = \"B\"  # Invert the color\n    else:  # If the target color is black\n        c1 = \"W\"  # Invert the color\n    for i in range(n - 1):  # Iterate over the blocks\n        if ss[i] == c:  # If the current block is the target color\n            ss[i] = c1  # Invert its color\n            ss[i + 1] = c if ss[i + 1] == c1 else c1  # Invert the color of the next block\n        l.append(i + 1)  # Add the index of the current block to the list of operations\n    if len(set(ss)) == 1:  # Check if all blocks have the same color\n        return l  # Return the list of operations\n    else:\n        return []  # Return an empty list\n\nn, s = int(input()), list(input())  # Read the input\nans, ans1 = func(list(s), [], \"B\"), func(list(s), [], \"W\")  # Call the helper function twice\nif len(set(s)) == 1:  # Check if all blocks are already the same color\n    print(0)  # Print 0\nelif not ans and not ans1:  # Check if both lists are empty\n    print(-1)  # Print -1\nelse:  # Print the length of the non-empty list and the list of operations\n    print(len(ans1) if ans1!= [] else len(ans), \"\\n\", *ans1 if ans1!= [] else ans)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Initialize two lists `sw` and `sb` to store the positions of white and black blocks that need to be inverted to make all blocks of the same color.\n3. Iterate through the string `s` from left to right, checking each pair of adjacent blocks. If a block is black, add its position to `sw` and invert its color. If a block is white, add its position to `sb` and invert its color.\n4. Check if it's possible to make all blocks white by inverting at most 3n blocks. If the last block is white and the number of white blocks to be inverted is less than 3n, return the positions of these blocks.\n5. Check if it's possible to make all blocks black by inverting at most 3n blocks. If the last block is black and the number of black blocks to be inverted is less than 3n, return the positions of these blocks.\n6. If it's impossible to make all blocks of the same color, return `None`.\n7. Print the number of operations and the positions of the blocks to be inverted if it's possible to make all blocks of the same color.\n\nCOMMENTED CODE:\n```python\n# Read the input: The number of blocks n and the string s representing the colors of the blocks.\nn = int(input())\ns = list(input())  # Convert the string to a list for easier manipulation\n\n# Initialize two lists sw and sb to store the positions of white and black blocks that need to be inverted to make all blocks of the same color.\ndef solve(n, w):\n    b = w.copy()  # Create a copy of the list w to store the colors of the blocks after inverting\n    sw, sb = [], []  # Initialize the lists sw and sb to store the positions of white and black blocks to be inverted\n    \n    # Iterate through the string s from left to right, checking each pair of adjacent blocks\n    for i in range(n-1):\n        if w[i] == 'B':  # If a block is black\n            sw.append(i+1)  # Add its position to sw\n            w[i+1] = 'W' if (w[i+1] == 'B') else 'B'  # Invert the color of the next block\n        if b[i] == 'W':  # If a block is white\n            sb.append(i+1)  # Add its position to sb\n            b[i+1] = 'W' if (b[i+1] == 'B') else 'B'  # Invert the color of the next block\n    \n    # Check if it's possible to make all blocks white by inverting at most 3n blocks\n    if (len(sw) < 3*n and w[-1] == 'W'):  # If the last block is white and the number of white blocks to be inverted is less than 3n\n        return sw  # Return the positions of these blocks\n    \n    # Check if it's possible to make all blocks black by inverting at most 3n blocks\n    if (len(sb) < 3*n and b[-1] == 'B'):  # If the last block is black and the number of black blocks to be inverted is less than 3n\n        return sb  # Return the positions of these blocks\n    \n    # If it's impossible to make all blocks of the same color, return None\n    return None\n\n# Call the function solve and store the result in ans\nans = solve(n, s)\n\n# Print the result\nif ans is None:  # If it's impossible to make all blocks of the same color\n    print(-1)  # Print -1\nelse:\n    print(len(ans))  # Print the number of operations\n    print(' '.join([str(i) for i in ans]))  # Print the positions of the blocks to be inverted\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Convert the string `s` into a list of integers `a`, where `a[i]` is 1 if the `i-th` block is black and 0 if it's white.\n3. Calculate the total number of black and white blocks.\n4. Check if it's impossible to make all blocks have the same color by checking if the total number of black blocks and white blocks are both odd.\n5. Determine the target color to make all blocks have the same color. If the total number of black blocks is even, the target color is black; otherwise, the target color is white.\n6. Initialize an empty list `chg` to store the positions of blocks that need to be changed.\n7. Iterate through the list `a` and check if the current block and the next block have different colors from the target color. If they do, invert their colors and add the current position to the list `chg`.\n8. Print the length of `chg` as the number of operations and the elements of `chg` as the positions of the blocks that need to be changed.\n\nCOMMENTED CODE:\n```python\nimport time\n\ndef st(it):\n    return [str(ita) for ita in it]\n\nLOCAL = False\nstart_time = None\nif __name__ == '__main__':\n    if LOCAL:\n        start_time = time.time()\n        # n = int(input())\n        # a = list(map(lambda x: int(x), input().split(' ')))\n    \n    # Read the input: The number of blocks `n` and the string `s` representing the colors of the blocks.\n    n = int(input())\n    a = list(map(lambda x: 1 if x == 'B' else 0, input()))\n    \n    # Convert the string `s` into a list of integers `a`, where `a[i]` is 1 if the `i-th` block is black and 0 if it's white.\n    # Calculate the total number of black and white blocks.\n    sum_a = sum(a)\n    blacks = sum_a\n    whites = n - blacks\n    \n    # Check if it's impossible to make all blocks have the same color by checking if the total number of black blocks and white blocks are both odd.\n    if blacks % 2 == 1 and whites % 2 == 1:\n        print(-1)\n    else:\n        # Determine the target color to make all blocks have the same color. If the total number of black blocks is even, the target color is black; otherwise, the target color is white.\n        to_change = 1 if blacks % 2 == 0 else 0\n        \n        # Initialize an empty list `chg` to store the positions of blocks that need to be changed.\n        chg = []\n        \n        # Iterate through the list `a` and check if the current block and the next block have different colors from the target color. If they do, invert their colors and add the current position to the list `chg`.\n        for i in range(n - 1):\n            if a[i] == to_change:\n                a[i + 1] = (a[i + 1] + 1) % 2\n                a[i] = (a[i] + 1) % 2\n                chg.append(i+1)\n        \n        # Print the length of `chg` as the number of operations and the elements of `chg` as the positions of the blocks that need to be changed.\n        print(len(chg))\n        print(' '.join(st(chg)))\n\n    if LOCAL:\n        print(\"--- %s seconds ---\" % (time.time() - start_time))\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks (n) and the color sequence from the input.\n2. Initialize an empty list (ar) to store the positions of blocks that need to be flipped.\n3. Iterate through the color sequence. If a white block is found, flip it and the next block if it exists. If the last block is white, set a flag (ch) to 1.\n4. If no white blocks were flipped or the last block was white, print the length of ar and the positions of the flipped blocks if ar is not empty.\n5. If the last block was white, reset the color sequence to its original state and repeat steps 3-4 for flipping black blocks.\n6. If no black blocks were flipped or the last block was black, print the length of ar and the positions of the flipped blocks if ar is not empty.\n7. If neither white nor black blocks were flipped or the last block was of the same color as the first block, print -1.\n\nCOMMENTED CODE:\n```python\nimport math\n\n# Read the number of blocks (n) and the color sequence from the input\nelem = int(input())\nst = list(input())  # st is the original color sequence\nst2 = st.copy()  # st2 is a copy of the original color sequence for flipping black blocks\n\n# Initialize an empty list (ar) to store the positions of blocks that need to be flipped\nar = []\n\n# Iterate through the color sequence. If a white block is found, flip it and the next block if it exists\nfor x in range(len(st)):\n    if st[x] == 'B':  # If the block is black, continue to the next block\n        continue\n    if x == len(st)-1:  # If the last block is white, set a flag (ch) to 1\n        ch = 1\n        break\n    st[x] = 'W'  # Flip the current block to white\n    if st[x+1]=='W':  # If the next block is also white, flip it to black\n        st[x+1]='B'\n    else:  # If the next block is black, flip it to white\n        st[x+1]='W'\n    ar.append(x+1)  # Add the position of the flipped block to ar\n\n# If no white blocks were flipped or the last block was white, print the length of ar and the positions of the flipped blocks if ar is not empty\nif ch == 0:\n    print(len(ar))\n    if len(ar)!=0:\n        print(*ar)\n\n# If the last block was white, reset the color sequence to its original state and repeat steps 3-4 for flipping black blocks\nelse:\n    ch = 0  # Reset the flag\n    ar = []  # Reset the list of flipped blocks\n    for x in range(len(st2)):\n        if st2[x] == 'W':  # If the block is white, continue to the next block\n            continue\n        if x == len(st2)-1:  # If the last block is black, set a flag (ch) to 1\n            ch = 1\n            break\n        st2[x] = 'B'  # Flip the current block to black\n        if st2[x+1]=='W':  # If the next block is white, flip it to black\n            st2[x+1]='B'\n        else:  # If the next block is black, flip it to white\n            st2[x+1]='W'\n        ar.append(x+1)  # Add the position of the flipped block to ar\n\n# If no black blocks were flipped or the last block was black, print the length of ar and the positions of the flipped blocks if ar is not empty\nif ch == 0:\n    print(len(ar))\n    if len(ar)!=0:\n        print(*ar)\n\n# If neither white nor black blocks were flipped or the last block was of the same color as the first block, print -1\nelse:\n    print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `N` and the string `S` representing the colors of the blocks.\n2. Count the number of black and white blocks using the `Counter` class from the `collections` module.\n3. Determine the target color `X` and `Y` based on the counts of black and white blocks. If the counts are equal, it's impossible to make all blocks the same color, so print -1 and exit.\n4. Initialize an empty list `ans` to store the indices of the blocks that need to be flipped.\n5. Iterate through the string `S` and check each pair of adjacent blocks.\n6. If both blocks are the same color `X`, flip them and add the index of the second block to `ans`.\n7. If the first block is `X` and the second block is `Y`, swap them and add the index of the second block to `ans`.\n8. After iterating through all blocks, print the length of `ans` and the indices in `ans` separated by spaces.\n\nCOMMENTED CODE:\n```python\n# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import Counter\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n# Read the number of blocks and the string representing the colors\nN = INT()\nS = list(input())\n\n# Count the number of black and white blocks\nC = Counter(S)\n\n# Determine the target color X and Y based on the counts\nif C['B'] % 2 == 0:\n    X = 'B'\n    Y = 'W'\nelif C['W'] % 2 == 0:\n    X = 'W'\n    Y = 'B'\nelse:\n    # If the counts are not equal, it's impossible to make all blocks the same color\n    print(-1)\n    exit()\n\n# Initialize an empty list to store the indices of the blocks that need to be flipped\nans = []\n\n# Iterate through the string and check each pair of adjacent blocks\nfor i in range(N-1):\n    if S[i] == S[i+1] == X:\n        # If both blocks are the same color X, flip them and add the index of the second block to ans\n        S[i] = S[i+1] = Y\n        ans.append(i+1)\n    elif S[i] == X and S[i+1] == Y:\n        # If the first block is X and the second block is Y, swap them and add the index of the second block to ans\n        S[i], S[i+1] = S[i+1], S[i]\n        ans.append(i+1)\n\n# Print the length of ans and the indices in ans separated by spaces\nprint(len(ans))\nif ans:\n    print(*ans)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Convert the string `s` into a list `A` of integers, where `A[i]` is 1 if the `i-th` block is white and 0 if it's black.\n3. If `n` is 2, check if the two blocks have the same color. If they do, print 0. If they don't, print -1.\n4. If `n` is not 2, create a new list `B` where each element is the opposite of the corresponding element in `A`.\n5. If the first block is white, invert the colors of the first two blocks and add their indices to the result list `R`.\n6. Iterate over the blocks starting from the second block. If a block is white, invert its color and the color of the next block, add their indices to `R`, and then invert the color of the previous block.\n7. Check if the last block is white or if the number of blocks minus 1 is even and the last block is black. If either condition is true, calculate the total number of operations and print it along with the indices of the blocks that need to be inverted.\n8. If the conditions in step 7 are not met, print -1.\n\nCOMMENTED CODE:\n```python\nn = int(input())  # Read the number of blocks\nA = [1 if x=='W' else 0 for x in list(input())]  # Convert the string into a list of integers\nR = []  # Initialize the result list\n\nif n==2:  # If there are only two blocks\n    if A[1]==A[0]:  # Check if the two blocks have the same color\n        print(0)  # If they do, print 0\n    else:\n        print(-1)  # If they don't, print -1\nelse:  # If there are more than two blocks\n    B= [not x for x in A]  # Create a new list where each element is the opposite of the corresponding element in A\n    if A[0] == 0:  # If the first block is white\n        A[0] = 1  # Invert its color\n        A[1] = not A[1]  # Invert the color of the second block\n        R.append(1)  # Add the index of the first block to the result list\n    for i in range(1,n):  # Iterate over the blocks starting from the second block\n        if i < n-1 and A[i] == 0:  # If a block is white and it's not the last block\n            A[i] = 1  # Invert its color\n            A[i+1] = not A[i+1]  # Invert the color of the next block\n            R.append(i)  # Add the index of the current block to the result list\n            R.append(i+1)  # Add the index of the next block to the result list\n            R.append(i)  # Add the index of the current block again to the result list\n    # Check if the last block is white or if the number of blocks minus 1 is even and the last block is black\n    if A[-1]==1 or (A[-1]==0 and (len(A)-1)%2==0):\n        print(round(len(R) + (((len(A)-1)/2) if A[-1]==0 and (len(A)-1)%2==0 else 0)))  # Calculate the total number of operations\n        for i in R: print(i, end=' ')  # Print the indices of the blocks that need to be inverted\n        if A[-1]==0 and (len(A)-1)%2==0:  # If the last block is black and the number of blocks minus 1 is even\n            for i in range(0,len(A)-1,2): print(i+1,end=' ')  # Print the indices of the blocks that need to be inverted again\n        print()  # Print a newline\n    else:\n        print(-1)  # If the conditions are not met, print -1\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Create two lists `a` and `b` to store the colors of the blocks, initially copying the colors from the string `s`.\n3. Initialize an empty list `c` to store the positions of blocks to be inverted to make all blocks black.\n4. Iterate through the blocks from left to right, checking if the current block is black. If it is, invert its color and add its position to list `c`. Also, invert the color of the next block if it is white.\n5. Check if all blocks are now white. If they are, print the length of list `c` and the positions in list `c`.\n6. If not all blocks are white, repeat steps 3-5 for making all blocks black by inverting the colors of `b`.\n7. If it is still impossible to make all blocks the same color, print -1.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors of the blocks\nn = int(input())\ns = input()\n\n# Create two lists to store the colors of the blocks, initially copying the colors from the string s\na = []\nb = []\nfor i in range(n):\n    a.append(s[i])  # Store the colors in list a\n    b.append(s[i])  # Store the colors in list b\n\n# Initialize an empty list to store the positions of blocks to be inverted to make all blocks black\nc = []\n\n# Iterate through the blocks from left to right\nfor i in range(n - 1):\n    # Check if the current block is black\n    if a[i] == \"W\":\n        continue  # If the block is white, skip to the next iteration\n    else:\n        # Invert the color of the current block\n        a[i] = \"W\"\n        # Add the position of the current block to list c\n        c.append(i + 1)\n        # Check the color of the next block\n        if a[i + 1] == \"W\":\n            # If the next block is white, invert its color\n            a[i + 1] = \"B\"\n        else:\n            # If the next block is black, invert its color\n            a[i + 1] = \"W\"\n\n# Check if all blocks are now white\nif a.count(\"W\") == n:\n    # If all blocks are white, print the length of list c and the positions in list c\n    print(len(c))\n    print(*c)\nelse:\n    # If not all blocks are white, repeat the process for making all blocks black by inverting the colors of b\n    d = []  # Initialize an empty list to store the positions of blocks to be inverted to make all blocks black\n    for i in range(n - 1):\n        # Check if the current block is black\n        if b[i] == \"B\":\n            continue  # If the block is black, skip to the next iteration\n        else:\n            # Invert the color of the current block\n            b[i] = \"B\"\n            # Add the position of the current block to list d\n            d.append(i + 1)\n            # Check the color of the next block\n            if b[i + 1] == \"W\":\n                # If the next block is white, invert its color\n                b[i + 1] = \"B\"\n            else:\n                # If the next block is black, invert its color\n                b[i + 1] = \"W\"\n    # Check if all blocks are now black\n    if b.count(\"B\") == n:\n        # If all blocks are black, print the length of list d and the positions in list d\n        print(len(d))\n        print(*d)\n    else:\n        # If it is still impossible to make all blocks the same color, print -1\n        print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input string `s` and convert it into a list of integers `a`, where 0 represents a black block and 1 represents a white block.\n2. Create a temporary copy of list `a` as `tmp`.\n3. Iterate through the list `a` starting from the second element (index 1). For each element, check if it is black (0).\n4. If the current element is black, append its index to the `ans` list, invert the color of the current element and the next element, and continue to the next iteration.\n5. After the loop, check if the last element of `a` is white (1). If it is, print the length of `ans` and the indices in `ans` joined by spaces.\n6. If the last element of `a` is not white, restore `a` to its original state by assigning `tmp` back to `a`.\n7. Repeat steps 3-6, but this time, check if the current element is white (1) and invert the colors of the current element and the next element if it is.\n8. After the second loop, check if the last element of `a` is black (0). If it is, print the length of `ans` and the indices in `ans` joined by spaces.\n9. If the last element of `a` is not black, print -1.\n\nCOMMENTED CODE:\n```python\n# Read the input string s and convert it into a list of integers a\ninput()  # Ignore the first input\ns = input()  # Read the input string\na = []  # Initialize an empty list to store the block colors\nfor x in s:  # Iterate through the input string\n    if x == 'B':  # If the current character is 'B', append 0 to list a\n        a.append(0)\n    else:  # If the current character is 'W', append 1 to list a\n        a.append(1)\n\n# Import the copy module to create a deep copy of list a\nimport copy\ntmp = copy.deepcopy(a)  # Create a temporary copy of list a\n\n# Iterate through list a starting from the second element (index 1)\nfor i in range(1, len(s)):\n    if a[i - 1] == 0:  # If the current element is black (0)\n        ans.append(i)  # Append the index of the current element to list ans\n        a[i - 1] = 1  # Invert the color of the current element\n        a[i] ^= 1  # Invert the color of the next element\nif a[i] == 1:  # After the loop, check if the last element of a is white (1)\n    print(len(ans))  # Print the length of list ans\n    print(' '.join([str(x) for x in ans]))  # Print the indices in list ans joined by spaces\nelse:  # If the last element of a is not white\n    a = tmp  # Restore a to its original state\n    ans = []  # Reset list ans\n    for i in range(1, len(s)):  # Repeat the loop\n        if a[i - 1] == 1:  # If the current element is white (1)\n            ans.append(i)  # Append the index of the current element to list ans\n            a[i - 1] = 0  # Invert the color of the current element\n            a[i] ^= 1  # Invert the color of the next element\n    if a[i] == 0:  # After the second loop, check if the last element of a is black (0)\n        print(len(ans))  # Print the length of list ans\n        print(' '.join([str(x) for x in ans]))  # Print the indices in list ans joined by spaces\n    else:  # If the last element of a is not black\n        print(-1)  # Print -1\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n\n1. Read the number of blocks `n` and the color sequence `s` from the input.\n2. Check if it's impossible to make all blocks have the same color by verifying if both black and white blocks are present in odd counts. If so, print -1 and exit.\n3. If the number of black blocks is odd, invert all block colors by replacing 'B' with 'W' and vice versa.\n4. Initialize an empty list `ans` to store the indices of blocks that need to be flipped.\n5. Iterate through the color sequence `b` and check for adjacent blocks with the same color. If found, add the index of the right block to `ans` and flip the colors of the adjacent blocks.\n6. Repeat step 5 to ensure all adjacent blocks with the same color are flipped.\n7. Print the length of `ans` as the number of operations required.\n8. Print the indices in `ans` as the positions of blocks that should be affected by the operations.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the color sequence from the input\na = int(input())\nb = input()\n\n# Check if it's impossible to make all blocks have the same color\nif (b.count(\"B\") % 2 == 1 and b.count(\"W\") % 2 == 1):\n    # If both black and white blocks are present in odd counts, print -1 and exit\n    print(-1)\nelse:\n    # Convert the color sequence to a list for easier manipulation\n    b = list(b)\n\n    # If the number of black blocks is odd, invert all block colors\n    if (b.count(\"B\") % 2 == 1):\n        for i in range(len(b)):\n            # Replace 'B' with 'W' and vice versa\n            if (b[i] == \"B\"):\n                b[i] = \"W\"\n            else:\n                b[i] = \"B\"\n\n    # Convert the list back to a string\n    b = list(b)\n\n    # Initialize an empty list to store the indices of blocks that need to be flipped\n    ans = []\n\n    # Iterate through the color sequence and check for adjacent blocks with the same color\n    for i in range(len(b) - 1):\n        # Check if the current block and the next block have the same color\n        if (b[i] == \"B\" and b[i + 1] == \"B\"):\n            # If they have the same color, add the index of the right block to ans and flip the colors\n            ans.append(str(i + 1))\n            b[i] = \"W\"\n            b[i + 1] = \"W\"\n\n    # Repeat the process to ensure all adjacent blocks with the same color are flipped\n    for i in range(len(b) - 1):\n        if (b[i] == \"B\" and b[i + 1] == \"B\"):\n            ans.append(str(i + 1))\n            b[i] = \"W\"\n            b[i + 1] = \"W\"\n        elif (b[i] == \"B\" and b[i + 1] == \"W\"):\n            # If the current block is black and the next block is white, add the index of the right block to ans and flip the colors\n            ans.append(str(i + 1))\n            b[i] = \"W\"\n            b[i + 1] = \"B\"\n\n    # Print the length of ans as the number of operations required\n    print(len(ans))\n\n    # Print the indices in ans as the positions of blocks that should be affected by the operations\n    print(\" \".join(ans))\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Convert the string `s` into a list `l` for easier manipulation.\n3. Check if all blocks are already white. If so, print 0 and exit.\n4. Initialize an empty list `m` to store the indices of blocks that need to be flipped.\n5. Iterate through the list `l` and flip the colors of adjacent blocks if they are different. Add the index of the first block in each pair to `m`.\n6. Check if there are any remaining black blocks. If so, check if it's possible to make all blocks white or black.\n7. If it's possible to make all blocks white or black, call the `find` function to print the sequence of operations.\n8. If it's not possible to make all blocks white or black, print -1.\n\nCOMMENTED CODE:\n```python\ndef find():\n    # If the last block is black, flip the colors of blocks at even indices\n    if (l[n-1]=='B'):\n        for i in range(0,n-2,2):\n            m.append(i+1)  # Add the index of the first block in each pair to m\n    # If the first block is black, flip the colors of blocks at odd indices\n    elif (l[0]=='B'):\n        for i in range(n-2,0,-2):\n            m.append(i+1)  # Add the index of the first block in each pair to m\n    print(len(m))  # Print the number of operations\n    for j in range(len(m)):\n        print(m[j],end=\" \")  # Print the indices of the blocks that need to be flipped\n\nn=int(input())  # Read the number of blocks\ns=str(input())  # Read the string representing the colors of the blocks\nl=list(s)  # Convert the string into a list for easier manipulation\n\nif ('B' not in s):  # Check if all blocks are already white\n    print(\"0\")  # Print 0 and exit\nelse:\n    m=[]  # Initialize an empty list to store the indices of blocks that need to be flipped\n    for i in range(0,len(s)-1):  # Iterate through the list\n        if l[i]!='W':  # If the current block is black\n            l[i]='W'  # Flip its color\n            m.append(i+1)  # Add the index of the first block in the pair to m\n            if l[i+1]=='W':  # If the next block is white\n                l[i+1]='B'  # Flip its color\n            else:  # If the next block is black\n                l[i+1]='W'  # Flip its color\n\n    if 'B' in l:  # Check if there are any remaining black blocks\n        if (l.count('B')==1) and (l.count('W')%2==0) and (l[0]=='B' or l[len(l)-1]=='B'):  # Check if it's possible to make all blocks white or black\n            find()  # Call the find function to print the sequence of operations\n        else:\n            print(\"-1\")  # Print -1 if it's not possible to make all blocks white or black\n    else:\n        print(len(m))  # Print the number of operations\n        for j in range(len(m)):\n            print(m[j],end=\" \")  # Print the indices of the blocks that need to be flipped\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Convert the string `s` into a list of boolean values `s` where `True` represents a white block and `False` represents a black block.\n3. Create a copy of the list `s` and store it in `r` to be used later.\n4. Iterate through the list `s` from the first block to the second last block.\n5. If the current block is black, continue to the next block.\n6. If the current block is white, invert the colors of the current block and the next block by changing their values in `s` and append the position of the current block to the `store` list.\n7. After the loop, check if the last block is white. If it is, print the length of the `store` list and the positions in the `store` list.\n8. If the last block is not white, create an empty list `store` and repeat steps 4-7 with the list `r` instead of `s`.\n9. If the last block is still not white after the second iteration, print -1.\n\nCOMMENTED CODE:\n```python\nimport sys\nfrom math import ceil\ninput = sys.stdin.readline\n\n# Read the number of blocks and the string representing the colors of the blocks\nn = int(input())\ns = [True if x == 'W' else False for x in input().strip()]\n\n# Create a copy of the list s to be used later\nr = s[:]\n\n# Initialize an empty list to store the positions of blocks to be inverted\nstore = []\n\n# Iterate through the list s from the first block to the second last block\nfor i in range(n-1):\n    # If the current block is black, continue to the next block\n    if s[i]:\n        continue\n    else:\n        # Invert the colors of the current block and the next block\n        store.append(i+1)  # Append the position of the current block to the store list\n        s[i] = not s[i]  # Invert the color of the current block\n        s[i+1] = not s[i+1]  # Invert the color of the next block\n\n# After the loop, check if the last block is white\nif s[-1]:\n    # If the last block is white, print the length of the store list and the positions in the store list\n    print(len(store))\n    print(*store)\nelse:\n    # If the last block is not white, create an empty list store and repeat the process with the list r instead of s\n    store = []\n    for i in range(n-1):\n        # If the current block is white, continue to the next block\n        if not r[i]:\n            continue\n        else:\n            # Invert the colors of the current block and the next block\n            store.append(i+1)  # Append the position of the current block to the store list\n            r[i] = not r[i]  # Invert the color of the current block\n            r[i+1] = not r[i+1]  # Invert the color of the next block\n\n    # If the last block is still not white after the second iteration, print -1\n    if not r[-1]:\n        print(len(store))\n        print(*store)\n    else:\n        print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the initial state of the blocks as a string `sir`.\n2. Create a new list `inv` where each element is the inverse color of the corresponding element in `sir`.\n3. Initialize an empty list `ans` to store the indices of blocks that need to be flipped to make all blocks the same color.\n4. Iterate through `sir` and flip the color of each white block by appending its index to `ans` and updating the corresponding elements in `sir` and `inv`.\n5. If the last block in `sir` is black, print the length of `ans` and the indices in `ans`.\n6. If the last block in `sir` is not black, repeat steps 4 and 5 for `inv`.\n7. If the last block in `inv` is not black, print -1.\n\nCOMMENTED CODE:\n```python\ndef getInv(x):\n    # Function to get the inverse color of a block\n    if x == 'W':\n        return 'B'\n    return 'W'\n\n# Read the number of blocks and the initial state of the blocks\nn = int(input())\n\n# Convert the input string to a list of characters\nsir = list(input())\n\n# Create a new list where each element is the inverse color of the corresponding element in sir\ninv = []\nfor x in sir:\n    inv.append(getInv(x))\n\n# Initialize an empty list to store the indices of blocks that need to be flipped\nans = []\n\n# Iterate through sir and flip the color of each white block\nfor i in range(0, len(sir) - 1):\n    # If the current block is white, flip its color and the color of the next block\n    if sir[i] == 'W': \n        # Append the index of the current block to ans\n        ans.append(i + 1)\n        # Flip the colors of the current and next blocks\n        sir[i] = getInv(sir[i])\n        sir[i + 1] = getInv(sir[i + 1])\n\n# Check if all blocks are black\nif sir[len(sir) - 1] == 'B':\n    # If all blocks are black, print the length of ans and the indices in ans\n    print(len(ans))\n    for x in ans:\n        print(x, end = \" \")\nelse:\n    # If not all blocks are black, repeat the process for inv\n    # Initialize an empty list to store the indices of blocks that need to be flipped\n    ans = []\n    for i in range(0, len(inv) - 1):\n        # If the current block is white, flip its color and the color of the next block\n        if inv[i] == 'W': \n            # Append the index of the current block to ans\n            ans.append(i + 1)\n            # Flip the colors of the current and next blocks\n            inv[i] = getInv(inv[i])\n            inv[i + 1] = getInv(inv[i + 1])\n    \n    # Check if all blocks are black\n    if inv[len(inv) - 1] == 'B':\n        # If all blocks are black, print the length of ans and the indices in ans\n        print(len(ans))\n        for x in ans:\n            print(x, end = \" \")\n    else:\n        # If not all blocks are black, print -1\n        print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Initialize an array `arr` of size `n` to store the colors of the blocks, where `arr[i] = 1` if the `i-th` block is white and `arr[i] = 0` if it's black.\n3. Check if the length of the blocks is odd or even.\n4. If the length is odd, iterate through the blocks and perform operations to make all blocks have the same color. If it's impossible, print -1.\n5. If the length is even, iterate through the blocks and perform operations to make all blocks have the same color. If it's impossible, print -1.\n6. Print the number of operations and the positions of the blocks that need to be flipped.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors\nn = int(input())\ns = input()\n\n# Initialize an array to store the colors of the blocks\narr = [0]*n\n\n# Convert the string to an array of colors\nfor i in range(n):\n    if (s[i] == \"W\"):\n        arr[i] = 1\n    else:\n        arr[i] = 0\n\n# Initialize an array to store the positions of the blocks that need to be flipped\noperation = [0]*(3*n)\ncount = 0\n\n# Check if the length of the blocks is odd or even\nif (n&1==1):\n    # ODD LENGTH CASE\n    x = arr[0]  # Store the color of the first block\n    for i in range(1,n-1):\n        # If the current block has the same color as the first block, skip it\n        if (arr[i] == x):\n            continue\n        # Perform an operation to flip the current block and the next block\n        operation[count] = i+1\n        count+=1\n        arr[i] = arr[i]^1  # Flip the current block\n        arr[i+1] = arr[i+1]^1  # Flip the next block\n    # Check if the last block has the same color as the first block\n    if (arr[n-1] == arr[0]):\n        # Print the number of operations and the positions of the blocks that need to be flipped\n        print(count)\n        print(*operation[:count])\n    else:\n        # If it's impossible to make all blocks have the same color, print -1\n        temp = n-3\n        while (temp >= 0):\n            operation[count] = temp+1\n            count+=1\n            temp -= 2\n        print(count)\n        print(*operation[:count])\n\n# EVEN LENGTH CASE\nelse:\n    x = arr[0]  # Store the color of the first block\n    for i in range(1,n-1):\n        # If the current block has the same color as the first block, skip it\n        if (arr[i]==x):\n            continue\n        # Perform an operation to flip the current block and the next block\n        operation[count] = i+1\n        count+=1\n        arr[i] = arr[i]^1  # Flip the current block\n        arr[i+1] = arr[i+1]^1  # Flip the next block\n    # Check if the last block has the same color as the first block\n    if (arr[n-1] == arr[0]):\n        # Print the number of operations and the positions of the blocks that need to be flipped\n        print(count)\n        print(*operation[:count])\n    else:\n        # If it's impossible to make all blocks have the same color, print -1\n        print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the color sequence `s` from the input.\n2. Count the number of white blocks `nw` and black blocks `nb`.\n3. Check if it's impossible to make all blocks the same color by verifying if both `nw` and `nb` are odd. If so, print -1 and exit.\n4. Determine the target color `en` to make all blocks the same. If `nw` and `nb` are both even, choose the color with the higher count. Otherwise, choose the color that has an even count.\n5. Iterate through the blocks from left to right, checking if the current block's color matches the target color `en`.\n6. If a mismatch is found, increment the operation count `num` and add the current block's index to the answer list `ans`.\n7. Perform the color inversion operation on the current block and its next block.\n8. Repeat steps 5-7 until the end of the sequence.\n9. Print the operation count `num` and the answer list `ans` (if `num` is not 0).\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the color sequence from the input\nn = int(input())\ns = list(input())\n\n# Count the number of white blocks and black blocks\nnw = 0\nnb = 0\nfor i in s:\n    if i == 'W':\n        nw += 1\n    else:\n        nb += 1\n\n# Check if it's impossible to make all blocks the same color\nnum = 0\nans = []\nif nw % 2!= 0 and nb % 2!= 0:\n    # If both counts are odd, it's impossible to make all blocks the same color\n    print(-1)\nelse:\n    # Determine the target color to make all blocks the same\n    if nw % 2 == 0 and nb % 2 == 0:\n        # If both counts are even, choose the color with the higher count\n        if nw > nb:\n            en = 'W'\n        else:\n            en = 'B'\n    elif nw % 2 == 0:\n        # If only white blocks have an even count, choose black as the target color\n        en = 'B'\n    else:\n        # If only black blocks have an even count, choose white as the target color\n        en = 'W'\n\n    # Iterate through the blocks and perform color inversion operations\n    for i in range(n - 1):\n        if s[i]!= en:\n            # If a mismatch is found, increment the operation count and add the current block's index to the answer list\n            num += 1\n            ans.append(i + 1)\n            # Perform the color inversion operation on the current block and its next block\n            if s[i + 1] == 'W':\n                s[i + 1] = 'B'\n            else:\n                s[i + 1] = 'W'\n            if s[i] == 'W':\n                s[i] = 'B'\n            else:\n                s[i] = 'W'\n\n    # Print the operation count and the answer list (if the operation count is not 0)\n    print(num)\n    if num!= 0:\n        print(\" \".join(str(k) for k in ans))\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Count the number of black and white blocks.\n3. Check if it's impossible to make all blocks the same color by checking if both counts are odd.\n4. If it's impossible, print -1. Otherwise, proceed to the next steps.\n5. Initialize an empty list `T` to store the positions of the blocks that need to be flipped.\n6. Iterate through the string `s` and flip the colors of adjacent blocks if they are different.\n7. If two adjacent blocks are both black, flip their colors and add the position of the left block to `T`.\n8. After iterating through the string, check if the number of black blocks is even.\n9. If the number of black blocks is even, iterate from the end of the string to the beginning and flip the colors of adjacent blocks until a white block is found.\n10. If the number of black blocks is odd, iterate from the beginning of the string to the end and flip the colors of adjacent blocks until a black block is found.\n11. Print the length of `T` and the elements of `T`.\n\nCOMMENTED CODE:\n```python\n# Read the input: The number of blocks n and the string s representing the colors of the blocks.\nn = int(input())\ns = list(input())\n\n# Count the number of black and white blocks.\nb = 0  # Number of black blocks\nw = 0  # Number of white blocks\nfor i in s:\n    if i == 'B':\n        b += 1\n    else:\n        w += 1\n\n# Check if it's impossible to make all blocks the same color by checking if both counts are odd.\nif b % 2 == 1 and w % 2 == 1:\n    print(-1)  # If both counts are odd, it's impossible to make all blocks the same color.\nelif b == 0 or w == 0:\n    print(0)  # If one of the counts is 0, all blocks are already the same color.\n\nelse:\n    # Initialize an empty list T to store the positions of the blocks that need to be flipped.\n    T = []\n\n    # Iterate through the string s and flip the colors of adjacent blocks if they are different.\n    for i in range(len(s) - 1):\n        if s[i] == 'B' and s[i + 1] == 'W':\n            # Flip the colors of the adjacent blocks and add the position of the left block to T.\n            s[i] = 'W'\n            s[i + 1] = 'B'\n            T.append(i + 1)\n        elif s[i] == 'B' and s[i + 1] == 'B':\n            # Flip the colors of the adjacent blocks and add the position of the left block to T.\n            s[i] = 'W'\n            s[i + 1] = 'W'\n            T.append(i + 1)\n\n    # Check if the number of black blocks is even.\n    if b % 2 == 0:\n        # Iterate from the end of the string to the beginning and flip the colors of adjacent blocks until a white block is found.\n        i = len(s) - 1\n        while s[i]!= 'W':\n            s[i] = 'W'\n            s[i - 1] = 'W'\n            T.append(i)\n            i -= 2\n    else:\n        # Iterate from the beginning of the string to the end and flip the colors of adjacent blocks until a black block is found.\n        i = 0\n        while s[i]!= 'B':\n            s[i] = 'B'\n            s[i + 1] = 'B'\n            T.append(i + 1)\n            i += 2\n\n    # Print the length of T and the elements of T.\n    print(len(T))\n    print(*T)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Count the number of black blocks (`cb`) and white blocks (`cw`) in the string `s`.\n3. If the number of black blocks and white blocks are both odd, it is impossible to make all blocks have the same color, so print `-1`.\n4. Otherwise, initialize an empty list `ans` to store the positions of the blocks that need to be flipped.\n5. If there are more black blocks than white blocks, iterate through the string `s` from left to right. When a white block is encountered, flip the colors of the blocks from the current block to the previous black block (inclusive) and add their positions to `ans`.\n6. If there are more white blocks than black blocks, iterate through the string `s` from left to right. When a black block is encountered, flip the colors of the blocks from the current block to the previous white block (inclusive) and add their positions to `ans`.\n7. Print the length of `ans` and the elements of `ans` (the positions of the blocks that need to be flipped).\n\nCOMMENTED CODE:\n```python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nINF = 10 ** 18\nMOD = 10**9+7\n\n# Read the number of blocks and the string representing the colors of the blocks\nn = int(input())\ns = input()\n\n# Count the number of black blocks and white blocks\ncb, cw = 0, 0\nfor i in s:\n    if i == 'B':\n        cb += 1\n    else:\n        cw += 1\n\n# If the number of black blocks and white blocks are both odd, it is impossible to make all blocks have the same color\nif cb % 2 == 1 and cw % 2 == 1:\n    print(-1)\nelse:\n    # Initialize an empty list to store the positions of the blocks that need to be flipped\n    ans = []\n\n    # If there are more black blocks than white blocks\n    if cb % 2 == 1:\n        # Initialize a variable to store the position of the previous black block\n        prev = -1\n        for i in range(n):\n            # If the current block is white\n            if s[i] == 'W':\n                # If the previous black block has not been found yet\n                if prev == -1:\n                    # Set the previous black block to the current position\n                    prev = i\n                else:\n                    # Flip the colors of the blocks from the current block to the previous black block (inclusive)\n                    for j in range(i-1, prev-1, -1):\n                        # Add the position of the block to be flipped to the list\n                        ans.append(j+1)\n                    # Reset the previous black block to -1\n                    prev = -1\n\n    # If there are more white blocks than black blocks\n    else:\n        # Initialize a variable to store the position of the previous white block\n        prev = -1\n        for i in range(n):\n            # If the current block is black\n            if s[i] == 'B':\n                # If the previous white block has not been found yet\n                if prev == -1:\n                    # Set the previous white block to the current position\n                    prev = i\n                else:\n                    # Flip the colors of the blocks from the current block to the previous white block (inclusive)\n                    for j in range(i-1, prev-1, -1):\n                        # Add the position of the block to be flipped to the list\n                        ans.append(j+1)\n                    # Reset the previous white block to -1\n                    prev = -1\n\n    # Print the length of the list and the elements of the list\n    print(len(ans))\n    print(*ans)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks from the input.\n2. Initialize counters `b` and `w` to keep track of the number of black and white blocks, respectively.\n3. Initialize empty lists `indexb` and `indexw` to store the indices of black and white blocks, respectively.\n4. Iterate through the string `s` and update the counters and lists based on the color of each block.\n5. Check if all blocks are of the same color. If so, print 0 and exit.\n6. Check if it's impossible to make all blocks the same color by checking if the number of white blocks is odd and the number of black blocks is odd. If so, print -1 and exit.\n7. Determine the parity of the number of white and black blocks. If they have the same parity, choose the majority color to make all blocks the same color.\n8. If the number of white blocks is even and the number of black blocks is odd, iterate through the indices of white blocks in steps of 2 and calculate the number of operations and positions needed to make all blocks black.\n9. If the number of white blocks is odd and the number of black blocks is even, iterate through the indices of black blocks in steps of 2 and calculate the number of operations and positions needed to make all blocks white.\n10. Print the number of operations and the positions needed to make all blocks the same color.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors of the blocks\nn = int(input())\ns = input()\n\n# Initialize counters for black and white blocks\nb = 0\nw = 0\n\n# Initialize empty lists to store the indices of black and white blocks\nindexb = []\nindexw = []\n\n# Iterate through the string and update the counters and lists\nfor i in range(0, len(s)):\n    if s[i] == \"B\":\n        # If the block is black, increment the counter and add its index to the list\n        b = b + 1\n        indexb.append(i + 1)\n    else:\n        # If the block is white, increment the counter and add its index to the list\n        w = w + 1\n        indexw.append(i + 1)\n\n# Check if all blocks are of the same color\nif b == 0:\n    # If all blocks are white, print 0 and exit\n    print(0)\nelif w == 0:\n    # If all blocks are black, print 0 and exit\n    print(0)\nelif w % 2!= 0 and b % 2!= 0:\n    # If it's impossible to make all blocks the same color, print -1 and exit\n    print(-1)\nelif w % 2 == 0 and b % 2!= 0:\n    # If the number of white blocks is even and the number of black blocks is odd\n    # Iterate through the indices of white blocks in steps of 2\n    for i in range(0, len(indexw), 2):\n        # Calculate the number of operations needed to make all blocks black\n        ops += indexw[i + 1] - indexw[i]\n        # Calculate the positions needed to make all blocks black\n        k = 0\n        for j in range(0, indexw[i + 1] - indexw[i]):\n            position.append(indexw[i] + k)\n            k = k + 1\n    # Print the number of operations and the positions needed\n    print(ops)\n    for i in range(0, len(position)):\n        print(position[i], end=\" \")\n    print(\"\")\nelif b % 2 == 0 and w % 2!= 0:\n    # If the number of black blocks is even and the number of white blocks is odd\n    # Iterate through the indices of black blocks in steps of 2\n    for i in range(0, len(indexb), 2):\n        # Calculate the number of operations needed to make all blocks white\n        ops += indexb[i + 1] - indexb[i]\n        # Calculate the positions needed to make all blocks white\n        k = 0\n        for j in range(0, indexb[i + 1] - indexb[i]):\n            position.append(indexb[i] + k)\n            k = k + 1\n    # Print the number of operations and the positions needed\n    print(ops)\n    for i in range(0, len(position)):\n        print(position[i], end=\" \")\n    print(\"\")\nelif b % 2 == 0 and w % 2 == 0:\n    # If the number of black blocks and white blocks have the same parity\n    # Choose the majority color to make all blocks the same color\n    if b > w:\n        # If there are more black blocks, iterate through the indices of white blocks in steps of 2\n        for i in range(0, len(indexw), 2):\n            # Calculate the number of operations needed to make all blocks black\n            ops += indexw[i + 1] - indexw[i]\n            # Calculate the positions needed to make all blocks black\n            k = 0\n            for j in range(0, indexw[i + 1] - indexw[i]):\n                position.append(indexw[i] + k)\n                k = k + 1\n        # Print the number of operations and the positions needed\n        print(ops)\n        for i in range(0, len(position)):\n            print(position[i], end=\" \")\n        print(\"\")\n    else:\n        # If there are more white blocks, iterate through the indices of black blocks in steps of 2\n        for i in range(0, len(indexb), 2):\n            # Calculate the number of operations needed to make all blocks white\n            ops += indexb[i + 1] - indexb[i]\n            # Calculate the positions needed to make all blocks white\n            k = 0\n            for j in range(0, indexb[i + 1] - indexb[i]):\n                position.append(indexb[i] + k)\n                k = k + 1\n        # Print the number of operations and the positions needed\n        print(ops)\n        for i in range(0, len(position)):\n            print(position[i], end=\" \")\n        print(\"\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Check if it's possible to make all blocks black by calling the `can` function with the string `s` and the character `'B'`.\n3. If it's possible to make all blocks black, print the number of operations and the positions of the blocks that need to be flipped.\n4. If it's not possible to make all blocks black, check if it's possible to make all blocks white by calling the `can` function with the string `s` and the character `'W'`.\n5. If it's possible to make all blocks white, print the number of operations and the positions of the blocks that need to be flipped.\n6. If it's not possible to make all blocks black or white, print `-1`.\n\nCOMMENTED CODE:\n```python\ndef can(S, c):  # Function to check if it's possible to make all blocks the same color\n    ans = ''  # Initialize an empty string to store the positions of blocks that need to be flipped\n    nc = False  # Initialize a flag to track if the current color is different from the target color\n    for i in range(len(S)):  # Iterate over the string\n        if (S[i]!= c and nc==False) or (S[i]==c and nc==True):  # Check if the current block needs to be flipped\n            ans += str(i+1) +''  # Add the position of the block to the answer string\n            nc = True  # Update the flag\n        else:\n            nc = False  # Reset the flag\n    if nc == True:  # If the last block needs to be flipped, it's not possible to make all blocks the same color\n        return False\n    return ans  # Return the answer string if it's possible to make all blocks the same color\n\n\nn = int(input())  # Read the number of blocks\ns = input()  # Read the string representing the colors of the blocks\nans = can(s, 'B')  # Check if it's possible to make all blocks black\nif ans!= False:  # If it's possible to make all blocks black\n    print(str(ans.count(' ')) + '\\n' + ans)  # Print the number of operations and the positions of blocks that need to be flipped\n    exit()  # Exit the program\nans = can(s, 'W')  # Check if it's possible to make all blocks white\nif ans!= False:  # If it's possible to make all blocks white\n    print(str(ans.count(' ')) + '\\n' + ans)  # Print the number of operations and the positions of blocks that need to be flipped\n    exit()  # Exit the program\nprint('-1')  # If it's not possible to make all blocks black or white, print -1\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Initialize variables to count the number of white blocks and to store the positions of white blocks that need to be inverted to make all blocks white.\n3. Iterate through the string `s` to count the number of white blocks and to store their positions in the `white` list.\n4. If the last block is white, print the count of white blocks and their positions.\n5. If the last block is not white, repeat steps 3-4 but for black blocks.\n6. If the last block is still not white after the second iteration, it is impossible to make all blocks have the same color, so print -1.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors of the blocks\nt = int(input())\ns = input()\n\n# Initialize variables to count the number of white blocks and to store their positions\nwhite = []\nwhite_count = 0\ntemp = list(s)  # Create a temporary copy of the string to avoid modifying the original string\n\n# Iterate through the string to count the number of white blocks and to store their positions\nfor j in range(len(s) - 1):\n    if temp[j] == 'B':  # If the current block is black\n        white_count += 1  # Increment the count of white blocks\n        temp[j + 1] = 'W' if temp[j + 1] == 'B' else 'B'  # Invert the color of the next block\n        white.append(j + 1)  # Store the position of the current block\n\n# If the last block is white, print the count of white blocks and their positions\nif temp[-1] == 'W':\n    print(white_count)\n    if len(white)!= 0:  # If there are white blocks that need to be inverted\n        print(*white)  # Print their positions\n\n# If the last block is not white, repeat the process but for black blocks\nelse:\n    black = []\n    black_count = 0\n    temp = list(s)  # Create a temporary copy of the string\n    for j in range(len(s) - 1):\n        if temp[j] == 'W':  # If the current block is white\n            black_count += 1  # Increment the count of black blocks\n            temp[j + 1] = 'B' if temp[j + 1] == 'W' else 'W'  # Invert the color of the next block\n            black.append(j + 1)  # Store the position of the current block\n\n    # If the last block is still not white after the second iteration, it is impossible to make all blocks have the same color\n    if temp[-1] == 'B':\n        print(black_count)\n        if len(black)!= 0:  # If there are black blocks that need to be inverted\n            print(*black)  # Print their positions\n    else:\n        print(-1)  # It is impossible to make all blocks have the same color\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the sequence of block colors from the input.\n2. Determine the initial color `c` of the blocks by checking the first block.\n3. Count the number of blocks with color `c` to determine if it's possible to make all blocks the same color.\n4. If the counts of blocks with color `c` and blocks with the opposite color are both odd, it's impossible to make all blocks the same color, so print -1.\n5. If the counts are both even or one is even and the other is odd, it's possible to make all blocks the same color. Determine the target color `c` based on the counts.\n6. Initialize an empty list `moves` to store the positions of blocks to be flipped.\n7. Iterate through the blocks, starting from the first block. If a block has the opposite color of the target color `c`, flip its color and the color of the next block, and add the position of the current block to the `moves` list.\n8. Print the number of moves and the positions of the blocks to be flipped.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the sequence of block colors from the input\nn = int(input().strip())\nblocks = list(input().strip())\n\n# Determine the initial color of the blocks by checking the first block\nc = blocks[0]  # initial color\n\n# Count the number of blocks with color c\ncnt = 0\nfor b in blocks:\n    if b == c:\n        cnt += 1\n\n# If the counts of blocks with color c and blocks with the opposite color are both odd,\n# it's impossible to make all blocks the same color, so print -1\nif cnt % 2 and (n - cnt) % 2:\n    print(-1)\nelse:\n    # If the counts are both even or one is even and the other is odd,\n    # it's possible to make all blocks the same color. Determine the target color c based on the counts\n    if (n - cnt) % 2:\n        c = 'W' if c == 'B' else 'B'  # flip the target color\n\n    # Initialize an empty list moves to store the positions of blocks to be flipped\n    moves = []\n\n    # Iterate through the blocks, starting from the first block\n    for i in range(n - 1):\n        # If a block has the opposite color of the target color c,\n        # flip its color and the color of the next block, and add the position of the current block to the moves list\n        if blocks[i]!= c:\n            blocks[i] = c  # flip the color of the current block\n            blocks[i + 1] = 'W' if blocks[i + 1] == 'B' else 'B'  # flip the color of the next block\n            moves.append(str(i + 1))  # add the position of the current block to the moves list\n\n    # Print the number of moves and the positions of the blocks to be flipped\n    print(len(moves))\n    print(' '.join(moves))\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the color sequence `s` from the input.\n2. Initialize an empty list `ans` to store the indices of blocks that need to be flipped.\n3. Iterate over three possible scenarios (k=0, 1, 2) to find a sequence of operations that makes all blocks have the same color.\n4. In each scenario, initialize a variable `q` to the color of the first block.\n5. Iterate over the blocks from the second block to the second last block.\n6. If the current block's color is different from `q`, add the index of the current block (or its mirrored index) to `ans`, flip the colors of the current block and the next block, and update `q` to the flipped color.\n7. If the color of the last block is the same as `q`, break the loop.\n8. If the color of the last block is different from `q`, reverse the list `s` and repeat steps 5-7.\n9. If the color of the first and last blocks are the same after the loop, print the length of `ans` and the indices in `ans`.\n10. Otherwise, print -1.\n\nCOMMENTED CODE:\n```python\ndef num():\n    # Read an integer from the input and convert it to an integer\n    return int(input())\n\ndef line():\n    # Read a line from the input and split it into integers\n    return map(int, input().split())\n\nn = num()  # Read the number of blocks\ns = [c == 'B' for c in input()]  # Read the color sequence and convert it to a list of booleans\nans = []  # Initialize an empty list to store the indices of blocks that need to be flipped\n\n# Iterate over three possible scenarios (k=0, 1, 2) to find a sequence of operations\nfor k in range(3):\n    q = s[0]  # Initialize a variable q to the color of the first block\n    for i in range(1, n - 1):  # Iterate over the blocks from the second block to the second last block\n        if s[i]!= q:  # If the current block's color is different from q\n            # Add the index of the current block (or its mirrored index) to ans\n            ans.append(i + 1 if k % 2 == 0 else n - i - 1)\n            # Flip the colors of the current block and the next block\n            s[i] = 1 - s[i]\n            s[i + 1] = 1 - s[i + 1]\n    if s[-1] == q:  # If the color of the last block is the same as q\n        break  # Break the loop\n    # If the color of the last block is different from q, reverse the list s and repeat the loop\n    s = s[::-1]\n\nif s[0] == s[-1]:  # If the color of the first and last blocks are the same\n    # Print the length of ans and the indices in ans\n    print(len(ans))\n    print(' '.join(map(str, ans)))\nelse:\n    # Print -1 if it is impossible to make all blocks have the same color\n    print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Convert the string `s` into a list of boolean values `l`, where `l[i]` is `True` if the `i-th` block is white and `False` otherwise.\n3. Initialize an empty list `ind` to store the indices of the blocks that need to be flipped.\n4. Iterate over the blocks from left to right. If the current block is white (`l[i]` is `True`), append its index `i + 1` to `ind`, flip the current block and the next block, and continue to the next block.\n5. If the last block is not white after the previous step, it means that all blocks cannot be made the same color, so print `-1` and exit.\n6. Repeat steps 4 and 5 for the case where all blocks are initially black.\n7. If the last block is white after both iterations, print the length of `ind` and the elements of `ind`.\n\nCOMMENTED CODE:\n```python\nimport sys\n\ndef I():\n    # Read a line from standard input and remove the newline character\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    # Read the number of blocks\n    n = int(I())\n    # Read the string representing the colors of the blocks\n    s = I()\n    # Initialize an empty list to store the indices of blocks that need to be flipped\n    ind = []\n\n    # Convert the string into a list of boolean values\n    l = [i == 'W' for i in s]\n    # Iterate over the blocks from left to right\n    for i in range(n - 1):\n        # If the current block is white\n        if l[i]:\n            # Append its index to ind\n            ind.append(i + 1)\n            # Flip the current block and the next block\n            l[i] = not l[i]\n            l[i + 1] = not l[i + 1]\n    # If the last block is not white after the previous iteration\n    if not l[-1]:\n        # Print the length of ind and the elements of ind\n        print(len(ind))\n        print(*ind)\n        return\n\n    # Repeat the previous steps for the case where all blocks are initially black\n    ind = []\n    l = [i == 'B' for i in s]\n    for i in range(n - 1):\n        if l[i]:\n            ind.append(i + 1)\n            l[i] = not l[i]\n            l[i + 1] = not l[i + 1]\n    if not l[-1]:\n        print(len(ind))\n        print(*ind)\n        return\n\n    # If the last block is white after both iterations, it means that all blocks cannot be made the same color\n    print(-1)\n\nmain()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the color sequence `A` from the input.\n2. Create a copy of the color sequence `B` to perform operations on.\n3. Initialize an empty list `ans` to store the indices of blocks that need to be flipped.\n4. Perform the first pass of flipping blocks to make all blocks black. This is done by iterating through the sequence and flipping the color of each block and its adjacent block if they are not already black.\n5. Check if the last block is black after the first pass. If not, it means it's impossible to make all blocks black, so print -1 and exit.\n6. Perform the second pass of flipping blocks to make all blocks white. This is done similarly to the first pass, but with the goal of making all blocks white.\n7. Check if the last block is white after the second pass. If not, it means it's impossible to make all blocks white, so print -1 and exit.\n8. If both passes were successful, print the number of operations and the indices of the blocks that were flipped.\n\nCOMMENTED CODE:\n```python\nimport sys\nimport math\nimport bisect\n\ndef solve1(A, ans):\n    # Perform the first pass of flipping blocks to make all blocks black\n    n = len(A)\n    ans.clear()  # Clear the list of flipped blocks\n    for i in range(n - 1):\n        if A[i]!= 'B':  # If the current block is not black\n            A[i] = 'B'  # Flip the color of the current block\n            if A[i+1] == 'W':  # If the adjacent block is white\n                A[i+1] = 'B'  # Flip the color of the adjacent block\n            else:  # If the adjacent block is black\n                A[i+1] = 'W'  # Flip the color of the adjacent block\n            ans.append(i)  # Add the index of the current block to the list of flipped blocks\n    #print('A:'+ str(A))  # Print the updated color sequence\n    #print('ans:'+ str(ans))  # Print the list of flipped blocks\n    return A[n-1] == 'B'  # Return True if the last block is black, False otherwise\n\ndef solve2(A, ans):\n    # Perform the second pass of flipping blocks to make all blocks white\n    n = len(A)\n    ans.clear()  # Clear the list of flipped blocks\n    for i in range(n - 1):\n        if A[i]!= 'W':  # If the current block is not white\n            A[i] = 'W'  # Flip the color of the current block\n            if A[i+1] == 'W':  # If the adjacent block is white\n                A[i+1] = 'B'  # Flip the color of the adjacent block\n            else:  # If the adjacent block is black\n                A[i+1] = 'W'  # Flip the color of the adjacent block\n            ans.append(i)  # Add the index of the current block to the list of flipped blocks\n    #print('A:'+ str(A))  # Print the updated color sequence\n    #print('ans:'+ str(ans))  # Print the list of flipped blocks\n    return A[n-1] == 'W'  # Return True if the last block is white, False otherwise\n\ndef main():\n    n = int(input())  # Read the number of blocks\n    A = list(input())  # Read the color sequence\n    B = A.copy()  # Create a copy of the color sequence\n    ans = []  # Initialize the list of flipped blocks\n    if (solve1(B, ans)):  # Perform the first pass and check if all blocks are black\n        print(len(ans))  # Print the number of operations\n        print(' '.join(list(str(a+1) for a in ans)))  # Print the indices of flipped blocks\n    else:\n        B = A.copy()  # Reset the color sequence\n        if solve2(B, ans):  # Perform the second pass and check if all blocks are white\n            print(len(ans))  # Print the number of operations\n            print(' '.join(list(str(a+1) for a in ans)))  # Print the indices of flipped blocks\n        else:\n            print(-1)  # Print -1 if it's impossible to make all blocks the same color\n\nif __name__ == \"__main__\":\n    main()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The number of blocks (n) and the string representing the colors of the blocks (s).\n2. Count the number of black and white blocks.\n3. Check if it's possible to make all blocks the same color by checking if the total number of blocks is even and the number of black or white blocks is odd. If it's not possible, print -1.\n4. If it's possible, determine the target color (black or white) based on the counts of black and white blocks.\n5. Initialize an empty list to store the positions of the blocks that need to be swapped.\n6. Iterate through the string of block colors. If a block's color does not match the target color, swap the colors of the current block and the next block, and add the position of the current block to the list of positions to be swapped.\n7. Print the number of positions to be swapped and the positions themselves.\n\nCOMMENTED CODE:\n```python\ndef swap(l, n, i):\n    # Swap the color of the block at position i\n    if l[i] == 'B':\n        l[i] = 'W'\n    else:\n        l[i] = 'B'\n    return l\n\ndef check(l, n, col):\n    # Check if all blocks have the same color\n    if col == 'B':\n        for i in l:\n            if i == 'W':\n                return False\n        return True\n    else:\n        for i in l:\n            if i == 'B':\n                return False\n        return True\n\ndef solve(s, n):\n    # Initialize counts of black and white blocks\n    cb = 0\n    cw = 0\n    # Initialize list to store positions of blocks to be swapped\n    ans = list()\n    \n    # Count black and white blocks\n    for i in range(n):\n        if s[i] == 'W':\n            cw += 1\n        else:\n            cb += 1\n    \n    # Check if it's possible to make all blocks the same color\n    if n % 2 == 0:\n        if cb % 2 == 1:\n            # If it's not possible, print -1\n            print(-1)\n            return\n        else:\n            # Determine the target color\n            col = 'x'\n            if cb > cw:\n                col = 'B'\n            else:\n                col = 'W'\n            \n            # Iterate through the string of block colors\n            while not check(s, n, col):\n                for i in range(n):\n                    # If a block's color does not match the target color, swap the colors of the current block and the next block\n                    if s[i]!= col:\n                        s = swap(s, n, i)\n                        s = swap(s, n, i + 1)\n                        # Add the position of the current block to the list of positions to be swapped\n                        ans.append(i + 1)\n    \n    else:\n        # Determine the target color\n        col = 'x'\n        if cb % 2 == 1:\n            col = 'B'\n        else:\n            col = 'W'\n        # Initialize list to store positions of blocks to be swapped\n        ans = list()\n        # Iterate through the string of block colors\n        while not check(s, n, col):\n            for i in range(n):\n                # If a block's color does not match the target color, swap the colors of the current block and the next block\n                if s[i]!= col:\n                    s = swap(s, n, i)\n                    s = swap(s, n, i + 1)\n                    # Add the position of the current block to the list of positions to be swapped\n                    ans.append(i + 1)\n    \n    # Print the number of positions to be swapped and the positions themselves\n    print(len(ans))\n    for i in range(len(ans)):\n        print(ans[i], end=\" \")\n    print()\n\n# Read the input\nn = int(input())\ns = input()\n# Convert the string of block colors to a list\nl = list()\nfor i in range(n):\n    l.append(s[i])\n# Call the solve function\nsolve(l, n)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the color sequence `s` from the input.\n2. Initialize an empty list `arr1` to store the indices of blocks that need to be flipped to make all blocks white.\n3. Iterate through the color sequence `s`. If a block is black, check if it's the last block. If it's not the last block, flip the current block and the next block, and add the index of the next block to `arr1`.\n4. Initialize an empty list `arr2` to store the indices of blocks that need to be flipped to make all blocks black.\n5. Iterate through the color sequence `s` again. If a block is white, check if it's the last block. If it's not the last block, flip the current block and the next block, and add the index of the next block to `arr2`.\n6. Check if it's possible to make all blocks the same color by checking if `arr1` or `arr2` is empty. If it's not possible, print -1.\n7. If it's possible to make all blocks the same color, print the length of `arr1` or `arr2`, and then print the elements of `arr1` or `arr2`.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks n and the color sequence s from the input\nn = int(input())\ns = input()\n\n# Initialize an empty list arr1 to store the indices of blocks that need to be flipped to make all blocks white\narr1 = []\n\n# Initialize a flag to check if it's possible to make all blocks white\nflag = 1\n\n# Iterate through the color sequence s\ni = 0\nwhile i < n:\n    # If a block is white, skip it\n    if s[i] == 'W':\n        i += 1\n        continue\n    else:\n        # If a block is black, check if it's the last block\n        if i == n - 1:\n            # If it's the last block, set the flag to 0\n            flag = 0\n            break\n        # Flip the current block and the next block, and add the index of the next block to arr1\n        a = [i for i in s]\n        a[i] = 'W'\n        if a[i + 1] == 'B':\n            a[i + 1] = 'W'\n        else:\n            a[i + 1] = 'B'\n        arr1.append(i + 1)\n        i += 1\n\n# Initialize an empty list arr2 to store the indices of blocks that need to be flipped to make all blocks black\narr2 = []\n\n# Initialize a flag to check if it's possible to make all blocks black\nf = 1\n\n# Iterate through the color sequence s again\ni = 0\nwhile i < n:\n    # If a block is black, skip it\n    if s[i] == 'B':\n        i += 1\n        continue\n    else:\n        # If a block is white, check if it's the last block\n        if i == n - 1:\n            # If it's the last block, set the flag to 0\n            f = 0\n            break\n        # Flip the current block and the next block, and add the index of the next block to arr2\n        b = [i for i in s]\n        b[i] = 'B'\n        if b[i + 1] == 'B':\n            b[i + 1] = 'W'\n        else:\n            b[i + 1] = 'B'\n        arr2.append(i + 1)\n        i += 1\n\n# Check if it's possible to make all blocks the same color\nif flag == 1:\n    # If it's possible to make all blocks white, print the length of arr1 and the elements of arr1\n    print(len(arr1))\n    if len(arr1) > 0:\n        print(*arr1)\nelif f == 1:\n    # If it's possible to make all blocks black, print the length of arr2 and the elements of arr2\n    print(len(arr2))\n    if len(arr2) > 0:\n        print(*arr2)\nelse:\n    # If it's not possible to make all blocks the same color, print -1\n    print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input values: the number of blocks `n` and the string `A` representing the colors of the blocks.\n2. Count the number of black blocks `b` and white blocks `w`.\n3. Check if it's impossible to make all blocks have the same color by verifying if `b` and `w` have different parities. If so, print `-1`.\n4. Initialize variables to store the result `res` and the list of operations `R`.\n5. Iterate through the blocks, starting from the first block. For each block, check if it's black. If it is, invert the colors of the current block and the next block, increment `res`, and append the position of the current block to `R`.\n6. After the iteration, check if the last block is black. If it is, reset `res` and `R`, and repeat the iteration from step 5, but this time inverting the colors of the current block and the next block when the current block is white.\n7. Print the result `res` and the list of operations `R`.\n\nCOMMENTED CODE:\n```python\n# Read the input values: the number of blocks n and the string A representing the colors of the blocks.\nn, = inp()\nA, = inp(str)\n\n# Count the number of black blocks b and white blocks w.\nb = A.count('B')\nw = n - b\n\n# Convert the string A to a list for easier manipulation.\nA = list(A)\n\n# Create a copy of the list A to use for the second iteration.\nB = A[::]\n\n# Check if it's impossible to make all blocks have the same color by verifying if b and w have different parities.\nif b % 2 and w % 2:\n    # If so, print -1.\n    print(-1)\nelse:\n    # Initialize variables to store the result res and the list of operations R.\n    res, flag = 0, False\n    R = []\n\n    # Iterate through the blocks, starting from the first block.\n    for i in range(n - 1):\n        # For each block, check if it's black.\n        if A[i] == 'B':\n            # If it is, invert the colors of the current block and the next block.\n            A[i], A[i + 1] = 'W', 'W' if A[i + 1] == 'B' else 'B'\n            # Increment res.\n            res += 1\n            # Append the position of the current block to R.\n            R.append(str(i + 1))\n\n    # After the iteration, check if the last block is black.\n    if A[n - 1] == 'B':\n        # If it is, reset res and R.\n        res, R = 0, []\n        # Use the copy of the list A (B) for the second iteration.\n        A = B[::]\n        # Repeat the iteration from step 5, but this time inverting the colors of the current block and the next block when the current block is white.\n        for i in range(n - 1):\n            if A[i] == 'W':\n                A[i], A[i + 1] = 'B', 'B' if A[i + 1] == 'W' else 'W'\n                res += 1\n                R.append(str(i + 1))\n\n    # Print the result res and the list of operations R.\n    print(res)\n    print(' '.join(R))\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Convert the string `s` into a list `a` where 0 represents a black block and 1 represents a white block.\n3. Initialize an empty list `ans` to store the indices of the blocks that need to be flipped.\n4. Iterate through the list `a` starting from the second block (index 1) to the second last block (index n-2).\n5. If the current block and the previous block have different colors, flip their colors and add the index of the current block to `ans`.\n6. If the number of blocks `n` is odd and the last two blocks have different colors, flip the colors of every other block starting from the first block.\n7. Check if all blocks are of the same color. If not, print -1.\n8. If all blocks are of the same color, print the length of `ans` and the indices in `ans`.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks n and the string s representing the colors of the blocks\nn = int(input())\ns = input()\n\n# Convert the string s into a list a where 0 represents a black block and 1 represents a white block\na = []\nfor i in s:\n    if i == \"B\":\n        a.append(0)  # 0 represents a black block\n    else:\n        a.append(1)  # 1 represents a white block\n\n# Initialize an empty list ans to store the indices of the blocks that need to be flipped\nans = []\n\n# Initialize st with the color of the first block\nst = a[0]\n\n# Iterate through the list a starting from the second block (index 1) to the second last block (index n-2)\nfor i in range(1, len(s) - 1):\n    # If the current block and the previous block have different colors\n    if a[i]!= st:\n        # Flip their colors\n        a[i] = (a[i] + 1) % 2\n        a[i + 1] = (a[i + 1] + 1) % 2\n        # Add the index of the current block to ans\n        ans.append(i + 1)\n    # Update st with the color of the current block\n    st = a[i]\n\n# If the number of blocks n is odd and the last two blocks have different colors\nif a[n - 1]!= a[n - 2] and n % 2 == 1:\n    # Flip the colors of every other block starting from the first block\n    for i in range(0, n - 2, 2):\n        a[i] = (a[i] + 1) % 2\n        a[i + 1] = (a[i + 1] + 1) % 2\n        # Add the index of the current block to ans\n        ans.append(i + 1)\n\n# Check if all blocks are of the same color\nif a.count(1) == n or a.count(0) == n:\n    # If all blocks are of the same color, print the length of ans and the indices in ans\n    print(len(ans))\n    for i in ans:\n        print(i, end=\" \")\n    print()\nelse:\n    # If not, print -1\n    print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The number of blocks `n` and the sequence of blocks `seq`.\n2. Convert the sequence into a list of binary values `S`, where 0 represents a white block and 1 represents a black block.\n3. Check if the number of white blocks is even or the number of black blocks is even. If both are even, proceed to transform all blocks to one color.\n4. If the number of white blocks is even, transform all white blocks to black by iterating through the sequence and inverting the color of each white block and its adjacent block.\n5. If the number of black blocks is even, transform all black blocks to white by iterating through the sequence and inverting the color of each black block and its adjacent block.\n6. If neither the number of white blocks nor the number of black blocks is even, it is impossible to make all blocks have the same color, so print -1.\n7. Print the number of operations and the positions of the blocks that were inverted.\n\nCOMMENTED CODE:\n```python\n# Read the input: The number of blocks n and the sequence of blocks seq\nn = int(input())\nseq = input()\n\n# Convert the sequence into a list of binary values S, where 0 represents a white block and 1 represents a black block\nS = [(0 if c == 'W' else 1) for c in seq]\n\n# Initialize an empty list to store the positions of the blocks that were inverted\noperations = []\n\n# Check if the number of white blocks is even or the number of black blocks is even\nif seq.count('W') % 2 == 0:\n    # If the number of white blocks is even, transform all white blocks to black\n    # by iterating through the sequence and inverting the color of each white block and its adjacent block\n    for start in range(n - 1):\n        if S[start] == 0:\n            # Invert the color of the current block and its adjacent block\n            S[start] = 1 - S[start]\n            S[start + 1] = 1 - S[start + 1]\n            # Append the position of the block that was inverted to the operations list\n            operations.append(start + 1)\n\n    # Print the number of operations and the positions of the blocks that were inverted\n    print(str(len(operations)) + '\\n' +''.join(map(str, operations)))\n\nelif seq.count('B') % 2 == 0:\n    # If the number of black blocks is even, transform all black blocks to white\n    # by iterating through the sequence and inverting the color of each black block and its adjacent block\n    for start in range(n - 1):\n        if S[start] == 1:\n            # Invert the color of the current block and its adjacent block\n            S[start] = 1 - S[start]\n            S[start + 1] = 1 - S[start + 1]\n            # Append the position of the block that was inverted to the operations list\n            operations.append(start + 1)\n\n    # Print the number of operations and the positions of the blocks that were inverted\n    print(str(len(operations)) + '\\n' +''.join(map(str, operations)))\nelse:\n    # If neither the number of white blocks nor the number of black blocks is even,\n    # it is impossible to make all blocks have the same color, so print -1\n    print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the input: The first step is to read the number of blocks (n) and the string representing the colors of the blocks (s).\n2. Count the number of black and white blocks: Count the number of black and white blocks to determine if it's possible to make all blocks the same color.\n3. Check if it's impossible to make all blocks the same color: If the number of black blocks and white blocks are both odd, it's impossible to make all blocks the same color, so print -1.\n4. Initialize variables: Initialize variables to keep track of the number of operations (count) and the positions of the blocks to be flipped (answer).\n5. Determine the color to flip to: If there are more black blocks, flip to white; otherwise, flip to black.\n6. Iterate through the blocks: Iterate through the blocks, starting from the first block.\n7. Check if the current block needs to be flipped: If the current block needs to be flipped, increment the count and add the position of the current block to the answer list.\n8. Check if the next block needs to be flipped: If the next block needs to be flipped, increment the count and add the position of the next block to the answer list.\n9. Print the result: Print the number of operations and the positions of the blocks to be flipped.\n\nCOMMENTED CODE:\n```python\n# Read the input\nn = int(input())  # number of blocks\ns = input()  # string representing the colors of the blocks\n\n# Count the number of black and white blocks\nb = s.count(\"B\")  # number of black blocks\nw = s.count(\"W\")  # number of white blocks\n\n# Check if it's impossible to make all blocks the same color\nif b % 2!= 0 and w % 2!= 0:\n    print(-1)  # if both numbers are odd, it's impossible\n\nelse:\n    # Determine the color to flip to\n    if b % 2!= 0:  # if there are more black blocks, flip to white\n        target_color = \"W\"\n    else:  # otherwise, flip to black\n        target_color = \"B\"\n\n    # Initialize variables\n    count = 0  # number of operations\n    answer = []  # positions of the blocks to be flipped\n\n    # Iterate through the blocks\n    i = 0\n    while i < (n - 1):\n        # Check if the current block needs to be flipped\n        if s[i] == target_color:\n            f = True  # flag to indicate if the current block needs to be flipped\n        if f:\n            count += 1  # increment the count\n            answer.append(i + 1)  # add the position of the current block to the answer list\n            # Check if the next block needs to be flipped\n            if s[i + 1] == target_color:\n                i += 1  # increment the index\n                f = False  # reset the flag\n        i += 1\n\n    # Print the result\n    print(count)  # print the number of operations\n    print(*answer)  # print the positions of the blocks to be flipped\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the color sequence `qqq` from the input.\n2. Convert the color sequence `qqq` into a list of characters `b`.\n3. Initialize an empty list `ans` to store the indices of blocks that need to be flipped.\n4. Try to make all blocks black by iterating through the list `b` and flipping the colors of adjacent blocks if they are not the desired color (`p`).\n5. If the resulting list `b` is all black or all white, reverse the list `ans` and print the length of `ans` and the indices in `ans` separated by spaces.\n6. If the resulting list `b` is not all black or all white, try to make all blocks white by repeating steps 4 and 5 with the desired color (`p`) changed to white and the other color (`q`) changed to black.\n7. If the resulting list `b` is still not all black or all white, print -1.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks n and the color sequence qqq from the input\na = int(input())\nqqq = input()\n\n# Convert the color sequence qqq into a list of characters b\nb = list(qqq)\n\n# Initialize an empty list ans to store the indices of blocks that need to be flipped\nans = []\n\n# Try to make all blocks black by iterating through the list b and flipping the colors of adjacent blocks if they are not the desired color (p)\np = 'B'  # desired color\nq = 'W'  # other color\nfor i in range(len(b) - 1):\n    if b[i]!= p:  # if the current block is not the desired color\n        b[i] = p  # flip the color of the current block\n        ans.append(i + 1)  # add the index of the current block to ans\n        if b[i + 1] == p:  # if the next block is the desired color\n            b[i + 1] = q  # flip the color of the next block\n        else:\n            b[i + 1] = p  # flip the color of the next block\n\n# If the resulting list b is all black or all white, reverse the list ans and print the length of ans and the indices in ans separated by spaces\nif b == list('W' * len(b)) or b == list('B' * len(b)):\n    ans.reverse()  # reverse the list ans\n    if len(ans) == 0:  # if ans is empty\n        print('0')  # print 0\n    else:\n        print(len(ans))  # print the length of ans\n        print(' '.join([str(i) for i in ans]))  # print the indices in ans separated by spaces\n    exit(0)  # exit the program\n\n# If the resulting list b is not all black or all white, try to make all blocks white by repeating steps 4 and 5 with the desired color (p) changed to white and the other color (q) changed to black\nelse:\n    b = list(qqq)  # reset the list b to the original color sequence\n    ans = []  # reset the list ans to empty\n    p = 'W'  # change the desired color to white\n    q = 'B'  # change the other color to black\n    for i in range(len(b) - 1):\n        if b[i]!= p:  # if the current block is not the desired color\n            b[i] = p  # flip the color of the current block\n            ans.append(i + 1)  # add the index of the current block to ans\n            if b[i + 1] == p:  # if the next block is the desired color\n                b[i + 1] = q  # flip the color of the next block\n            else:\n                b[i + 1] = p  # flip the color of the next block\n\n    # If the resulting list b is still not all black or all white, print -1\n    if b == list('W' * len(b)) or b == list('B' * len(b)):\n        ans.reverse()  # reverse the list ans\n        if len(ans) == 0:  # if ans is empty\n            print('0')  # print 0\n        else:\n            print(len(ans))  # print the length of ans\n            print(' '.join([str(i) for i in ans]))  # print the indices in ans separated by spaces\n        exit(0)  # exit the program\n    else:\n        print('-1')  # print -1\n        exit(0)  # exit the program\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Calculate the number of black blocks `b` and white blocks `w`.\n3. Check if it's impossible to make all blocks have the same color by verifying if both `b` and `w` are odd. If so, print -1 and return.\n4. Determine the target color (`odd` or `even`) based on whether `w` or `b` is odd.\n5. Iterate through the blocks, starting from the first block to the second last block.\n6. For each block, check if its color is not the target color.\n7. If the color is not the target color, add the current block's index to the answer list `ans`, invert the colors of the current block and the next block, and update the colors of the next block based on the target color.\n8. Print the length of `ans` and the indices in `ans` separated by spaces.\n\nCOMMENTED CODE:\n```python\ndef sol():\n  # Read the number of blocks and the string representing the colors of the blocks\n  n = int(input())\n  s = input()\n\n  # Calculate the number of black blocks and white blocks\n  b = sum(map(lambda x: x == 'B', s))\n  w = sum(map(lambda x: x == 'W', s))\n\n  # Check if it's impossible to make all blocks have the same color\n  if w % 2 == 1 and b % 2 == 1:\n    # If both w and b are odd, it's impossible to make all blocks have the same color\n    print(-1)\n    return\n\n  # Determine the target color (odd or even) based on whether w or b is odd\n  if w % 2 == 1:\n    # If w is odd, the target color is 'W' (odd)\n    odd = 'W'\n    even = 'B'\n  else:\n    # If b is odd, the target color is 'B' (odd)\n    odd = 'B'\n    even = 'W'\n\n  # Initialize an empty list to store the indices of the blocks to be inverted\n  ans = list()\n\n  # Convert the string s to a list of characters for easier manipulation\n  s = list(s)\n\n  # Iterate through the blocks, starting from the first block to the second last block\n  for i in range(n-1):\n    # Check if the current block's color is not the target color\n    if s[i]!= odd:\n      # If the color is not the target color, add the current block's index to the answer list\n      ans.append(i + 1)\n      # Invert the colors of the current block and the next block\n      s[i] = odd\n      s[i+1] = even if s[i+1] == odd else odd\n\n  # Print the length of ans and the indices in ans separated by spaces\n  print(len(ans))\n  print(' '.join(map(str, ans)))\n\nsol()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the color sequence from the input.\n2. Convert the color sequence into a binary sequence where 'B' is 0 and 'W' is 1.\n3. Check if all blocks are of the same color. If yes, print 0 and return.\n4. Initialize two lists `modify0` and `modify1` to store the indices of blocks that need to be changed to 0 and 1 respectively.\n5. Iterate through the binary sequence and append the indices of blocks that need to be changed to their respective lists.\n6. Determine which list has an even number of elements. This list will be used to create pairs of blocks to change their colors.\n7. If neither list has an even number of elements, it's impossible to make all blocks the same color, so print -1 and return.\n8. Create pairs of blocks to change their colors by iterating through the chosen list in steps of 2.\n9. For each pair, iterate through the indices between the pair's elements (inclusive) and append each index as a pair to the `ops` list.\n10. Print the number of operations and the indices of the blocks that need to be changed.\n\nCOMMENTED CODE:\n```python\ndef f():\n    # Read the number of blocks and the color sequence from the input\n    n = int(input())\n    d = {'B':0,'W':1}  # Dictionary to map 'B' to 0 and 'W' to 1\n    line = [d[char] for char in input()]  # Convert color sequence to binary sequence\n\n    # Check if all blocks are of the same color\n    if not any(line):  # any() returns True if at least one element is True\n        print(0)  # If all blocks are 0 (i.e., all 'B'), print 0 and return\n        return\n    if all(line):  # all() returns True if all elements are True\n        print(0)  # If all blocks are 1 (i.e., all 'W'), print 0 and return\n        return\n\n    # Initialize lists to store indices of blocks that need to be changed\n    modify0 = []  # List to store indices of blocks that need to be changed to 0\n    modify1 = []  # List to store indices of blocks that need to be changed to 1\n\n    # Iterate through the binary sequence and append indices to their respective lists\n    for i in range(n):\n        if line[i]:  # If the current block is 1 (i.e., 'W')\n            modify1.append(i)  # Append its index to modify1\n        else:  # If the current block is 0 (i.e., 'B')\n            modify0.append(i)  # Append its index to modify0\n\n    # Determine which list has an even number of elements\n    modify = None\n    if len(modify1)%2==0:  # If modify1 has an even number of elements\n        modify = modify1  # Use modify1 to create pairs\n    elif len(modify0)%2==0:  # If modify0 has an even number of elements\n        modify = modify0  # Use modify0 to create pairs\n\n    # If neither list has an even number of elements, it's impossible to make all blocks the same color\n    if modify is None:\n        print(-1)  # Print -1 and return\n        return\n\n    # Create pairs of blocks to change their colors\n    m = len(modify)  # Get the length of the chosen list\n    ops = []  # List to store pairs of indices\n    for i in range(0,m,2):  # Iterate through the list in steps of 2\n        x = modify[i]  # Get the index of the first block in the pair\n        y = modify[i+1]  # Get the index of the second block in the pair\n        for ind in range(x,y):  # Iterate through the indices between the pair's elements (inclusive)\n            ops.append((ind,ind+1))  # Append each index as a pair to ops\n\n    # Print the number of operations and the indices of the blocks that need to be changed\n    print(len(ops))  # Print the number of operations\n    print(' '.join(str(op[1]) for op in ops))  # Print the indices of the blocks that need to be changed\n\nf()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Initialize an empty list `ans` to store the positions of the blocks that need to be flipped.\n3. Iterate over the blocks from left to right, checking if the current block and the next block have different colors.\n4. If they do, flip the colors of the current block and the next block, and add the position of the next block to `ans`.\n5. After the first iteration, check if all blocks have the same color. If they do, print the length of `ans` and the elements of `ans`.\n6. If not, reset `s` to its original state and repeat steps 3-5, but this time flipping the colors of the blocks from black to white.\n7. If after the second iteration all blocks have the same color, print the length of `ans` and the elements of `ans`.\n8. If not, print -1 to indicate that it is impossible to make all blocks have the same color.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors of the blocks\nn = int(input())\ns = list(input())  # Convert the string to a list for easier manipulation\n\n# Initialize an empty list to store the positions of the blocks that need to be flipped\nans = []\n\n# Iterate over the blocks from left to right\nfor i in range(n-1):\n    # Check if the current block and the next block have different colors\n    if s[i] == 'W':  # If the current block is white\n        s[i] = 'B'  # Flip its color to black\n        if s[i+1] == 'W':  # If the next block is white\n            s[i+1] = 'B'  # Flip its color to black\n        else:  # If the next block is black\n            s[i+1] = 'W'  # Flip its color to white\n        ans.append(i+1)  # Add the position of the next block to ans\n\n# Check if all blocks have the same color after the first iteration\nif len(set(s)) == 1:  # If all blocks have the same color\n    print(len(ans))  # Print the length of ans\n    print(*ans)  # Print the elements of ans\n    exit()  # Exit the program\n\n# Reset s to its original state\ns = list(input())\n\n# Repeat steps 3-5, but this time flipping the colors of the blocks from black to white\nfor i in range(n-1):\n    if s[i] == 'B':  # If the current block is black\n        s[i] = 'W'  # Flip its color to white\n        if s[i+1] == 'W':  # If the next block is white\n            s[i+1] = 'B'  # Flip its color to black\n        else:  # If the next block is black\n            s[i+1] = 'W'  # Flip its color to white\n        ans.append(i+1)  # Add the position of the next block to ans\n\n# Check if all blocks have the same color after the second iteration\nif len(set(s)) == 1:  # If all blocks have the same color\n    print(len(ans))  # Print the length of ans\n    print(*ans)  # Print the elements of ans\nelse:  # If not\n    print(-1)  # Print -1 to indicate that it is impossible to make all blocks have the same color\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Count the number of black blocks `t1` and white blocks `t2`.\n3. Check if it's impossible to make all blocks have the same color by verifying if both `t1` and `t2` are odd. If so, print -1.\n4. Initialize variables `c` to count the number of operations and `a1` to store the positions of the blocks that need to be flipped.\n5. Determine the target color `b` based on whether `t2` is even or odd.\n6. Iterate through the string `s` from left to right, checking each block's color against the target color `b`.\n7. If a block's color doesn't match the target color, increment `c` and perform the flip operation by changing the color of the current block and the next block.\n8. Append the position of the block that was flipped to the list `a1`.\n9. Print the total number of operations `c` and the positions of the blocks that were flipped.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors of the blocks\nn = int(input())\ns = input()\n\n# Count the number of black blocks and white blocks\nt1 = s.count('B')\nt2 = s.count('W')\n\n# Check if it's impossible to make all blocks have the same color\nif t1 % 2 == 1 and t2 % 2 == 1:\n    # If both counts are odd, it's impossible to make all blocks have the same color\n    print(\"-1\")\nelse:\n    # Initialize variables to count the number of operations and store the positions of the blocks that need to be flipped\n    c = 0\n    a1 = []\n    b = \"#\"  # Initialize the target color as a placeholder\n\n    # Determine the target color based on whether t2 is even or odd\n    if t2 % 2 == 0:\n        b = \"W\"  # If t2 is even, the target color is white\n    else:\n        b = \"B\"  # If t2 is odd, the target color is black\n\n    # Iterate through the string s from left to right\n    for i in range(n - 1):\n        # Check if the current block's color doesn't match the target color\n        if (a[i] == b):\n            # If the current block's color doesn't match the target color, increment c and perform the flip operation\n            c += 1\n            # Flip the colors of the current block and the next block\n            if (a[i + 1] == 'W'):\n                a[i + 1] = 'B'\n            else:\n                a[i + 1] = 'W'\n            # Append the position of the block that was flipped to the list a1\n            a1.append(i + 1)\n\n    # Print the total number of operations and the positions of the blocks that were flipped\n    print(c)\n    print(*a1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n\n1. Read the number of blocks `n` and the initial color configuration `bs` from the input.\n2. Create a reversed color configuration `rs` by inverting the colors of each block in `bs`.\n3. Initialize variables to keep track of the number of changes `changes` and the indices of the blocks to be changed `cindex`.\n4. Initialize a flag `flag` to check if it's impossible to make all blocks have the same color.\n5. Perform a series of operations to make all blocks have the same color. The operations involve choosing two adjacent blocks and inverting their colors.\n6. If the last two blocks are white, invert the color of the last block and remove the last two blocks from the list.\n7. If the last two blocks are black, remove the last two blocks from the list.\n8. If the last two blocks are different colors, invert the color of the last block and the second last block.\n9. After the operations, check if the remaining blocks are all the same color. If not, set the flag `flag` to True.\n10. If the flag `flag` is True, print -1. Otherwise, print the number of changes and the indices of the blocks to be changed.\n\nCOMMENTED CODE:\n```python\ndef inv(c):\n    # Invert the color of a block\n    if(c==\"W\"):\n        return \"B\"\n    else:\n        return \"W\"\n\nn = int(input())\n# Read the initial color configuration\nbs = list(input())\n# Create a reversed color configuration\nrs = [inv(s) for s in bs]\nchanges = 0\ncindex = []\nflag = False\n\n# Perform operations to make all blocks have the same color\nwhile(len(bs)>2):\n    el = len(bs)\n    # If the last block is white, invert its color and the color of the second last block\n    if(bs[el-1]==\"W\"):\n        bs[el-1]=\"B\"\n        bs[el-2]=inv(bs[el-2])\n        changes += 1\n        cindex.append(el-1)\n    # If the last two blocks are black, remove them from the list\n    else:\n        if(bs[el-2]==\"B\"):\n            bs.pop()\n            bs.pop()\n        # If the last two blocks are different colors, invert the color of the second last block and the third last block\n        else:\n            bs[el-2]=\"B\"\n            bs[el-3]=inv(bs[el-3])\n            changes += 1\n            cindex.append(el-2)\n\n# Check if the remaining blocks are all the same color\nif(bs==['W', 'W']):\n    changes += 1\n    cindex.append(1)\nelif(bs==['B', 'W'] or bs==['W', 'B'] or bs==['W']):\n    flag = True\n\n# Print the result\nif(not flag):\n    print(changes)\n    if(changes!= 0):\n        print(\" \".join(str(i) for i in cindex))\n\nelse:\n    bs = rs\n    changes = 0\n    cindex = []\n    flag = False\n    # Perform operations to make all blocks have the same color\n    while(len(bs)>2):\n        el = len(bs)\n        # If the last block is white, invert its color and the color of the second last block\n        if(bs[el-1]==\"W\"):\n            bs[el-1]=\"B\"\n            bs[el-2]=inv(bs[el-2])\n            changes += 1\n            cindex.append(el-1)\n        # If the last two blocks are black, remove them from the list\n        else:\n            if(bs[el-2]==\"B\"):\n                bs.pop()\n                bs.pop()\n            # If the last two blocks are different colors, invert the color of the second last block and the third last block\n            else:\n                bs[el-2]=\"B\"\n                bs[el-3]=inv(bs[el-3])\n                changes += 1\n                cindex.append(el-2)\n\n    # Check if the remaining blocks are all the same color\n    if(bs==['W', 'W']):\n        changes += 1\n        cindex.append(1)\n    elif(bs==['B', 'W'] or bs==['W', 'B'] or bs==['W']):\n        flag = True\n\n    # Print the result\n    if(flag):\n        print(-1)\n    else:\n        print(changes)\n        if(changes!= 0):\n            print(\" \".join(str(i) for i in cindex))\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "There are n blocks arranged in a row and numbered from left to right, starting from one. Each block is either black or white. \n\nYou may perform the following operation zero or more times: choose two adjacent blocks and invert their colors (white block becomes black, and vice versa). \n\nYou want to find a sequence of operations, such that they make all the blocks having the same color. You don't have to minimize the number of operations, but it should not exceed 3 \u22c5 n. If it is impossible to find such a sequence of operations, you need to report it.\n\nInput\n\nThe first line contains one integer n (2 \u2264 n \u2264 200) \u2014 the number of blocks.\n\nThe second line contains one string s consisting of n characters, each character is either \"W\" or \"B\". If the i-th character is \"W\", then the i-th block is white. If the i-th character is \"B\", then the i-th block is black. \n\nOutput\n\nIf it is impossible to make all the blocks having the same color, print -1.\n\nOtherwise, print an integer k (0 \u2264 k \u2264 3 \u22c5 n) \u2014 the number of operations. Then print k integers p_1, p_2, ..., p_k (1 \u2264 p_j \u2264 n - 1), where p_j is the position of the left block in the pair of blocks that should be affected by the j-th operation.\n\nIf there are multiple answers, print any of them.\n\nExamples\n\nInput\n\n\n8\nBWWWWWWB\n\n\nOutput\n\n\n3\n6 2 4\n\n\nInput\n\n\n4\nBWBB\n\n\nOutput\n\n\n-1\n\n\nInput\n\n\n5\nWWWWW\n\n\nOutput\n\n\n0\n\n\nInput\n\n\n3\nBWB\n\n\nOutput\n\n\n2\n2 1 \n\nNote\n\nIn the first example, it is possible to make all blocks black in 3 operations. Start with changing blocks 6 and 7, so the sequence is \"BWWWWBBB\". Then change blocks 2 and 3, so the sequence is \"BBBWWBB\". And finally, change blocks 4 and 5, so all blocks are black.\n\nIt is impossible to make all colors equal in the second example.\n\nAll blocks are already white in the third example.\n\nIn the fourth example it is possible to make all blocks white in two operations: first operation is to change blocks 2 and 3 (so the sequence is \"BBW\"), and then change blocks 1 and 2 (so all blocks are white).",
        "output": "SOLUTION STEPS:\n1. Read the number of blocks `n` and the string `s` representing the colors of the blocks.\n2. Count the number of black blocks `cb` and white blocks `cw`.\n3. Check if all blocks are already of the same color. If so, print 0.\n4. If the number of white blocks is even, iterate through the string to find pairs of adjacent white blocks and invert their colors.\n5. If the number of black blocks is even, iterate through the string to find pairs of adjacent black blocks and invert their colors.\n6. If neither of the above conditions is met, it's impossible to make all blocks the same color, so print -1.\n\nCOMMENTED CODE:\n```python\n# Read the number of blocks and the string representing the colors\nb = int(input())\ns = input()\n\n# Count the number of black blocks and white blocks\ncb = s.count('B')  # count the number of 'B's in the string\ncw = s.count('W')  # count the number of 'W's in the string\n\n# Initialize variables to store the number of operations and the sequence of operations\no = ''  # initialize an empty string to store the sequence of operations\nco = 0  # initialize a counter for the number of operations\n\n# Check if all blocks are already of the same color\nif cb == 0 or cw == 0:\n    # If so, print 0\n    print(0)\nelif cw % 2 == 0:  # if the number of white blocks is even\n    # Iterate through the string to find pairs of adjacent white blocks and invert their colors\n    i = 0\n    while i!= b - 1:\n        if s[i] == 'W':\n            # Invert the colors of the current block and the next block\n            c = 'B'  # set the new color to black\n            if s[i + 1] == 'W':\n                ci = 'B'  # if the next block is white, set its new color to black\n            else:\n                ci = 'W'  # if the next block is black, set its new color to white\n            s = s[:i] + c + ci + s[i + 2:]  # update the string\n            co += 1  # increment the counter for the number of operations\n            o += str(i + 1)  # add the position of the current block to the sequence of operations\n            o +=''  # add a space to separate the positions\n        i += 1\n    # Print the number of operations and the sequence of operations\n    print(co)\n    print(o)\n\nelif cb % 2 == 0:  # if the number of black blocks is even\n    # Iterate through the string to find pairs of adjacent black blocks and invert their colors\n    i = 0\n    while i!= b - 1:\n        if s[i] == 'B':\n            # Invert the colors of the current block and the next block\n            c = 'W'  # set the new color to white\n            if s[i + 1] == 'B':\n                ci = 'W'  # if the next block is black, set its new color to white\n            else:\n                ci = 'B'  # if the next block is white, set its new color to black\n            s = s[:i] + c + ci + s[i + 2:]  # update the string\n            co += 1  # increment the counter for the number of operations\n            o += str(i + 1)  # add the position of the current block to the sequence of operations\n            o +=''  # add a space to separate the positions\n        i += 1\n    # Print the number of operations and the sequence of operations\n    print(co)\n    print(o)\n\nelse:  # if neither the number of white blocks nor the number of black blocks is even\n    # It's impossible to make all blocks the same color, so print -1\n    print(-1)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    }
]