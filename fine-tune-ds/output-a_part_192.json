[
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input values for the number of vertices (n) and the number of edges (m) in the graph.\n2. Initialize an array (lab) to store the representative of each connected component, and an array (cou) to store the size of each connected component. Both arrays are initialized with -1 and 1 respectively.\n3. If the number of edges (m) is not equal to n-1, it is impossible to form a Cthulhu graph, so print \"NO\" and return.\n4. Iterate through each edge in the graph, and for each edge, find the representative of the connected component that each vertex belongs to using the getroot function.\n5. If the two vertices belong to different connected components, merge the two components by calling the union function.\n6. After processing all edges, check if there is more than one connected component left. If so, the graph is not a Cthulhu graph, so print \"NO\" and return.\n7. If the graph passes all checks, it is a Cthulhu graph, so print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\nimport sys\n\n# Function to find the representative of a connected component\ndef getroot(lab, u):\n    # If the representative of the connected component is not found yet, return the vertex itself\n    if lab[u] == -1:\n        return u\n    # Otherwise, recursively find the representative and update the lab array\n    lab[u] = getroot(lab, lab[u])\n    return lab[u]\n\n# Function to merge two connected components\ndef union(lab, cou, a, b):\n    # If the size of the first component is greater than the second, merge the second into the first\n    if cou[a] > cou[b]:\n        cou[a] += cou[b]\n        lab[b] = a\n    # Otherwise, merge the first into the second\n    else:\n        cou[b] += cou[a]\n        lab[a] = b\n\n# Function to read input values\ndef inp():\n    return map(int, input().split())\n\n# Main function to solve the problem\ndef solve():\n    # Read the input values for the number of vertices (n) and the number of edges (m)\n    n, m = inp()\n    # Initialize the lab and cou arrays\n    lab = [-1 for i in range(n)]\n    cou = [1 for i in range(n)]\n\n    # If the number of edges (m) is not equal to n-1, it is impossible to form a Cthulhu graph\n    if n!= m:\n        print(\"NO\") #impossible\n        return \n\n    # Iterate through each edge in the graph\n    for i in range(m):\n        # Read the vertices of the current edge\n        u, v = inp()\n        # Find the representative of the connected component that each vertex belongs to\n        u = getroot(lab, u-1)\n        v = getroot(lab, v-1)\n        # If the two vertices belong to different connected components, merge the two components\n        if u!= v:\n            union(lab, cou, u, v)\n    # Check if there is more than one connected component left\n    if lab.count(-1) > 1: #not connected\n        print(\"NO\")\n        return \n    \n    # If the graph passes all checks, it is a Cthulhu graph\n    print(\"FHTAGN!\")\n\n# Call the main function to solve the problem\nsolve()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices `n` and the number of edges `m`.\n2. Create an adjacency list representation of the graph `g`, where `g[i]` contains the indices of vertices connected to vertex `i`.\n3. Iterate through the edges and add them to the adjacency list `g`.\n4. Initialize a boolean array `seen` to keep track of visited vertices during the depth-first search (DFS).\n5. Perform a DFS traversal starting from an arbitrary vertex (in this case, vertex 0).\n6. During the DFS, count the number of vertices in each connected component.\n7. Check if the graph can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n8. If the graph satisfies the conditions, print \"FHTAGN!\", otherwise print \"NO\".\n\nCOMMENTED CODE:\n```python\n# Read the input values for the number of vertices n and the number of edges m\nread_line = lambda: [int(i) for i in input().split(' ')]\nn, m = read_line()\n\n# Create an adjacency list representation of the graph g\ng = [[] for i in range(n)]\n\n# Iterate through the edges and add them to the adjacency list g\nfor i in range(m):\n    # Read the edge (a, b) and subtract 1 from each vertex index to match the 0-based indexing\n    a, b = [v - 1 for v in read_line()]\n    # Add the edge to the adjacency list g\n    g[a].append(b)\n    g[b].append(a)\n\n# Initialize a boolean array seen to keep track of visited vertices during the DFS\nseen = [False] * n\n\n# Define a recursive DFS function to count the number of vertices in each connected component\ndef dfs(v):\n    # If the vertex v has already been visited, return 0 to avoid counting it again\n    if seen[v]:\n        return 0\n    # Mark vertex v as visited and initialize the component count to 1\n    seen[v], cnt = True, 1\n    # Recursively traverse the neighbors of vertex v and count the vertices in the connected component\n    for u in g[v]:\n        cnt += dfs(u)\n    # Return the total count of vertices in the connected component\n    return cnt\n\n# Check if the graph can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle\n# If the graph satisfies the conditions, print \"FHTAGN!\", otherwise print \"NO\"\nprint(\"FHTAGN!\" if n == m == dfs(0) else \"NO\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices `n` and edges `m` from the input.\n2. Create an adjacency list representation of the graph `g`, where `g[i]` contains the indices of vertices connected to vertex `i`.\n3. Iterate through the edges and add them to the adjacency list `g`.\n4. Initialize an array `v` to keep track of the parent of each vertex during DFS, and two variables `c` to store the endpoints of the cycle.\n5. Perform a depth-first search (DFS) starting from vertex 0, and update the parent array `v` and the cycle variables `c` accordingly.\n6. Check if the DFS traversal visited all vertices (`r == n`) and if a cycle was found (`c[0]!= -1`).\n7. If either condition is not met, print \"NO\" and exit.\n8. If a cycle was found, find the length of the cycle by traversing from the first endpoint `c[0]` to the second endpoint `c[1]`.\n9. If the cycle length is at least 3, print \"FHTAGN!\"; otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\nn, m = map(int, input().split())  # Read the number of vertices and edges\ng = [[] for _ in range(n)]  # Create an adjacency list representation of the graph\nfor _ in range(m):\n    a, b = map(int, input().split())  # Read an edge and add it to the adjacency list\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n\nv = [-1] * n  # Initialize an array to keep track of the parent of each vertex\nc = [-1, -1]  # Initialize two variables to store the endpoints of the cycle\nr = 0  # Initialize a variable to count the number of visited vertices\n\ndef dfs(x, p):  # Define a recursive DFS function\n    v[x] = p  # Update the parent of vertex x\n    global r, c  # Access the global variables\n    r += 1  # Increment the count of visited vertices\n    for j in g[x]:  # Iterate through the neighbors of vertex x\n        if v[j] == -1:  # If the neighbor has not been visited\n            dfs(j, x)  # Recursively visit the neighbor\n        elif v[x]!= j:  # If the neighbor is part of a cycle\n            if c[0] == -1:  # If this is the first cycle found\n                c = (x, j)  # Store the endpoints of the cycle\n            elif c!= (j, x):  # If this is not the same cycle as the previous one\n                print('NO')  # The graph is not Cthulhu\n                exit()  # Exit the program\n\ndfs(0, 0)  # Perform DFS starting from vertex 0\nif r!= n or c[0] == -1:  # Check if all vertices were visited and a cycle was found\n    print('NO')  # The graph is not Cthulhu\n    exit()  # Exit the program\n\np = c[0]  # Start traversing the cycle from the first endpoint\nt = 1  # Initialize a variable to count the length of the cycle\nwhile p!= c[1]:  # Traverse the cycle\n    t += 1  # Increment the cycle length\n    p = v[p]  # Move to the next vertex in the cycle\n\nif t >= 3:  # Check if the cycle length is at least 3\n    print('FHTAGN!')  # The graph is Cthulhu\nelse:\n    print('NO')  # The graph is not Cthulhu\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The first line contains two integers, n and m, representing the number of vertices and edges in the graph, respectively. Each of the following m lines contains a pair of integers, x and y, indicating an edge between vertices x and y.\n\n2. Create an adjacency list: Initialize an empty list, lst, of size n+1 to represent the adjacency list of the graph. For each edge in the input, add the corresponding vertices to each other's adjacency lists.\n\n3. Perform DFS: Define a recursive function, func, to perform a depth-first search (DFS) on the graph. Initialize two arrays, a and b, of size n+1 to keep track of the DFS traversal. The array a is used to mark visited vertices, and the array b is used to store the parent of each vertex.\n\n4. Identify cycles: During the DFS traversal, check if a vertex has already been visited and its parent is not the current vertex. If so, increment the counter c to indicate the presence of a cycle.\n\n5. Check for Cthulhu condition: After the DFS traversal, check if the counter c is equal to the number of roots minus one. Also, check if any vertex has not been visited (i.e., its value in array a is 0). If either condition is not met, print \"NO\". Otherwise, print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\n#Cthulhu\nn, m = map(int, input().split())  # Read the number of vertices and edges\nlst = [[] for i in range(n + 1)]  # Initialize an empty adjacency list\n\n# Create the adjacency list\nfor i in range(m):\n    x, y = map(int, input().split())  # Read an edge\n    lst[x].append(y)  # Add y to x's adjacency list\n    lst[y].append(x)  # Add x to y's adjacency list\n\n# Perform DFS to identify cycles and roots\na = [0] * (n + 1)  # Initialize array a to mark visited vertices\nb = [0] * (n + 1)  # Initialize array b to store parent of each vertex\nc = 0  # Initialize counter for cycles\n\ndef func(n):\n    global a, b, c, lst  # Access global variables\n    a[n] = 1  # Mark vertex n as visited\n    for j in lst[n]:  # Iterate over neighbors of vertex n\n        if a[j] == 1 and b[n]!= j:  # Check if j is already visited and not parent of n\n            c += 1  # Increment cycle counter\n        if not a[j]:  # If j is not visited\n            b[j] = n  # Set parent of j as n\n            func(j)  # Recursively visit j\n    a[n] = 2  # Mark vertex n as fully visited\n\nfunc(1)  # Start DFS from vertex 1\n\n# Check for Cthulhu condition\nif c - 1 or 0 in a[1:]:  # Check if cycle counter is not equal to number of roots minus one or if any vertex is not visited\n    print(\"NO\")  # Print \"NO\" if condition is not met\nelse:\n    print(\"FHTAGN!\")  # Print \"FHTAGN!\" if condition is met\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices `n` and the number of edges `m` from the first line.\n2. Initialize an adjacency list `adj` to represent the graph, where each index `i` corresponds to a vertex and its value is a list of its adjacent vertices.\n3. Initialize a visited array `vis` to keep track of visited vertices during the depth-first search (DFS).\n4. Read the edges of the graph from the subsequent lines and update the adjacency list accordingly.\n5. Perform a DFS traversal starting from an arbitrary vertex (in this case, vertex 1) to count the number of vertices in each connected component.\n6. Check if the graph is connected (i.e., `n == m`) and if the number of vertices in the DFS traversal equals the total number of vertices (`dfs(1) == n`).\n7. If the graph is not connected or the DFS traversal does not cover all vertices, print \"NO\".\n8. Otherwise, print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\n#!/usr/bin/env python3\n\n# Read the input values for the number of vertices n and the number of edges m\nn, m = map(int, input().rstrip().split())\n\n# Initialize an adjacency list to represent the graph\nadj = [[] for i in range(n+1)]\n\n# Initialize a visited array to keep track of visited vertices during DFS\nvis = [False for i in range(n+1)]\n\n# Read the edges of the graph and update the adjacency list\nfor i in range(m):\n    u, v = map(int, input().rstrip().split())\n    # Add an edge between vertices u and v in both directions\n    adj[u].append(v)\n    adj[v].append(u)\n\n# Define a recursive DFS function to count the number of vertices in each connected component\ndef dfs(cur):\n    # Initialize a counter for the number of vertices in the current connected component\n    cnt = 1\n    # Mark the current vertex as visited\n    vis[cur] = True\n    # Recursively visit all unvisited adjacent vertices\n    for nxt in adj[cur]:\n        if not vis[nxt]:\n            # Increment the counter by the number of vertices in the next connected component\n            cnt += dfs(nxt)\n\n    return cnt\n\n# Check if the graph is connected and if the DFS traversal covers all vertices\nif n!= m or dfs(1)!= n:\n    # If the graph is not connected or the DFS traversal does not cover all vertices, print \"NO\"\n    print(\"NO\")\nelse:\n    # Otherwise, print \"FHTAGN!\"\n    print(\"FHTAGN!\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Initialize a disjoint set data structure to keep track of connected components in the graph.\n3. Iterate through each edge in the graph and perform a union operation on the two vertices it connects.\n4. Count the number of vertices in each connected component by iterating through each vertex and finding its root using the disjoint set data structure.\n5. Check if the graph can be regarded as Cthulhu by verifying two conditions:\n   - The number of connected components is less than or equal to 1 (i.e., the graph is connected).\n   - The number of vertices in each connected component is less than n (i.e., the graph is not a single tree).\n6. If the graph satisfies both conditions, it can be regarded as Cthulhu. Otherwise, it cannot.\n\nCOMMENTED CODE:\n```python\n# Define a constant for the maximum number of vertices\nMAX = 101\n\n# Initialize a list to store the parent of each vertex in the disjoint set data structure\nparent = []\n\n# Function to create a disjoint set data structure\ndef makeSet():\n    global parent\n    # Initialize the parent of each vertex to itself\n    parent = [i for i in range(MAX + 1)]\n\n# Function to find the root of a vertex in the disjoint set data structure\ndef findSet(u):\n    # Traverse up the parent chain until the root is found\n    while u!= parent[u]:\n        u = parent[u]\n    return u\n\n# Function to merge two sets in the disjoint set data structure\ndef unionSet(u, v):\n    # Find the roots of the two vertices\n    up = findSet(u)\n    vp = findSet(v)\n    # Merge the two sets by making the root of one set the parent of the other\n    parent[up] = vp\n\n# Create a disjoint set data structure\nmakeSet()\n\n# Read the number of vertices (n) and edges (m) from the input\nn, m = map(int, input().split())\n\n# Iterate through each edge in the graph and perform a union operation\nfor i in range(m):\n    # Read the two vertices connected by the current edge\n    a, b = map(int, input().split())\n    # Perform a union operation on the two vertices\n    unionSet(a, b)\n\n# Initialize a list to store the number of vertices in each connected component\np = [0] * MAX\n\n# Count the number of vertices in each connected component\nfor i in range(1, n + 1):\n    # Find the root of the current vertex\n    root = findSet(i)\n    # Increment the count of vertices in the current connected component\n    p[root] += 1\n\n# Check if the graph can be regarded as Cthulhu\nisCthulhu = True\n# Iterate through each connected component\nfor i in range(1, n + 1):\n    # Check if the number of vertices in the current connected component is less than n\n    if p[findSet(i)] < n:\n        # If so, the graph cannot be regarded as Cthulhu\n        isCthulhu = False\n\n# Check if the graph is connected\nif n == m and isCthulhu:\n    # If the graph is connected and has the correct number of vertices in each connected component, it can be regarded as Cthulhu\n    print(\"FHTAGN!\")\nelse:\n    # Otherwise, it cannot be regarded as Cthulhu\n    print(\"NO\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices `n` and the number of edges `m` from the first line.\n2. Create an empty graph `g` with `n` vertices.\n3. Iterate through each edge in the graph, adding it to the adjacency list of the corresponding vertices in `g`.\n4. Check if the graph is connected by comparing `n` and `m`. If `n!= m`, the graph is not connected, and we set `flag1` to `False`.\n5. Perform a depth-first search (DFS) on the graph starting from vertex 0 to mark all visited vertices in the `used` array. This will help us identify connected components in the graph.\n6. After the DFS, check if all vertices are marked in the `used` array. If any vertex remains unvisited, it means the graph is not connected, and we set `flag2` to `False`.\n7. If both `flag1` and `flag2` are `True`, the graph is connected and contains no isolated vertices, which is a necessary condition for the graph to be Cthulhu.\n8. If the graph is connected and contains no isolated vertices, we need to check if it can be represented as a set of three or more rooted trees with a simple cycle connecting their roots.\n9. To do this, we can use a technique called \"tarjan's algorithm\" or \"strongly connected components\" (SCCs) to find all SCCs in the graph.\n10. If the graph can be represented as a set of three or more SCCs, each of which is a rooted tree, and there is a simple cycle connecting their roots, then the graph is Cthulhu, and we print \"FHTAGN!\". Otherwise, we print \"NO\".\n\nCOMMENTED CODE:\n```python\nclass Graph:\n    def __init__(self, n):\n        # Initialize the graph with n vertices\n        self.n = n\n        # Create an adjacency list for each vertex\n        self.adj = [[] for i in range(n)]\n\n    def add(self, v, u):\n        # Add an edge between vertices v and u\n        self.adj[v].append(u)\n        self.adj[u].append(v)\n\nn, m = map(int, input().split())\n# Create an empty graph with n vertices\ng = Graph(n)\n# Iterate through each edge and add it to the graph\nfor i in range(m):\n    v, u = map(int, input().split())\n    # Subtract 1 from v and u because vertex indices start from 1 in the input\n    g.add(v - 1, u - 1)\n\nflag1 = True\nflag2 = True\n\n# Check if the graph is connected\nif n!= m:\n    # If n!= m, the graph is not connected, so set flag1 to False\n    flag1 = False\n\n# Create a used array to mark visited vertices\nused = [False for i in range(n)]\n\ndef dfs(v):\n    # Perform a depth-first search starting from vertex v\n    used[v] = True\n    # Recursively visit all unvisited neighbors of v\n    for u in g.adj[v]:\n        if used[u]:\n            # If u is already visited, skip it\n            continue\n        dfs(u)\n\n# Perform DFS starting from vertex 0\ndfs(0)\n# Check if all vertices are visited\nfor v in range(n):\n    if not used[v]:\n        # If any vertex remains unvisited, set flag2 to False\n        flag2 = False\n\nif flag1 and flag2:\n    # If the graph is connected and contains no isolated vertices\n    print(\"FHTAGN!\")\nelse:\n    # Otherwise, print \"NO\"\n    print(\"NO\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the number of vertices (n) and edges (m) from the input.\n2. If the number of edges is not equal to n-1, it means the graph is not a tree, so it cannot be Cthulhu. Print \"NO\" and move to the next test case.\n3. Create an adjacency list representation of the graph using the given edges.\n4. Iterate over each pair of vertices in the graph.\n5. For each pair, perform a depth-first search (DFS) to check if the graph contains a simple cycle that includes both vertices.\n6. If a simple cycle is found, mark the graph as Cthulhu and break the loop.\n7. If no simple cycle is found after checking all pairs, the graph is not Cthulhu. Print \"NO\".\n8. If the graph is marked as Cthulhu, perform another DFS to find all connected components in the graph.\n9. If a connected component has more than one vertex, it must be a tree. If all connected components are trees, the graph is Cthulhu. Print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\nfrom sys import stdin, stdout, setrecursionlimit\nsetrecursionlimit(10**4)\nfrom collections import defaultdict\n\n# Function to read a number from the input\nnmbr = lambda: int(stdin.readline())\n\n# Function to read a list of numbers from the input\nlst = lambda: list(map(int, stdin.readline().split()))\n\n# Function to perform DFS\ndef dfs(src, par):\n    global remu, remv\n    # Mark the current vertex as visited\n    vis[src] = 1\n    \n    # Iterate over all neighbors of the current vertex\n    for neigh in g[src]:\n        # Skip if the neighbor is already visited or is the parent vertex\n        if vis[neigh] or neigh == par:\n            continue\n        \n        # Check if the neighbor is part of a simple cycle with the root vertex\n        if (src == remu and neigh == remv) or (neigh == remu and src == remv):\n            continue\n        \n        # Recursively perform DFS on the neighbor\n        dfs(neigh, src)\n\n# Main program\nfor _ in range(1):  # nmbr()):\n    # Read the number of vertices and edges\n    n, eg = lst()\n    f1 = 0\n    \n    # If the number of edges is not equal to n-1, the graph is not a tree\n    if eg!= n - 1:\n        print('NO')\n        continue\n    \n    # Create an adjacency list representation of the graph\n    g = defaultdict(set)\n    l = []\n    \n    # Read all edges and add them to the adjacency list\n    for i in range(eg):\n        u, v = lst()\n        g[u].add(v)\n        g[v].add(u)\n        l += [[u, v]]\n    \n    # Iterate over all pairs of vertices\n    for ru, rv in l:\n        # Reset the visited array\n        vis = [0] * (1 + n)\n        \n        # Set the root and vertex for the simple cycle check\n        remu, remv = ru, rv\n        \n        # Perform DFS to check for a simple cycle\n        dfs(1, -1)\n        \n        # Check if a simple cycle is found\n        for v in vis[1:]:\n            if v == 0:\n                break\n        \n        # If a simple cycle is found, mark the graph as Cthulhu\n        if f1:\n            f1 = 1\n            break\n    \n    # Print the result\n    print('FHTAGN!' if f1 else 'NO')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the first line.\n2. If n is not equal to m + 1 (since an undirected graph with n vertices has n-1 edges), print \"NO\" and exit the program.\n3. Initialize an adjacency list (adjlist) to represent the graph, where each index represents a vertex and its corresponding value is a list of adjacent vertices.\n4. Initialize a visited array (visited) to keep track of visited vertices during the depth-first search (DFS).\n5. Read m lines of input, where each line contains a pair of integers (x, y) representing an edge between vertices x and y. Update the adjacency list accordingly.\n6. Perform a DFS traversal starting from vertex 0 to find all connected components in the graph.\n7. If vertex 0 is not visited after the DFS traversal, it means the graph is a single connected component, and print \"FHTAGN!\".\n8. Otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\n#!/usr/bin/python3\n# B - Cthulhu\nimport sys\n\n# Function to perform DFS traversal starting from a given vertex\ndef dfs(curvertex):\n    # Mark the current vertex as visited\n    visited[curvertex] = 1\n    \n    # Recursively visit all unvisited adjacent vertices\n    for v in adjlist[curvertex]:\n        if visited[v] == 0:\n            dfs(v)\n\n# Read input values for the number of vertices (n) and the number of edges (m)\nn, m = [int(x) for x in input().split()]\n# If n is not equal to m + 1, print \"NO\" and exit\nif n!= m + 1:\n    print(\"NO\")\n    sys.exit()\n\n# Initialize an adjacency list to represent the graph\nadjlist = [[] for x in range(n)]\n# Initialize a visited array to keep track of visited vertices\nvisited = [0]*n\n\n# Read m lines of input, where each line contains a pair of integers (x, y) representing an edge\nfor i in range(m):\n    x, y = [int(x) for x in input().split()]\n    # Update the adjacency list accordingly\n    x -= 1  # Adjust vertex indices to match the adjacency list\n    y -= 1\n    adjlist[x].append(y)\n    adjlist[y].append(x)\n\n# Perform a DFS traversal starting from vertex 0 to find all connected components\ndfs(0)\n# If vertex 0 is not visited after the DFS traversal, it means the graph is a single connected component\nif 0 not in visited:\n    print(\"FHTAGN!\")\nelse:\n    print(\"NO\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Check if the number of edges is equal to n-1. If not, the graph is not a tree and cannot be Cthulhu, so print \"NO\".\n3. Create an adjacency list representation of the graph (g), where g[i] contains the vertices connected to vertex i.\n4. Perform a depth-first search (DFS) from an arbitrary vertex (0) to mark all vertices as visited.\n5. Check if all vertices are marked. If not, the graph contains a disconnected component and is not Cthulhu, so print \"NO\".\n6. If all vertices are marked, the graph is a connected graph. Now, we need to find a cycle in the graph.\n7. Perform a DFS from an arbitrary vertex (0) and keep track of the parent of each vertex.\n8. If we encounter a vertex that has already been visited and is not the parent of the current vertex, we have found a cycle.\n9. If we find a cycle, check if it has at least three vertices. If not, the graph is not Cthulhu, so print \"NO\".\n10. If we find a cycle with at least three vertices, check if the remaining vertices form one or more trees. If they do, the graph is Cthulhu, so print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\ndef dfs(v):\n    # Perform DFS from vertex v and mark all visited vertices\n    global g, marked\n    marked[v] = True\n    for nv in g[v]:\n        if not marked[nv]:\n            dfs(nv)\n\nn, m = map(int, input().split())\n# Check if the number of edges is equal to n-1\nif (n!= m):\n    print(\"NO\")\nelse:\n    g = [[] for _ in range(n)]\n    for i in range(m):\n        a, b = map(int, input().split())\n        # Create an adjacency list representation of the graph\n        g[a-1].append(b-1)\n        g[b-1].append(a-1)\n    marked = [False for _ in range(n)]\n    dfs(0)\n    # Check if all vertices are marked\n    if False in marked:\n        print(\"NO\")\n    else:\n        # Find a cycle in the graph\n        parent = [-1] * n\n        stack = [0]\n        while stack:\n            v = stack.pop()\n            for nv in g[v]:\n                if nv!= parent[v]:\n                    parent[nv] = v\n                    stack.append(nv)\n                else:\n                    # Found a cycle, check if it has at least three vertices\n                    cycle = [nv]\n                    while nv!= v:\n                        nv = parent[nv]\n                        cycle.append(nv)\n                    if len(cycle) >= 3:\n                        # Check if the remaining vertices form one or more trees\n                        remaining = [i for i in range(n) if i not in cycle]\n                        for v in remaining:\n                            if len(g[v])!= len(remaining) - 1:\n                                break\n                        else:\n                            # The graph is Cthulhu, so print \"FHTAGN!\"\n                            print(\"FHTAGN!\")\n                            break\n                    else:\n                        # The graph is not Cthulhu, so print \"NO\"\n                        print(\"NO\")\n                        break\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Initialize a list (p) to store the parent of each vertex, where initially each vertex is its own parent (p[i] = i).\n3. Iterate through each edge in the graph, and for each edge (a, b), check if the roots of the trees containing a and b are the same. If they are, increment a counter (cnt) to keep track of the number of cycles found.\n4. Perform a union operation on the trees containing a and b by updating the parent of a to be the same as the parent of b.\n5. After processing all edges, iterate through the list of parents (p) and count the number of vertices that are their own parents (i.e., the roots of the trees). Store this count in cnt2.\n6. Check if the graph can be regarded as Cthulhu by verifying two conditions:\n   - If there is exactly one cycle (cnt == 1) and there is only one root (cnt2 == 1), then the graph can be regarded as Cthulhu.\n   - Otherwise, the graph cannot be regarded as Cthulhu.\n\nCOMMENTED CODE:\n```python\ndef find(node):  # Function to find the root of the tree containing a given node\n    while p[node]!= node:  # Traverse up the tree until we reach the root\n        p[node] = p[p[node]]  # Path compression: update the parent of the current node to be the parent of its parent\n        node = p[node]  # Move to the parent node\n    return node  # Return the root of the tree\n\ndef union(n1, n2):  # Function to merge two trees\n    a1 = find(n1)  # Find the roots of the trees containing n1 and n2\n    a2 = find(n2)\n\n    if a1!= a2:  # If the roots are different, merge the trees by updating the parent of one root to be the other\n        p[a1] = a2\n\n# Read the number of vertices (n) and edges (m) from the input\nn, m = map(int, input().split())\n\n# Initialize a list (p) to store the parent of each vertex\np = [i for i in range(n + 1)]\n\n# Initialize a counter to keep track of the number of cycles found\ncnt = 0\n\n# Iterate through each edge in the graph\nfor _ in range(m):\n    a, b = map(int, input().split())  # Read the vertices connected by the current edge\n    if find(a) == find(b):  # Check if the roots of the trees containing a and b are the same\n        cnt += 1  # If they are, increment the counter\n    union(a, b)  # Merge the trees containing a and b\n\n# Initialize a counter to count the number of vertices that are their own parents (i.e., the roots of the trees)\ncnt2 = 0\n\n# Iterate through the list of parents (p) and count the number of vertices that are their own parents\nfor i in range(1, n + 1):\n    if p[i] == i:  # If a vertex is its own parent, increment the counter\n        cnt2 += 1\n\n# Check if the graph can be regarded as Cthulhu\nif cnt == 1 and cnt2 == 1:  # If there is exactly one cycle and there is only one root\n    print('FHTAGN!')  # The graph can be regarded as Cthulhu\nelse:\n    print(\"NO\")  # Otherwise, the graph cannot be regarded as Cthulhu\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and the number of edges (m) from the input.\n2. Check if the number of edges is equal to n - 1. If not, the graph is not a tree and cannot be Cthulhu, so print \"NO\" and exit.\n3. Initialize the parent and rank dictionaries using the make_set function.\n4. Iterate through each edge in the graph, and for each edge, call the union_set function to merge the sets containing the two vertices.\n5. Find the top parent of the set containing vertex 1 using the find_set function.\n6. Iterate through the remaining vertices (from 2 to n), and for each vertex, check if its set is the same as the top parent's set. If not, the graph is not Cthulhu, so print \"NO\" and exit.\n7. If all checks pass, the graph is Cthulhu, so print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\n# Initialize parent and rank dictionaries\nparent = dict()  # stores the parent of each vertex\nranks = dict()  # stores the rank of each vertex\n\n# Function to make a set for each vertex\ndef make_set(N):\n    global parent, ranks  # use global variables\n    # Initialize parent and rank lists with values from 0 to N+5\n    parent = [i for i in range(N + 5)]\n    ranks = [0 for i in range(N + 5)]\n\n# Function to find the representative of a set\ndef find_set(u):\n    # If the parent of u is not itself, recursively find the representative\n    if parent[u]!= u:\n        parent[u] = find_set(parent[u])  # path compression\n    return parent[u]\n\n# Function to merge two sets\ndef union_set(u, v):\n    # Find the representatives of the sets containing u and v\n    up = find_set(u)\n    vp = find_set(v)\n\n    # If the sets are the same, do nothing\n    if up == vp:\n        return\n    # Merge the sets based on rank\n    if ranks[up] > ranks[vp]:\n        parent[vp] = up\n    elif ranks[up] < ranks[vp]:\n        parent[up] = vp\n    else:\n        parent[up] = vp\n        ranks[vp] += 1  # increment rank of vp\n\n# Read the number of vertices and edges from input\nm, n = map(int, input().split())\n\n# Check if the number of edges is equal to n - 1\nif m!= n:\n    print('NO')  # graph is not a tree\n    exit()\n\n# Initialize parent and rank dictionaries\nmake_set(m)\n\n# Iterate through each edge and merge the sets\nfor i in range(m):\n    a, b = map(int, input().split())\n    union_set(a, b)\n\n# Find the top parent of the set containing vertex 1\ntop_parent = find_set(1)\n\n# Check if all vertices are in the same set as the top parent\nfor i in range(2, m):\n    if find_set(i)!= top_parent:\n        print('NO')  # graph is not Cthulhu\n        exit()\n\n# If all checks pass, the graph is Cthulhu\nprint('FHTAGN!')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The first line contains the number of vertices `n` and the number of edges `m`. Each of the following `m` lines contains a pair of integers `x` and `y`, representing an edge between vertices `x` and `y`.\n2. Create an adjacency list representation of the graph: Initialize an empty list `t` of size `n + 1`, where `t[i]` will store the vertices connected to vertex `i`. Iterate through the edges and add the corresponding vertices to the adjacency list.\n3. Perform a depth-first search (DFS) to find all connected components: Initialize a visited array `q` of size `n + 1` and a parent array `p` of size `n + 1`. Set `q[a] = 1` for the starting vertex `a` and recursively visit all unvisited neighbors. Update the parent array `p` to keep track of the parent of each vertex.\n4. Count the number of cycles: Iterate through the visited array `q` and count the number of vertices that are part of a cycle (i.e., `q[b] == 1` and `p[a]!= b`).\n5. Check if the graph is a Cthulhu: If the number of cycles is not equal to 1 or if there are any unvisited vertices, print \"NO\". Otherwise, print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\nn, m = map(int, input().split())  # Read the number of vertices and edges\nt = [[] for i in range(n + 1)]  # Initialize an empty adjacency list\nfor i in range(m):\n    a, b = map(int, input().split())  # Read an edge between vertices a and b\n    t[a].append(b)  # Add vertex b to the adjacency list of vertex a\n    t[b].append(a)  # Add vertex a to the adjacency list of vertex b\n\nq, p, s = [0] * (n + 1), [0] * (n + 1), 0  # Initialize visited array, parent array, and cycle count\ndef dfs(a):  # Define a recursive DFS function\n    global q, p, s, t  # Access global variables\n    q[a] = 1  # Mark vertex a as visited\n    for b in t[a]:  # Iterate through the neighbors of vertex a\n        if q[b] == 1 and p[a]!= b:  # If vertex b is visited and not a child of vertex a\n            s += 1  # Increment the cycle count\n        if not q[b]:  # If vertex b is not visited\n            p[b] = a  # Set the parent of vertex b to vertex a\n            dfs(b)  # Recursively visit vertex b\n    q[a] = 2  # Mark vertex a as fully visited\n\ndfs(1)  # Start the DFS from vertex 1\nprint('NO' if s - 1 or 0 in q[1: ] else 'FHTAGN!')  # Check if the graph is a Cthulhu\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Initialize an empty list to store the vertices and an empty list to store the edges.\n3. Read the edges from the user and store them in the edges list.\n4. Iterate through the edges and add each vertex to the vertices list if it's not already present.\n5. Check if the number of edges (m) is equal to the number of vertices (n) - 1. If not, print \"NO\" and exit.\n6. Iterate through each vertex in the vertices list and perform a Breadth-First Search (BFS) to find a rooted tree.\n7. For each rooted tree, check if all vertices are visited. If not, print \"NO\" and exit.\n8. If all rooted trees have all vertices visited, print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\n# Read the input values for the number of vertices (n) and the number of edges (m) from the user\nnm_ = input()\nnm = [int(k) for k in nm_.split(\" \")]\nn = nm[0]\nm = nm[1]\n\n# Initialize an empty list to store the vertices and an empty list to store the edges\nvertices = []\naristas = []\n\n# Read the edges from the user and store them in the edges list\nfor i in range(m):\n    e_ = input()\n    e = [int(k) for k in e_.split(\" \")]\n    aristas = aristas + [e]\n\n# Iterate through the edges and add each vertex to the vertices list if it's not already present\nfor e in aristas:\n    for i in e:\n        if i not in vertices:\n            vertices = vertices + [i]\n\n# Check if the number of edges (m) is equal to the number of vertices (n) - 1\nif m!= n - 1:\n    print(\"NO\")\nelse:\n    # Iterate through each vertex in the vertices list and perform a Breadth-First Search (BFS) to find a rooted tree\n    i = 0\n    while i <= n:\n        if i == n:\n            # If all vertices have been checked, print \"FHTAGN!\"\n            print(\"FHTAGN!\")\n            i = i + 1\n        elif len(set(BFS(vertices, aristas, vertices[i])[0]) & set(vertices))!= n:\n            # If a rooted tree does not have all vertices visited, print \"NO\"\n            print(\"NO\")\n            i = n + 1\n        else:\n            i = i + 1\n\n# Define the BFS function to find a rooted tree\ndef BFS(vertices, aristas, s):\n    # Initialize lists to store visited nodes and solution edges\n    U = [s]\n    F = []\n    Aux = []\n\n    # Add edges incident to s to Aux\n    for e in aristas:\n        if e[0] == s:\n            Aux = Aux + [e]\n        elif e[1] == s:\n            Aux = Aux + [e]\n\n    # Perform BFS\n    while Aux!= []:\n        u = Aux.pop(0)\n        w = -1  # Initialize w\n\n        # Find the unvisited node (w) incident to u\n        if u[0] not in U:\n            w = u[0]\n        if u[1] not in U:\n            w = u[1]\n\n        if w!= -1:  # u has an unvisited node\n            U = U + [w]\n            F = F + [u]\n\n            # Add edges incident to w to Aux\n            for e in aristas:\n                if e[0] == w:\n                    Aux = Aux + [e]\n                elif e[1] == w:\n                    Aux = Aux + [e]\n\n    return (U, F)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (N) and the number of edges (M) from the user.\n2. Create an adjacency list representation of the graph, where each index in the list corresponds to a vertex, and the values at each index are the vertices directly connected to it.\n3. Iterate through the edges and add them to the adjacency list.\n4. Initialize a visited array to keep track of visited vertices during the depth-first search (DFS).\n5. Perform a DFS traversal starting from vertex 0 to find all connected components in the graph.\n6. Check if the graph has any isolated vertices (i.e., vertices not reachable from vertex 0). If so, print \"NO\" and exit.\n7. If the number of edges is not equal to N - 1, print \"NO\" and exit, as this indicates the graph is not a tree.\n8. If the DFS traversal did not visit vertex 0, print \"NO\" and exit, as this indicates the graph is not connected.\n9. If all checks pass, print \"FHTAGN!\" to indicate that the graph is a Cthulhu.\n\nCOMMENTED CODE:\n```python\n# Read the input values for the number of vertices (N) and the number of edges (M) from the user.\nN, M = map(int, input().split())\n\n# Create an adjacency list representation of the graph.\ng = [[] for i in range(N)]\n\n# Iterate through the edges and add them to the adjacency list.\nfor i in range(M):\n    # Read the edge information from the user.\n    a, b = map(int, input().split())\n    # Add the edge to the adjacency list.\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n\n# Initialize a visited array to keep track of visited vertices during the DFS.\nvisited = [0] * N\n\n# Define a recursive DFS function to traverse the graph.\ndef dfs(n):\n    # Mark the current vertex as visited.\n    global visn\n    visited[n] = 1\n    # Recursively visit all unvisited neighbors of the current vertex.\n    for i in g[n]:\n        if not visited[i]:\n            dfs(i)\n\n# Check if the graph has any isolated vertices (i.e., vertices not reachable from vertex 0).\nif N!= M:\n    # If the number of edges is not equal to N - 1, print \"NO\" and exit.\n    print(\"NO\")\n    exit()\n\n# Perform a DFS traversal starting from vertex 0 to find all connected components in the graph.\ndfs(0)\n\n# Check if the DFS traversal did not visit vertex 0.\nif 0 in visited:\n    # If the DFS traversal did not visit vertex 0, print \"NO\" and exit.\n    print(\"NO\")\nelse:\n    # If all checks pass, print \"FHTAGN!\" to indicate that the graph is a Cthulhu.\n    print(\"FHTAGN!\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the first line.\n2. If the number of vertices is less than 3 or the number of edges is not equal to n - 1, the graph cannot be Cthulhu, so print \"NO\" and exit.\n3. Initialize an empty set to keep track of visited vertices and an adjacency list (e) to represent the graph.\n4. Read the edges of the graph from the subsequent lines and add them to the adjacency list.\n5. Perform a depth-first search (DFS) starting from an arbitrary vertex (1) to find all connected components in the graph.\n6. If the number of visited vertices is equal to the total number of vertices, the graph is connected, so check if it can be represented as a set of rooted trees with a simple cycle.\n7. If the graph can be represented as a set of rooted trees with a simple cycle, print \"FHTAGN!\", otherwise print \"NO\".\n\nCOMMENTED CODE:\n```python\n# Read the input values for the number of vertices (n) and the number of edges (m)\ninp = input().split()\nn = int(inp[0])\nm = int(inp[1])\n\n# Define a function to perform DFS\ndef dfs(x):\n    # Mark the current vertex as visited\n    visited.add(x)\n    \n    # Recursively visit all unvisited neighbors of the current vertex\n    for y in e[x]:\n        if not y in visited:\n            dfs(y)\n\n# Check if the graph can be Cthulhu\nif n >= 3 and n == m + 1:  # n - 1 edges for a tree, so add 1 for the cycle\n    # Initialize an empty set to keep track of visited vertices\n    visited = set()\n    \n    # Initialize an adjacency list to represent the graph\n    e = [[] for i in range(n + 1)]\n    \n    # Read the edges of the graph and add them to the adjacency list\n    for i in range(m):\n        x, y = map(int, input().split())\n        e[x].append(y)\n        e[y].append(x)\n\n    # Perform DFS to find all connected components in the graph\n    dfs(1)\n    \n    # Check if the graph is connected\n    if len(visited) == n:\n        # Check if the graph can be represented as a set of rooted trees with a simple cycle\n        # This is a complex step and requires further analysis of the graph structure\n        # For simplicity, we assume that if the graph is connected and has n - 1 edges, it can be represented as a set of rooted trees with a simple cycle\n        print('FHTAGN!')\n    else:\n        print('NO')\nelse:\n    print('NO')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Check if the number of edges is equal to n - 1. If not, the graph is not a tree and cannot be Cthulhu, so print \"NO\".\n3. Initialize a parent array to keep track of the parent of each vertex in the disjoint-set data structure.\n4. Iterate through each edge in the graph and perform a union operation on the two vertices connected by the edge.\n5. After all edges have been processed, iterate through the parent array to count the number of vertices that are their own parents (i.e., the number of connected components).\n6. If there is only one connected component, it means the graph is a single tree, and we need to check if it contains a cycle. If it does, the graph is Cthulhu, so print \"FHTAGN!\". Otherwise, print \"NO\".\n7. If there are multiple connected components, the graph is not Cthulhu, so print \"NO\".\n\nCOMMENTED CODE:\n```python\ndef findSet(u):  # Find the root of the set that u belongs to\n    while u!= parent[u]:  # If u is not the root, keep moving up the tree\n        u = parent[u]\n    return u  # Return the root of the set\n\ndef unionSet(u, v):  # Merge the sets that u and v belong to\n    up = findSet(u)  # Find the roots of the sets that u and v belong to\n    vp = findSet(v)\n    parent[up] = vp  # Make the root of the set that u belongs to a child of the root of the set that v belongs to\n\nif __name__ == '__main__':\n    n, m = map(int, input().split())  # Read the number of vertices and edges from the user\n    if n!= m:  # Check if the number of edges is equal to n - 1\n        print('NO')  # If not, the graph is not a tree and cannot be Cthulhu\n    else:\n        parent = [i for i in range(n + 1)]  # Initialize the parent array\n        for i in range(m):  # Iterate through each edge in the graph\n            u, v = map(int, input().split())  # Read the vertices connected by the edge\n            unionSet(u, v)  # Perform a union operation on the two vertices\n        cnt = 0  # Count the number of vertices that are their own parents\n        for i in range(1, n + 1):\n            if parent[i] == i:  # If a vertex is its own parent, increment the count\n                cnt += 1\n        if cnt == 1:  # If there is only one connected component\n            cycle_found = False  # Assume no cycle is found\n            visited = [False] * (n + 1)  # Initialize a visited array\n            for i in range(1, n + 1):  # Iterate through each vertex in the component\n                if not visited[i]:  # If the vertex has not been visited\n                    stack = [i]  # Initialize a stack with the vertex\n                    visited[i] = True  # Mark the vertex as visited\n                    while stack:  # While the stack is not empty\n                        u = stack.pop()  # Pop a vertex from the stack\n                        for j in range(1, n + 1):  # Iterate through each vertex\n                            if parent[j] == parent[u] and not visited[j]:  # If the vertex is in the same set and has not been visited\n                                stack.append(j)  # Push the vertex onto the stack\n                                visited[j] = True  # Mark the vertex as visited\n                                if j == i:  # If the vertex is the root of the cycle\n                                    cycle_found = True  # Set cycle_found to True\n                                    break  # Exit the loop\n                        if cycle_found:  # If a cycle is found\n                            break  # Exit the loop\n            if cycle_found:  # If a cycle is found\n                print('FHTAGN!')  # The graph is Cthulhu\n            else:  # If no cycle is found\n                print('NO')  # The graph is not Cthulhu\n        else:  # If there are multiple connected components\n            print('NO')  # The graph is not Cthulhu\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and the number of edges (m) from the input.\n2. Check if the number of edges is equal to n - 1. If not, the graph is not a tree and cannot be Cthulhu, so print \"NO\" and return.\n3. Initialize a disjoint-set data structure to keep track of connected components in the graph.\n4. Iterate over each edge in the graph, and for each edge, union the two vertices in the disjoint-set data structure.\n5. Find the root of the set that contains vertex 1 (the first vertex). If all vertices are in the same set, the graph is connected.\n6. Iterate over the remaining vertices (from 2 to n). If any vertex is not in the same set as vertex 1, the graph is not a single connected component, so print \"NO\" and return.\n7. If the graph passes all checks, it is a Cthulhu graph, so print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\n# Problem from Codeforces\n# http://codeforces.com/problemset/problem/103/B\n\n# Disjoint-set data structure to keep track of connected components\nparent = dict()  # stores the parent of each vertex\nranks = dict()  # stores the rank of each set\n\n# Function to make a set for each vertex\ndef make_set(N):\n    global parent, ranks\n    # Initialize parent and ranks for each vertex\n    parent = {i: i for i in range(N + 5)}\n    ranks = {i: 0 for i in range(N + 5)}\n\n# Function to find the root of a set\ndef find_set(u):\n    # If the parent of u is not itself, find the root recursively\n    if parent[u]!= u:\n        parent[u] = find_set(parent[u])\n    # Return the root of the set\n    return parent[u]\n\n# Function to union two sets\ndef union_set(u, v):\n    # Find the roots of the sets containing u and v\n    up = find_set(u)\n    vp = find_set(v)\n\n    # If the sets are the same, do nothing\n    if up == vp:\n        return\n    # Union the sets based on their ranks\n    if ranks[up] > ranks[vp]:\n        parent[vp] = up\n    elif ranks[up] < ranks[vp]:\n        parent[up] = vp\n    else:\n        parent[up] = vp\n        ranks[vp] += 1\n\n# Main solution function\ndef solution():\n    # Read the number of vertices and edges from the input\n    m, n = map(int, input().split())\n    # Check if the number of edges is equal to n - 1\n    if m!= n:\n        print('NO')\n        return\n\n    # Initialize the disjoint-set data structure\n    make_set(m)\n    # Iterate over each edge in the graph and union the two vertices\n    for i in range(m):\n        a, b = map(int, input().split())\n        union_set(a, b)\n\n    # Find the root of the set containing vertex 1\n    top_parent = find_set(1)\n    # Iterate over the remaining vertices and check if they are in the same set\n    for i in range(2, m):\n        if find_set(i)!= top_parent:\n            print('NO')\n            return\n\n    # If the graph passes all checks, it is a Cthulhu graph\n    print('FHTAGN!')\n\n# Call the solution function\nsolution()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of nodes and edges from the input.\n2. Create an empty dictionary to store the graph edges, where each key is a node and its corresponding value is a list of its neighbors.\n3. Iterate through the input edges and add them to the graph dictionary. If a node is not present in the dictionary, add it with its neighbor. If a node is already present, append the new neighbor to its list.\n4. Define a function `get_neighbors` to retrieve the neighbors of a given node from the graph dictionary.\n5. Define a function `DFS` to perform a Depth-First Search (DFS) traversal of the graph starting from a given node. This function keeps track of visited nodes and returns a set of all visited nodes.\n6. Iterate through all nodes in the graph and perform DFS traversal starting from each node. Count the number of nodes that have a DFS traversal result with a size equal to or greater than the total number of nodes.\n7. If the count of such nodes is 3 or more and the total number of edges is equal to the total number of nodes minus 1, print \"FHTAGN!\". Otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\n# Read the number of nodes and edges from the input\nnum_nodes, num_edges = map(int, input().split())\n\n# Create an empty dictionary to store the graph edges\nedges = {}\n\n# Iterate through the input edges and add them to the graph dictionary\nfor i in range(num_edges):\n  node1, node2 = map(int, input().split())\n  # Get the current keys in the dictionary\n  keys = list(edges.keys())\n  # If node1 is already in the dictionary, append node2 to its list of neighbors\n  if node1 in keys:\n    edges[node1].append(node2)\n  # Otherwise, add node1 to the dictionary with node2 as its only neighbor\n  else:\n    edges[node1] = [node2]\n  # Repeat the same process for node2\n  if node2 in keys:\n    edges[node2].append(node1)\n  else:\n    edges[node2] = [node1]\n\n# Define a function to retrieve the neighbors of a given node\ndef get_neighbors(edges, node):\n  # Return the list of neighbors of the given node\n  neighbors = edges[node]\n  return neighbors\n\n# Define a function to perform DFS traversal starting from a given node\ndef DFS(edges, node):\n  # Initialize a set to keep track of visited nodes\n  explorados = {node}\n  # Initialize a list to store nodes to be explored\n  to_explore = []\n  # Add all neighbors of the starting node to the list of nodes to be explored\n  for n in get_neighbors(edges, node):\n    to_explore.append(n)\n  # Perform DFS traversal\n  while len(to_explore) > 0:\n    # Get the next node to be explored\n    atual = to_explore[-1]\n    # Remove the node from the list of nodes to be explored\n    to_explore.pop(-1)\n    # Mark the node as visited\n    explorados.add(atual)\n    # Get the neighbors of the current node\n    neighbors = get_neighbors(edges, atual)\n    # Add unvisited neighbors to the list of nodes to be explored\n    for n in neighbors:\n      if n not in explorados:\n        to_explore.append(n)\n  # Return the set of visited nodes\n  return explorados\n\n# Initialize a counter for nodes with DFS traversal result size equal to or greater than the total number of nodes\ntotal = 0\n# Iterate through all nodes in the graph\nfor node1 in list(edges.keys()):\n  # Perform DFS traversal starting from the current node\n  explorados_final = DFS(edges, node1)\n  # If the size of the DFS traversal result is equal to or greater than the total number of nodes, increment the counter\n  if len(explorados_final) >= num_nodes:\n    total += 1\n\n# Check the conditions for the graph to be considered Cthulhu\nif total >= 3 and num_edges == num_nodes - 1:\n  # If the conditions are met, print \"FHTAGN!\"\n  print('FHTAGN!')\nelse:\n  # Otherwise, print \"NO\"\n  print('NO')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Check if the graph is valid by ensuring that n is at least 3 and that the number of edges (m) is equal to n - 1. If not, print \"NO\" and exit the program.\n3. Create an adjacency list (e) to represent the graph, where e[i] contains the vertices connected to vertex i.\n4. Iterate through each edge in the graph and add the corresponding vertices to each other's adjacency lists.\n5. Define a depth-first search (DFS) function to traverse the graph and find all connected components.\n6. Perform DFS starting from an arbitrary vertex (in this case, vertex 1) and mark all visited vertices in the set f.\n7. After DFS, check if the number of visited vertices (len(f)) is equal to the total number of vertices (n). If yes, print \"FHTAGN!\", indicating that the graph is a Cthulhu. Otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\n# Read the input values for the number of vertices (n) and the number of edges (m) from the user\nn, m = map(int, input().split())\n\n# Check if the graph is valid\nif n < 3 or n!= m + 1:  # n - 1 edges for a tree, but we have m edges\n    print('NO')  # Invalid graph\n    exit()\n\n# Create an adjacency list (e) to represent the graph\ne, f = [[] for i in range(n + 1)], set()  # Initialize e as an empty list for each vertex\n\n# Iterate through each edge in the graph and add the corresponding vertices to each other's adjacency lists\nfor j in range(m):\n    x, y = map(int, input().split())  # Read the edge (x, y)\n    e[x].append(y)  # Add y to x's adjacency list\n    e[y].append(x)  # Add x to y's adjacency list\n\n# Define a depth-first search (DFS) function to traverse the graph and find all connected components\ndef dfs(x):\n    # Mark the current vertex as visited by adding it to the set f\n    f.add(x)\n    \n    # Recursively visit all unvisited neighbors of the current vertex\n    for y in e[x]:\n        if not y in f:  # Check if y has not been visited yet\n            dfs(y)  # Recursively visit y\n\n# Perform DFS starting from an arbitrary vertex (in this case, vertex 1)\ndfs(1)\n\n# After DFS, check if the number of visited vertices (len(f)) is equal to the total number of vertices (n)\nprint('FHTAGN!' if len(f) == n else 'NO')  # Print the result\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the first line.\n2. Initialize an adjacency list (adj) to represent the graph, where each index represents a vertex and its corresponding value is a list of adjacent vertices.\n3. Initialize a list (seen) to keep track of visited vertices during the depth-first search (DFS).\n4. Initialize a list (pai) to store the parent of each vertex in the DFS traversal.\n5. Initialize a variable (ciclos) to count the number of simple cycles in the graph.\n6. Perform a DFS traversal starting from an arbitrary vertex (1) to identify connected components and count simple cycles.\n7. Check if all vertices are visited (conexo) to ensure the graph is connected.\n8. If the graph is not connected, print \"NO\" and exit.\n9. If the graph is connected, check if the number of simple cycles (ciclos) is equal to 1 (ciclos/2 == 1). If true, print \"FHTAGN!\"; otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\n# Read input values for the number of vertices (n) and the number of edges (m)\nn, m = [int(i) for i in input().split()]\n\n# Initialize an adjacency list (adj) to represent the graph\nadj = [[] for i in range(n+1)]\n\n# Initialize a list (seen) to keep track of visited vertices during the DFS\nseen = [False for i in range(n+1)]\n\n# Initialize a list (pai) to store the parent of each vertex in the DFS traversal\npai = [0 for i in range(n+1)]\n\n# Initialize a variable (ciclos) to count the number of simple cycles in the graph\nciclos = 0\n\n# Define a recursive DFS function to traverse the graph\ndef dfs(u):\n    # Mark the current vertex as visited\n    seen[u] = True\n    \n    # Count simple cycles by checking for back edges\n    global ciclos\n    for v in adj[u]:\n        if not seen[v]:\n            # If the adjacent vertex is not visited, recursively traverse it\n            pai[v] = u\n            dfs(v)\n        elif v!= pai[u]:\n            # If the adjacent vertex is visited and not the parent, increment the cycle count\n            ciclos += 1\n\n# Read edge connections and update the adjacency list\nfor i in range(m):\n    x, y = [int(i) for i in input().split()]\n    adj[x].append(y)\n    adj[y].append(x)\n\n# Perform DFS traversal starting from an arbitrary vertex (1)\ndfs(1)\n\n# Check if all vertices are visited (conexo) to ensure the graph is connected\nconexo = True\nfor i in range(1, n+1, 1):\n    if not seen[i]:\n        # If any vertex is not visited, the graph is not connected\n        conexo = False\n\n# If the graph is not connected, print \"NO\" and exit\nif not conexo:\n    print('NO')\n    exit(0)\n\n# If the graph is connected, check if the number of simple cycles (ciclos) is equal to 1\nif ciclos/2 == 1:\n    # If true, print \"FHTAGN!\"\n    print('FHTAGN!')\nelse:\n    # Otherwise, print \"NO\"\n    print('NO')\nexit(0)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the number of vertices (A) and edges (B) from the input.\n2. Create an adjacency list representation of the graph, where each index represents a vertex and its corresponding value is a list of its adjacent vertices.\n3. Initialize a color array of size A with all elements set to 0, which will be used to keep track of visited vertices during the DFS traversal.\n4. Perform a Depth-First Search (DFS) traversal starting from vertex 0, marking each visited vertex with a color of 1.\n5. Check if all vertices have been visited by summing the color array and comparing it with the total number of vertices (A). If not all vertices are visited, the graph is not connected and cannot be regarded as Cthulhu.\n6. If all vertices are visited, check if the number of edges (B) is equal to the number of vertices (A) minus 1. If not, the graph is not a tree and cannot be regarded as Cthulhu.\n7. If the graph is a tree, check if it contains a simple cycle by performing another DFS traversal. If a cycle is found, the graph can be regarded as Cthulhu.\n\nCOMMENTED CODE:\n```python\n# Read the number of vertices (A) and edges (B) from the input\nA, B = map(int, input().split())\n\n# Create an adjacency list representation of the graph\nA_ = [[] for i in range(A)]\nfor i in range(B):\n    # Read the edge information and add it to the adjacency list\n    a, b = map(int, input().split())\n    A_[b-1].append(a-1)\n    A_[a-1].append(b-1)\n\n# Initialize a color array to keep track of visited vertices\ncolor = [0 for i in range(A)]\n\n# Perform a Depth-First Search (DFS) traversal starting from vertex 0\ndef dfs(a):\n    global color\n    # Mark the current vertex as visited\n    color[a] = 1\n    # Recursively visit all unvisited adjacent vertices\n    for i in A_[a]:\n        if color[i] == 0:\n            dfs(i)\n\n# Start the DFS traversal from vertex 0\ndfs(0)\n\n# Check if all vertices have been visited\nif sum(color) == A:\n    # Check if the graph is a tree (number of edges equals A-1)\n    if A == B:\n        # If the graph is a tree, check if it contains a simple cycle\n        print('FHTAGN!')\n    else:\n        print('NO')\nelse:\n    print('NO')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The number of vertices `n` and the number of edges `m` of the graph, and then the `m` pairs of integers representing the edges.\n2. Create an adjacency list representation of the graph, where each index `i` in the list corresponds to a vertex, and the set at index `i` contains the vertices that are directly connected to `i`.\n3. Find a simple cycle in the graph using a depth-first search (DFS) starting from an arbitrary vertex (in this case, vertex 1). This cycle will be used as the root cycle for the subsequent analysis.\n4. If no cycle is found, the graph is not Cthulhu, so print \"NO\" and exit.\n5. Perform a DFS from each vertex in the root cycle to find all connected components in the graph.\n6. If the number of visited vertices is equal to the total number of vertices `n`, then the graph can be represented as a set of rooted trees connected by a simple cycle, so print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\n# 103B\n\n__author__ = 'artyom'\n\n# Read the input: number of vertices n and number of edges m, and then m pairs of integers representing the edges\nread = lambda: map(int, input().split())\nn, m = read()\n\n# Create an adjacency list representation of the graph\ngraph = [set() for _ in range(n + 1)]\nfor __ in range(m):\n  # For each edge, add the vertices to each other's adjacency lists\n  u, v = read()\n  graph[u].add(v)\n  graph[v].add(u)\n\n# Function to find a simple cycle in the graph using DFS\ndef find_cycle(start):\n  # Initialize parents array to keep track of the parent of each vertex\n  parents, stack = [0] * (n + 1), [(start, -1)]\n  while stack:\n    # Pop the top vertex from the stack\n    vertex, parent = stack.pop()\n    # Mark the vertex as visited by setting its parent\n    parents[vertex] = parent\n    # Iterate over the neighbors of the vertex\n    for neighbour in graph[vertex]:\n      # If the neighbor is not the parent, it's a new vertex to explore\n      if neighbour!= parent:\n        # If the neighbor has already been visited, it means we've found a cycle\n        if parents[neighbour]:\n          # Reconstruct the cycle by backtracking from the neighbor to the start vertex\n          cycle = set()\n          cycle.add(neighbour)\n          while vertex!= neighbour:\n            cycle.add(vertex)\n            vertex = parents[vertex]\n          return cycle\n        # Add the neighbor to the stack to explore its neighbors\n        stack.append((neighbour, vertex))\n  # If no cycle is found, return an empty set\n  return set()\n\n# Find a simple cycle in the graph\ncyc = find_cycle(1)\nif not cyc:\n  # If no cycle is found, the graph is not Cthulhu, so print \"NO\" and exit\n  print('NO')\n  exit()\n\n# Function to perform DFS from each vertex in the root cycle to find all connected components\ndef dfs():\n  # Initialize a set to keep track of visited vertices\n  visited = set(cyc)\n  # Iterate over each vertex in the root cycle\n  for start in cyc:\n    # Initialize a stack to perform DFS from the current vertex\n    stack = [(v, start) for v in graph[start] if v not in cyc]\n    while stack:\n      # Pop the top vertex from the stack\n      vertex, parent = stack.pop()\n      # Mark the vertex as visited\n      visited.add(vertex)\n      # Iterate over the neighbors of the vertex\n      for neighbour in graph[vertex]:\n        # If the neighbor is not the parent and has not been visited, add it to the stack\n        if neighbour!= parent:\n          if neighbour in visited:\n            # If the neighbor has already been visited, it means there's a cycle, so return an empty set\n            return set()\n          stack.append((neighbour, vertex))\n  # If all vertices have been visited, return the set of visited vertices\n  return visited\n\n# Perform DFS from each vertex in the root cycle\nvisited = dfs()\n# If the number of visited vertices is equal to the total number of vertices n, then the graph can be represented as a set of rooted trees connected by a simple cycle, so print \"FHTAGN!\"\nprint('FHTAGN!' if len(visited) == n else 'NO')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the number of vertices (n) and edges (m) from the input.\n2. If n is not equal to m + 1, it means the graph is not connected, so it cannot be a Cthulhu, and we print \"NO\" and exit.\n3. Initialize a list of Node objects, where each Node represents a vertex in the graph and stores its parent and rank in the Union-Find data structure.\n4. Iterate over each edge in the graph, and for each edge, perform the Union operation on the two vertices it connects.\n5. If the Union operation does not merge two separate components (i.e., it returns False), it means the edge is part of a cycle, so we increment the cycle count.\n6. After processing all edges, if the cycle count is 1, it means the graph has a single cycle, which is a necessary condition for a Cthulhu. In this case, we print \"FHTAGN!\".\n7. Otherwise, if the cycle count is greater than 1 or 0, it means the graph does not meet the Cthulhu criteria, so we print \"NO\".\n\nCOMMENTED CODE:\n```python\nclass Node:\n  # Initialize a Node object with its parent and rank\n  def __init__(self, parent, rank):\n    self.parent = parent\n    self.rank = rank\n\ndef findRoot(s, u):\n  # Find the root of the set containing vertex u\n  if s[u].parent!= u:\n    # Path compression: update the parent of u to be the root\n    s[u].parent = findRoot(s, s[u].parent)\n  return s[u].parent\n\ndef union(s, u, v):\n  # Merge the sets containing vertices u and v\n  ru = findRoot(s, u)\n  rv = findRoot(s, v)\n  if ru!= rv:\n    # If the ranks are different, attach the tree with the smaller rank to the tree with the larger rank\n    if s[ru].rank < s[rv].rank:\n      s[ru].parent = rv\n    elif s[ru].rank > s[rv].rank:\n      s[rv].parent = ru\n    else:\n      # If the ranks are equal, increment the rank of the tree with the smaller rank and attach it to the other tree\n      s[rv].parent = ru\n      s[ru].rank += 1\n    return True\n  return False\n\nif __name__ == \"__main__\":\n  # Read the number of vertices (n) and edges (m) from the input\n  n, m = map(int, input().split())\n  if n!= m + 1:\n    # If n is not equal to m + 1, the graph is not connected, so it cannot be a Cthulhu\n    print(\"NO\")\n    exit(0)\n  # Initialize a list of Node objects, where each Node represents a vertex in the graph\n  s = []\n  for i in range(n + 1):\n    s.append(Node(i, 0))\n  # Initialize the cycle count to 0\n  cnt = 0\n  # Iterate over each edge in the graph\n  for i in range(m):\n    u, v = map(int, input().split())\n    # Perform the Union operation on the two vertices connected by the edge\n    if union(s, u, v) == False:\n      # If the Union operation does not merge two separate components, increment the cycle count\n      cnt += 1\n  # If the cycle count is 1, the graph has a single cycle, which is a necessary condition for a Cthulhu\n  if cnt == 1:\n    print(\"FHTAGN!\")\n  else:\n    # Otherwise, if the cycle count is greater than 1 or 0, the graph does not meet the Cthulhu criteria\n    print(\"NO\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Initialize the disjoint set data structure (parents, ranks, size) using the given number of vertices.\n3. Iterate through each edge in the graph, and for each edge, check if the two vertices belong to the same set. If they do, it means there's a cycle in the graph, so set a flag to True.\n4. If a cycle is found, check if it's the first cycle encountered. If it is, set a flag to True and continue. If it's not the first cycle, it means there are multiple cycles in the graph, so set the flag to False and break the loop.\n5. If no cycles are found, or if multiple cycles are found, the graph is not a Cthulhu graph, so print \"NO\".\n6. If a single cycle is found, check if the number of sets in the disjoint set data structure is greater than 1. If it is, it means there are multiple connected components in the graph, so the graph is not a Cthulhu graph, so print \"NO\". Otherwise, print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\nimport sys\nimport queue\nsys.setrecursionlimit(100000)\n\n# global constant\nINF = int(1e7+1)\nMAX = 100005\n\n# For testing\n#sys.stdin = open(\"INP.txt\", 'r')\n#sys.stdout = open(\"OUT.txt\", 'w')\n\n# global variables\nparents = []\nranks = []\nsize = []\nn = 0\n\n# classes\nclass Pair:\n    def __init__(self, a, b):\n        self.first = a\n        self.second = b\n\n\n# functions\ndef init():\n    global parents, ranks, size\n    # Initialize the disjoint set data structure\n    parents = [i for i in range(n)]\n    ranks = [0 for i in range(n)]\n    size = [1 for i in range(n)]\n\n\ndef findSet(u):\n    # Find the root of the set that vertex u belongs to\n    if parents[u]!= u:\n        # Path compression: update the parent of u to be the root of the set\n        parents[u] = findSet(parents[u])\n    return parents[u]\n\n\ndef unionSet(u, v):\n    # Merge the sets that vertices u and v belong to\n    up = findSet(u)\n    vp = findSet(v)\n    if up == vp:\n        # If u and v are already in the same set, do nothing\n        return\n    if ranks[up] < ranks[vp]:\n        # If the rank of the set that u belongs to is less than the rank of the set that v belongs to,\n        # make the set that v belongs to the parent of the set that u belongs to\n        parents[up] = vp\n    elif ranks[vp] < ranks[up]:\n        # If the rank of the set that v belongs to is less than the rank of the set that u belongs to,\n        # make the set that u belongs to the parent of the set that v belongs to\n        parents[vp] = up\n    else:\n        # If the ranks of the two sets are equal, make the set that v belongs to the parent of the set that u belongs to\n        # and increment the rank of the set that v belongs to\n        ranks[vp] += 1\n        parents[up] = vp\n\n\n# main function\ndef main():\n    global n\n    # Read the number of vertices and edges from the input\n    n, m = map(int, input().split())\n    # Initialize the disjoint set data structure\n    init()\n    # Flag to check if a cycle is found\n    flag = False\n    # Flag to check if the first cycle is found\n    firstLoop = False\n    # Iterate through each edge in the graph\n    for i in range(m):\n        u, v = map(int, input().split())\n        # Decrement u and v by 1 to make them 0-indexed\n        u -= 1\n        v -= 1\n        # Check if the two vertices belong to the same set\n        if findSet(u) == findSet(v):\n            # If they do, it means there's a cycle in the graph, so set the flag to True\n            flag = True\n            # If this is the first cycle found, set the firstLoop flag to True\n            if not firstLoop:\n                firstLoop = True\n            else:\n                # If this is not the first cycle found, it means there are multiple cycles in the graph,\n                # so set the flag to False and break the loop\n                flag = False\n                break\n        # Merge the sets that vertices u and v belong to\n        unionSet(u, v)\n    # Create a set to store the roots of the sets\n    S = set()\n    # If a cycle is found, iterate through each vertex and add its root to the set\n    if flag:\n        for i in range(n):\n            S.add(findSet(i))\n    # If a cycle is found and the number of sets is greater than 1, it means there are multiple connected components in the graph,\n    # so the graph is not a Cthulhu graph, so print \"NO\"\n    if flag and len(S) > 1:\n        flag = False\n    # If a cycle is found and the number of sets is 1, it means the graph is a Cthulhu graph, so print \"FHTAGN!\"\n    if flag:\n        print(\"FHTAGN!\")\n    else:\n        # If no cycle is found, or if multiple cycles are found, the graph is not a Cthulhu graph, so print \"NO\"\n        print(\"NO\")\n\n\nmain()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the number of vertices `n` and the number of edges `m` from the input.\n2. Initialize an empty list `edges` to store the edges of the graph and two lists `link` and `size` to keep track of the connected components and their sizes, respectively. Initialize `link` with the indices of the vertices and `size` with ones.\n3. Define a function `find_link(x)` to find the root of the connected component containing vertex `x`. This function uses path compression to optimize the process.\n4. Define a function `same(x, y)` to check if vertices `x` and `y` are in the same connected component.\n5. Define a function `unite(x, y)` to merge the connected components containing vertices `x` and `y`. This function uses the union-find data structure to keep track of the connected components.\n6. Read the edges of the graph from the input and merge the connected components using the `unite` function.\n7. Check if the graph can be regarded as Cthulhu by verifying two conditions: (1) the maximum size of a connected component is equal to `n`, and (2) the number of edges is equal to `n - 1` (since a tree with `n` vertices has `n - 1` edges). If both conditions are met, print \"FHTAGN!\", otherwise print \"NO\".\n\nCOMMENTED CODE:\n```python\ndef solve():\n    import sys\n    input = sys.stdin.readline  # Read input from standard input\n\n    # Read the number of vertices n and the number of edges m from the input\n    n, m = map(int, input().split())\n\n    # Initialize an empty list to store the edges of the graph\n    edges = []\n\n    # Initialize two lists to keep track of the connected components and their sizes\n    link = [i for i in range(n+1)]  # Initialize link with the indices of the vertices\n    size = [1 for _ in range(n+1)]  # Initialize size with ones\n\n    # Define a function to find the root of the connected component containing vertex x\n    def find_link(x):\n        # Use path compression to optimize the process\n        while x!= link[x]:\n            x = link[x]\n        return x\n\n    # Define a function to check if vertices x and y are in the same connected component\n    def same(x, y):\n        return find_link(x) == find_link(y)\n\n    # Define a function to merge the connected components containing vertices x and y\n    def unite(x, y):\n        if same(x, y):  # If x and y are already in the same connected component, do nothing\n            return\n\n        # Find the smaller and larger connected components\n        small_set, big_set = find_link(x), find_link(y)\n        if size[small_set] > size[big_set]:\n            small_set, big_set = big_set, small_set\n\n        # Merge the smaller connected component into the larger one\n        link[small_set] = big_set\n        size[big_set] += size[small_set]\n\n    # Read the edges of the graph from the input and merge the connected components\n    for _ in range(m):\n        u, v = map(int, input().split())  # Read the edge (u, v)\n        unite(u, v)  # Merge the connected components containing u and v\n\n    # Check if the graph can be regarded as Cthulhu\n    if max(size) == n and n == m:  # Check the two conditions\n        print('FHTAGN!')  # If both conditions are met, print \"FHTAGN!\"\n    else:\n        print('NO')  # Otherwise, print \"NO\"\n\nsolve()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input values of n (number of vertices) and m (number of edges) from the user.\n2. Create an adjacency list representation of the graph using a defaultdict in Python.\n3. Iterate through each edge in the graph and add it to the adjacency list of both vertices.\n4. Initialize a visited array to keep track of visited vertices during DFS, and a parent array to store the parent of each vertex.\n5. Perform a Depth-First Search (DFS) starting from vertex 0. Mark the current vertex as visited and add its unvisited neighbors to the queue.\n6. During DFS, check if the current vertex has a neighbor that is already visited and is not its parent. If found, it means there's a cycle in the graph, so set f = 1.\n7. After DFS, count the number of visited vertices (cnt) and check if it's equal to n (all vertices are visited) and if f is still 0 (no cycle found).\n8. If the conditions in step 7 are met, it means the graph is a tree (connected and no cycles). However, we also need to check if the number of edges (m) is equal to n - 1 (a tree with n vertices has n - 1 edges).\n9. If all conditions are met, print \"FHTAGN!\", otherwise print \"NO\".\n\nCOMMENTED CODE:\n```python\n# Create an adjacency list representation of the graph\nfrom collections import defaultdict\ngraph = defaultdict(list)\n\n# Read the input values of n (number of vertices) and m (number of edges)\nn, m = list(map(int, input().split()))\n\n# Iterate through each edge in the graph and add it to the adjacency list of both vertices\nfor i in range(m):\n    u, v = list(map(int, input().split()))\n    graph[u-1].append(v-1)\n    graph[v-1].append(u-1)\n\n# Initialize a visited array to keep track of visited vertices during DFS\nvisited = [False for i in range(n)]\n\n# Initialize a parent array to store the parent of each vertex\nparent = [-1 for i in range(n)]\n\n# Initialize a queue for DFS\nq = []\n\n# Mark the starting vertex as visited and add it to the queue\nvisited[0] = True\nq += [0]\n\n# Initialize a flag to check for cycles\nf = 0\n\n# Perform DFS\nwhile q!= []:\n    u = q[0]\n    q.pop(0)\n\n    # Iterate through the neighbors of the current vertex\n    for i in graph[u]:\n        # If the neighbor is not visited, mark it as visited, add it to the queue, and update its parent\n        if visited[i] == False:\n            visited[i] = True\n            q.append(i)\n            parent[i] = u\n        # If the neighbor is already visited and is not the parent of the current vertex, it means there's a cycle\n        elif parent[u]!= i:\n            f = 1\n\n# Count the number of visited vertices\ncnt = visited.count(True)\n\n# Check if the graph is a tree (connected and no cycles) and if the number of edges is equal to n - 1\nif f == 0 and cnt == n and n == m + 1:  # n == m + 1 because a tree with n vertices has n - 1 edges\n    print(\"FHTAGN!\")\nelse:\n    print(\"NO\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the first line.\n2. Check if the graph is valid by ensuring that n is at least 3 and that the number of edges is equal to n - 1 (since a tree with n vertices has n - 1 edges). If not, print \"NO\" and exit.\n3. Create an adjacency list (e) to represent the graph, where e[i] contains the vertices connected to vertex i.\n4. Read the edges of the graph from the subsequent lines and update the adjacency list accordingly.\n5. Perform a depth-first search (DFS) starting from vertex 1 to find all connected components in the graph.\n6. Check if the number of vertices in the connected component (f) is equal to n. If yes, print \"FHTAGN!\", indicating that the graph is a Cthulhu. Otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\n# Read the input values for the number of vertices (n) and the number of edges (m)\ninp = input().split()\nn = int(inp[0])  # Number of vertices\nm = int(inp[1])  # Number of edges\n\n# Check if the graph is valid\nif n < 3 or n!= m + 1:  # A tree with n vertices has n - 1 edges\n    # If not, print \"NO\" and exit\n    print('NO')\n    exit()\n\n# Create an adjacency list (e) to represent the graph\ne, f = [[] for i in range(n + 1)], set()  # Initialize adjacency list and set for visited vertices\n\n# Read the edges of the graph from the subsequent lines and update the adjacency list\nfor j in range(m):\n    x, y = map(int, input().split())  # Read edge (x, y)\n    e[x].append(y)  # Add y to the adjacency list of x\n    e[y].append(x)  # Add x to the adjacency list of y\n\n# Perform a depth-first search (DFS) starting from vertex 1 to find all connected components in the graph\ndef dfs(x):\n    # Mark vertex x as visited by adding it to the set f\n    f.add(x)\n    # Recursively visit all unvisited neighbors of x\n    for y in e[x]:\n        if not y in f:\n            dfs(y)\n\n# Start the DFS from vertex 1\ndfs(1)\n\n# Check if the number of vertices in the connected component (f) is equal to n\nprint('FHTAGN!' if len(f) == n else 'NO')  # Print \"FHTAGN!\" if the graph is a Cthulhu, otherwise print \"NO\"\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Create an adjacency list representation of the graph, where each index i in the list represents a vertex, and the elements at index i are the vertices directly connected to i.\n3. Initialize three arrays: a, b, and c. Array a will be used to keep track of the visited vertices and their status (1 for visited, 2 for visited and processed), array b will store the parent of each vertex, and c will count the number of roots in the graph.\n4. Perform a depth-first search (DFS) starting from vertex 1. During the DFS, update the status of visited vertices in array a, store the parent of each vertex in array b, and increment c whenever a root is found.\n5. After the DFS, check if the graph satisfies the conditions for being a Cthulhu: if c is not equal to 1 (indicating multiple roots) or if there are any vertices with status 0 in array a (indicating unvisited vertices), print \"NO\". Otherwise, print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\ndef func(n):\n    # Mark the current vertex as visited\n    global a, b, c, lst\n    a[n] = 1\n    \n    # Iterate over all vertices connected to the current vertex\n    for j in lst[n]:\n        # If the connected vertex is already visited and its parent is not the current vertex, increment c\n        if a[j] == 1 and b[n]!= j:\n            c += 1\n        # If the connected vertex has not been visited, mark it as visited and update its parent\n        if not a[j]:\n            b[j] = n\n            # Recursively call func on the connected vertex\n            func(j)\n    \n    # Mark the current vertex as processed\n    a[n] = 2\n\n# Read the number of vertices (n) and edges (m) from the input\nn, m = [int(x) for x in input().split()]\n\n# Create an adjacency list representation of the graph\nlst = [[] for i in range(n + 1)]\n\n# Populate the adjacency list\nfor i in range(m):\n    x, y = map(int, input().split())\n    lst[x].append(y)\n    lst[y].append(x)\n\n# Initialize arrays a, b, and c\na = [0] * (n + 1)\nb = [0] * (n + 1)\nc = 0\n\n# Perform DFS starting from vertex 1\nfunc(1)\n\n# Check if the graph satisfies the conditions for being a Cthulhu\nif c!= 1 or 0 in a[1:]:\n    print(\"NO\")\nelse:\n    print(\"FHTAGN!\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (N) and the number of edges (M) from the user.\n2. Create an adjacency list representation of the graph using the given edges.\n3. Initialize a variable `visn` to keep track of the number of visited vertices and a visited array to mark visited vertices.\n4. Perform a depth-first search (DFS) traversal of the graph starting from an arbitrary vertex (in this case, vertex 0).\n5. Check if the number of visited vertices is equal to the total number of vertices. If not, the graph is not connected, and it's not a Cthulhu graph.\n6. If the graph is connected, check if the number of edges is equal to the number of vertices minus one. If not, the graph is not a tree, and it's not a Cthulhu graph.\n7. If the graph is a tree, find all the biconnected components in the graph using the DFS traversal.\n8. Check if the graph can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle. If it can, the graph is a Cthulhu graph.\n\nCOMMENTED CODE:\n```python\n# Read the input values for the number of vertices (N) and the number of edges (M) from the user.\nN, M = map(int, input().split())\n\n# Create an adjacency list representation of the graph using the given edges.\ng = [[] for i in range(N)]\nfor i in range(M):\n    a, b = map(int, input().split())\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\n\n# Initialize a variable `visn` to keep track of the number of visited vertices and a visited array to mark visited vertices.\nvisn = 0\nvisited = [0] * N\n\n# Perform a depth-first search (DFS) traversal of the graph starting from an arbitrary vertex (in this case, vertex 0).\ndef dfs(n):\n    global visn\n    visn += 1\n    visited[n] = 1\n    for i in g[n]:\n        if not visited[i]:\n            dfs(i)\n\n# Check if the number of visited vertices is equal to the total number of vertices. If not, the graph is not connected, and it's not a Cthulhu graph.\nif N!= M:\n    print(\"NO\")\n    exit()\n\n# Perform DFS traversal to mark all vertices as visited.\ndfs(0)\n\n# Check if the number of visited vertices is equal to the total number of vertices. If not, the graph is not connected, and it's not a Cthulhu graph.\nif visn!= N:\n    print(\"NO\")\nelse:\n    # If the graph is connected, check if it can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n    print(\"FHTAGN!\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Initialize the disjoint-set data structure (parent and ranks arrays) using the makeSet function.\n3. Read the edges of the graph from the input and store them in the edge array.\n4. Apply Kruskal's algorithm to find the minimum spanning tree of the graph using the Kruskal function.\n5. After finding the minimum spanning tree, iterate through the parent array to find the number of connected components (cnt).\n6. Check if the graph is a Cthulhu graph by verifying two conditions:\n   - If there is only one connected component (cnt == 1) and there is exactly one cycle (cycle == 1), then the graph is a Cthulhu graph.\n7. Print \"FHTAGN!\" if the graph is a Cthulhu graph, otherwise print \"NO\".\n\nCOMMENTED CODE:\n```python\n\"\"\"\nhttps://codeforces.com/problemset/problem/103/B\n\"\"\"\n\n# Initialize global variables\nparent = []  # parent array for disjoint-set data structure\nranks = []  # ranks array for disjoint-set data structure\nedge = []  # array to store edges of the graph\ncycle = 0  # variable to count the number of cycles\n\n\ndef makeSet(n):\n    \"\"\"\n    Initialize the disjoint-set data structure.\n    \"\"\"\n    global parent, ranks\n\n    # Initialize parent and ranks arrays\n    parent = [i for i in range(n)]  # each element is initially its own parent\n    ranks = [0 for _ in range(n)]  # initialize ranks to 0\n\n\ndef findSet(u):\n    \"\"\"\n    Find the root of the set that contains the element u.\n    \"\"\"\n    global parent\n\n    # If u is not its own parent, recursively find its root\n    if parent[u]!= u:\n        parent[u] = findSet(parent[u])  # path compression\n    return parent[u]\n\n\ndef unionSet(u, v):\n    \"\"\"\n    Merge the sets that contain elements u and v.\n    \"\"\"\n    global parent, ranks, cycle\n\n    # Find the roots of the sets that contain u and v\n    up = findSet(u)\n    vp = findSet(v)\n\n    # If u and v are already in the same set, increment the cycle count\n    if up == vp:\n        cycle += 1\n        return\n\n    # Merge the sets based on the ranks of their roots\n    if ranks[up] > ranks[vp]:\n        parent[vp] = up  # make vp a child of up\n    elif ranks[up] < ranks[vp]:\n        parent[up] = vp  # make up a child of vp\n    else:\n        ranks[up] += 1  # increment the rank of up\n        parent[vp] = up  # make vp a child of up\n\n\ndef Kruskal():\n    \"\"\"\n    Apply Kruskal's algorithm to find the minimum spanning tree.\n    \"\"\"\n    for i in range(len(edge)):\n        u = edge[i][0]\n        v = edge[i][1]\n        # Check if u and v are not the same vertex\n        if u!= v:\n            unionSet(u, v)\n\n\ndef main():\n    \"\"\"\n    Main function to solve the problem.\n    \"\"\"\n    n, m = map(int, input().split())  # read the number of vertices and edges\n    makeSet(n + 1)  # initialize the disjoint-set data structure\n\n    for _ in range(m):\n        edge.append(list(map(int, input().split())))  # read edges of the graph\n\n    Kruskal()  # apply Kruskal's algorithm\n    for i in range(1, n + 1):\n        findSet(i)  # find the root of each set\n    parent.pop(0)  # remove the dummy parent\n    cnt = len(set(parent))  # count the number of connected components\n\n    # Check if the graph is a Cthulhu graph\n    if cnt == 1 and cycle == 1:\n        print('FHTAGN!')\n    else:\n        print('NO')\n\n\nif __name__ == \"__main__\":\n    main()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input: The first step is to read the number of vertices (n) and the number of edges (m) from the input. Then, read the edges of the graph, where each edge is represented as a pair of vertices.\n2. Initialize the adjacency list: Create an adjacency list (adjs) to represent the graph, where adjs[i] contains the indices of the vertices that are directly connected to vertex i.\n3. Perform DFS to find a simple cycle: Use a depth-first search (DFS) to find a simple cycle in the graph. The DFS function takes a vertex x, its parent vertex pre, and the current degree deg as parameters. It marks the visited vertices and returns True if a cycle is found, False otherwise.\n4. Identify the cycle: If a cycle is found, store the vertices in the cycle in the circle list.\n5. Reset the degrees: Reset the degrees of all vertices to -1.\n6. Perform DFS2 to check the graph structure: Use another DFS function (dfs2) to check if the graph can be represented as a set of rooted trees with a simple cycle. The dfs2 function takes a vertex x, its parent vertex pre, and the current degree deg as parameters. It returns False if the graph structure is not valid, True otherwise.\n7. Check the degrees: Check if all vertices have a valid degree. If any vertex has a degree other than -1 or the degree calculated by dfs2, print \"NO\".\n8. Print the result: If the graph structure is valid and all vertices have a valid degree, print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\nfrom __future__ import print_function\nimport sys\nfrom collections import *\nfrom heapq import *\nfrom functools import *\nimport re\nfrom itertools import *\n\nINF=float(\"inf\")\nNINF=float(\"-inf\")\n\ntry:\n    input=raw_input\nexcept:\n    pass\n\ndef read_string():\n    return input()\n\ndef read_string_line():\n    return [x for x in input().split(\" \")]\n\ndef read_int_line():\n    return [int(x) for x in input().split(\" \")]\n\ndef read_int():\n    return int(input())\n\n# Read the input\nn,m=read_int_line()\n\n# Initialize the adjacency list\nadjs=[[] for _ in range(n)]\nfor _ in range(m):\n    a,b=read_int_line()\n    adjs[a-1].append(b-1)\n    adjs[b-1].append(a-1)\n\n# Initialize the degrees\ndegs=[-1]*n\n\n# Perform DFS to find a simple cycle\nst=[]\ncircle=[]\ndef dfs(x, pre,deg):\n    # Mark the visited vertex\n    degs[x]=deg\n    st.append(x)\n    \n    # Recur for all adjacent vertices\n    for to in adjs[x]:\n        if to==pre:continue\n        if degs[to]==-1:\n            # If the adjacent vertex is not visited, recur for it\n            if dfs(to,x,deg+1):\n                # If a cycle is found, backtrack and return True\n                st.pop()\n                return True\n        else:\n            # If the adjacent vertex is already visited, it means a cycle is found\n            i=st.index(to)\n            assert not circle\n            circle.extend(st[i:])\n            st.pop()\n            return True\n    \n    # If no cycle is found, backtrack and return False\n    st.pop()\n    return False\n\n# Find a simple cycle in the graph\ndfs(0,-1,0)\n\n# If no cycle is found, print \"NO\"\nif not circle:\n    print(\"NO\") \nelse:\n    # Reset the degrees\n    degs[:]=[-1]*n\n    \n    # Perform DFS2 to check the graph structure\n    for i, a in enumerate(circle):\n        b=circle[(i+1)%len(circle)]\n        # Add the edges of the cycle to the set of edges\n        edges.add((a,b))\n        edges.add((b,a))\n    \n    # Check if the graph structure is valid\n    for a in circle:\n        if degs[a]!=-1:\n            # If any vertex has a degree other than -1, print \"NO\"\n            print(\"NO\")\n            break\n        if not dfs2(a,-1,0):\n            # If the graph structure is not valid, print \"NO\"\n            print(\"NO\")\n            break\n    else:\n        # If all vertices have a valid degree, print \"FHTAGN!\"\n        if -1 in degs:\n            print(\"NO\")\n        else:\n            print(\"FHTAGN!\")\n\n# Define the DFS2 function to check the graph structure\ndef dfs2(x,pre,deg):\n    # Mark the visited vertex\n    degs[x]=deg\n    \n    # Recur for all adjacent vertices\n    for to in adjs[x]:\n        if to==pre:continue\n        if (x,to) in edges:continue\n        if degs[to]!= -1:\n            # If the adjacent vertex is already visited and the edge is not in the cycle, return False\n            return False\n        if not dfs2(to,x,deg+1):\n            # If the graph structure is not valid, return False\n            return False\n    \n    # If the graph structure is valid, return True\n    return True\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The first line contains the number of vertices (n) and the number of edges (m) in the graph. Then, for each edge, read the two vertices it connects.\n2. Create an undirected graph data structure: Initialize a graph with n vertices and an adjacency list to store the edges.\n3. Add edges to the graph: For each edge, add it to the adjacency list of both vertices.\n4. Initialize a disjoint set union (DSU) data structure: Create a DSU with n nodes to keep track of connected components.\n5. Iterate through the edges: For each edge, check if the two vertices are already connected in the DSU. If they are, increment the cycle count.\n6. Union the vertices in the DSU: If the vertices are not connected, union them in the DSU.\n7. Check for the Cthulhu condition: If there is exactly one cycle and all vertices are connected in the DSU, the graph is a Cthulhu.\n8. Print the result: If the graph is a Cthulhu, print \"FHTAGN!\", otherwise print \"NO\".\n\nCOMMENTED CODE:\n```python\nimport sys\n\n# Increase the recursion limit to handle large inputs\nsys.setrecursionlimit(10 ** 6)\n\n# Define a class for edges\nclass Edge:\n    def __init__(self, u, v, w=0):\n        # Initialize the edge with two vertices and an optional weight\n        self.frm = u\n        self.to = v\n        self.weight = w\n\n    # Define a string representation of the edge\n    def __repr__(self):\n        return \"{frm} - {to}: {weight}\".format(frm=self.frm, to=self.to, weight=self.weight)\n\n    # Define an equality check for edges\n    def __eq__(self, other):\n        # Two edges are equal if they have the same vertices (in either order)\n        return self.frm == other.frm and self.to == other.to \\\n                    or self.frm == other.to and self.to == other.frm\n\n\n# Define a class for graphs\nclass Graph:\n    def __init__(self, num_vertex):\n        # Initialize the graph with a specified number of vertices\n        self.num_vertex = num_vertex\n        # Initialize an adjacency list to store the edges\n        self.adj_list = [[] for _ in range(num_vertex)]\n\n    # Add an edge to the graph\n    def add_edge(self, u, v, w=0):\n        # Add the edge to the adjacency list of both vertices\n        self.adj_list[u].append(Edge(u, v, w))\n        self.adj_list[v].append(Edge(v, u, w))\n\n    # Get the adjacent vertices of a vertex\n    def adj(self, v):\n        # Return the adjacency list of the vertex\n        return self.adj_list[v]\n\n    # Get all edges in the graph\n    def edges(self):\n        # Initialize an empty list to store all edges\n        all_edges = []\n        # Iterate through all vertices\n        for v in range(self.num_vertex):\n            # Iterate through all edges of the vertex\n            for e in self.adj_list[v]:\n                # Add the edge to the list if it's not already there\n                if e not in all_edges:\n                    all_edges.append(e)\n        # Return the list of all edges\n        return all_edges\n\n\n# Define a class for disjoint set union (DSU)\nclass DisjointSetUnion:\n    def __init__(self, num_nodes):\n        # Initialize the DSU with a specified number of nodes\n        self.id = [i for i in range(num_nodes)]\n        # Initialize the parent array\n        self.parent = [i for i in range(num_nodes)]\n        # Initialize the size array\n        self.size = [1 for _ in range(num_nodes)]\n        # Initialize the count of connected components\n        self.cnt = num_nodes\n\n    # Find the root of a node\n    def find(self, p):\n        # While the node is not its own parent, follow the parent pointers\n        while p!= self.parent[p]:\n            p = self.parent[p]\n        # Return the root\n        return p\n\n    # Get the count of connected components\n    def count(self):\n        # Return the count\n        return self.cnt\n\n    # Check if two nodes are connected\n    def connected(self, p, q):\n        # Return True if the nodes have the same root, False otherwise\n        return self.find(p) == self.find(q)\n\n    # Union two nodes\n    def union(self, p, q):\n        # Find the roots of the nodes\n        root_p = self.find(p)\n        root_q = self.find(q)\n        # If the nodes are already connected, do nothing\n        if root_p == root_q: return\n        # If the root of p has fewer nodes, make the root of q the parent of p\n        if self.size[root_p] < self.size[root_q]:\n            self.parent[root_p] = root_q\n            self.size[root_q] += self.size[root_p]\n        # Otherwise, make the root of p the parent of q\n        else:\n            self.parent[root_q] = root_p\n            self.size[root_p] += self.size[root_q]\n        # Decrement the count of connected components\n        self.cnt -= 1\n\n\n# Initialize the DSU and graph\ndsu = None\ngraph = None\n\n# Define the main function\ndef main():\n    # Read the input from standard input\n    sc = sys.stdin\n    # Read the first line containing the number of vertices and edges\n    line = sc.readline().strip()\n    n, m = map(int, line.split())\n    # Initialize the graph and DSU\n    global graph, dsu\n    # Initialize the cycle count\n    cnt_cycle = 0\n    # Create the graph\n    graph = Graph(n)\n    # Create the DSU\n    dsu = DisjointSetUnion(n)\n    # Iterate through the edges\n    for i in range(m):\n        # Read the edge\n        line = sc.readline().strip()\n        x, y = map(int, line.split())\n        # Decrement the vertex indices\n        x, y = x-1, y-1\n        # Add the edge to the graph\n        graph.add_edge(x, y)\n        # Check if the edge is part of a cycle\n        if dsu.connected(x, y):\n            # Increment the cycle count\n            cnt_cycle += 1\n        else:\n            # Union the vertices in the DSU\n            dsu.union(x, y)\n\n    # Check if the graph is a Cthulhu\n    detected = False\n    # If there is exactly one cycle and all vertices are connected, it's a Cthulhu\n    if cnt_cycle == 1 and dsu.count() == 1:\n        detected = True\n\n    # Print the result\n    print(\"FHTAGN!\" if detected else \"NO\")\n\n\n# Run the main function if the script is executed directly\nif __name__ == '__main__':\n    main()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Initialize an array 'root' to store the parent of each vertex, and an array 'rank' to store the rank of each vertex in the Union-Find data structure.\n3. Initialize a counter 'cnt' to count the number of edges that form a cycle.\n4. Iterate through each edge in the graph, and for each edge, check if the two vertices belong to the same connected component using the Union-Find data structure.\n5. If the two vertices belong to the same connected component, increment the counter 'cnt' by 1.\n6. If the two vertices do not belong to the same connected component, merge the two components by updating the parent and rank arrays.\n7. After iterating through all edges, check if the graph satisfies the conditions for being a Cthulhu graph:\n   - If the number of vertices is equal to the number of edges and the counter 'cnt' is 1, the graph is a Cthulhu graph.\n   - Otherwise, the graph is not a Cthulhu graph.\n\nCOMMENTED CODE:\n```python\nimport os\nimport sys\nfrom io import BytesIO, IOBase\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef par(x):\n    # Find the parent of a vertex using path compression\n    if root[x]!= x:\n        return par(root[x])\n    else:\n        return x\n\ndef max_edge(n):\n    # Calculate the maximum number of edges in a graph with n vertices\n    return n * (n - 1) // 2\n\ndef union(u, v):\n    # Merge two connected components using Union-Find\n    x = par(u)\n    y = par(v)\n    if x!= y:\n        if rank[x] >= rank[y]:\n            root[y] = root[x]\n            rank[x] += rank[y]\n        elif rank[y] > rank[x]:\n            root[x] = root[y]\n            rank[y] += rank[x]\n\nn, m = map(int, input().split())\nroot = [i for i in range(n + 1)]\nrank = [1] * (n + 1)\n# g = [[] for i in range(n + 1)]\ncnt = 0\nfor i in range(m):\n    u, v = map(int, input().split())\n    # Check if the two vertices belong to the same connected component\n    if par(u)!= par(v):\n        union(u, v)\n    else:\n        cnt += 1\ns = set()\nfor i in range(n):\n    s.add(par(i + 1))\n# Check if the graph satisfies the conditions for being a Cthulhu graph\nif n == m and cnt == 1:\n    print(\"FHTAGN!\")\nelse:\n    print(\"NO\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Create an adjacency list representation of the graph using a defaultdict called 'v'.\n3. Iterate through each edge in the graph and add the corresponding vertices to each other's adjacency lists in 'v'.\n4. Initialize a list 'vis' of size n to keep track of visited vertices during DFS.\n5. Perform a Depth-First Search (DFS) on the graph starting from each unvisited vertex. This will help in identifying connected components in the graph.\n6. Count the number of connected components in the graph (denoted by variable 'c').\n7. Check if the graph has only one connected component and if the number of edges (m) is equal to n-1. If both conditions are true, it means the graph is a tree.\n8. If the graph is a tree and has only one connected component, it can be represented as a single rooted tree. In this case, print 'FHTAGN!' (indicating that the graph is Cthulhu).\n9. If the graph does not meet the conditions in step 8, print 'NO'.\n\nCOMMENTED CODE:\n```python\nfrom collections import defaultdict\n\n# Create an adjacency list representation of the graph\nv = defaultdict(list)\n\n# Read the input values for the number of vertices (n) and the number of edges (m)\nn, m = map(int, input().split())\n\n# Iterate through each edge in the graph and add the corresponding vertices to each other's adjacency lists\nfor i in range(m):\n    a, b = map(int, input().split())\n    v[a-1].append(b-1)\n    v[b-1].append(a-1)\n\n# Initialize a list 'vis' of size n to keep track of visited vertices during DFS\nvis = [0]*n\n\n# Function to perform DFS on the graph starting from a given node\ndef dfs(node):\n    # Mark the current node as visited\n    vis[node] = 1\n    \n    # Recursively visit all unvisited neighbors of the current node\n    for j in v[node]:\n        if vis[j] == 0:\n            dfs(j)\n\n# Count the number of connected components in the graph\nc = 0\nfor i in range(n):\n    if vis[i] == 0:\n        dfs(i)           # Perform DFS starting from an unvisited node\n        c += 1\n\n# Check if the graph has only one connected component and if the number of edges (m) is equal to n-1\nif c == 1 and n == m:\n    # If both conditions are true, it means the graph is a tree\n    print('FHTAGN!')  # Print 'FHTAGN!' to indicate that the graph is Cthulhu\nelse:\n    print('NO')  # Print 'NO' if the graph does not meet the conditions\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The first line contains the number of vertices (n) and the number of edges (m) in the graph. Then, for each edge, read the source and destination vertices.\n\n2. Construct the graph: Create a graph data structure and add nodes and edges based on the input. Each node represents a vertex in the graph, and each edge represents a connection between two vertices.\n\n3. Find all reachable nodes: Perform a depth-first search (DFS) from an arbitrary node to find all reachable nodes in the graph. This will help determine if the graph is connected.\n\n4. Find cycles: Perform a DFS from each node to find cycles in the graph. A cycle is a path that starts and ends at the same node and passes through at least one edge more than once. Keep track of the length of each cycle.\n\n5. Check if the graph is Cthulhu: Check if the graph meets the conditions to be considered Cthulhu. A graph is Cthulhu if it is connected, has at least three edges, has exactly one cycle, and the length of the cycle is at least three.\n\n6. Print the result: If the graph is Cthulhu, print \"FHTAGN!\", otherwise print \"NO\".\n\nCOMMENTED CODE:\n```python\nclass Node:\n    def __init__(self, n_name):\n        \"\"\"\n        String, list of edges -> node\n        \"\"\"\n        self.name = n_name  # Name of the node\n        self.edges = []  # List of edges connected to this node\n        self.incoming_edges = []  # List of edges pointing to this node\n\n    def __str__(self):\n        string = 'Name :'+ str(self.name) +'\\n'\n        string += 'outcoming edges :'+ '\\n'\n        for edge in self.edges:\n            string += str(edge) + '\\n'\n        return string\n\n    def add_edge(self, edge):\n        \"\"\"\n        edge -> None\n        \"\"\"\n        self.edges.append(edge)  # Add an edge to the list of edges\n\n\nclass Edge:\n    def __init__(self, e_source, e_destination, weight=1):\n        \"\"\"\n        Node, Node, number -> Edge\n        \"\"\"\n        self.source = e_source  # Source node of the edge\n        self.destination = e_destination  # Destination node of the edge\n        self.weight = weight  # Weight of the edge (default is 1)\n\n    def __str__(self):\n        string ='source :'+ str(self.source.name) +'\\n'\n        string += 'destination :'+ str(self.destination.name) +'\\n'\n        string += 'weight :'+ str(self.weight) + '\\n'\n        return string\n\n    def __lt__(self, other):\n        return self.weight < other.weight  # Compare edges based on weight\n\n\nclass Graph:\n    def __init__(self):\n        self.node_list = []  # List of nodes in the graph\n        self.edge_list = []  # List of edges in the graph\n        self.name_to_node = {}  # Dictionary mapping node names to nodes\n\n    def __str__(self):\n        output = \"\"\n        output += \"Nodes : \"\n        for node in self.node_list:\n            output += str(node.name) + \"  \"\n        output += \"\\nEdges : \"\n        for edge in self.edge_list:\n            output += str(edge.source.name) + \"--(\" + str(edge.weight) + \")--\" + str(edge.destination.name) + \"  \"\n        output += \"\\n\"\n        return output\n\n    def add_node(self, node_name):\n        \"\"\"\n        (String or integer) -> Node\n        Adds a node to the graph\n        \"\"\"\n        new_node = Node(node_name)  # Create a new node\n        self.node_list += [new_node]  # Add the node to the list of nodes\n        self.name_to_node[node_name] = new_node  # Add the node to the dictionary\n        return new_node\n\n    def add_edge(self, source_name, dest_name, weight=1):\n        \"\"\"\n        (String or number), (String or number) -> (Edge)\n        Adds an edge between two nodes\n        if the nodes are not there it will create then\n        \"\"\"\n        if source_name not in self.name_to_node:\n            self.add_node(source_name)  # Create the source node if it doesn't exist\n\n        if dest_name not in self.name_to_node:\n            self.add_node(dest_name)  # Create the destination node if it doesn't exist\n\n        source_node = self.name_to_node[source_name]  # Get the source node\n        dest_node = self.name_to_node[dest_name]  # Get the destination node\n        new_edge = Edge(source_node, dest_node, weight)  # Create a new edge\n        source_node.add_edge(new_edge)  # Add the edge to the source node\n        dest_node.incoming_edges += [new_edge]  # Add the edge to the destination node\n        self.edge_list += [new_edge]  # Add the edge to the list of edges\n\n\ndef get_cycles(source, level, levels, cycles):\n    # Mark source as explored\n    levels[source] = level\n\n    # DFS through all of its neighbors\n    for edge in source.edges:\n        next_vertex = edge.destination\n\n        # If it's not explored then DFS it else then it's a cycle\n        if next_vertex not in levels:\n            get_cycles(next_vertex, levels[source] + 1, levels, cycles)\n        else:\n            cycle_length = levels[next_vertex] - levels[source] + 1\n            if cycle_length > 2:  # Check if the cycle length is at least 3\n                cycles.append(abs(cycle_length))  # Add the cycle length to the list of cycles\n\n\ndef get_all_nodes(source, explored_nodes):\n    explored_nodes.add(source)  # Mark the node as explored\n    for edge in source.edges:\n        next_vertex = edge.destination\n        if next_vertex not in explored_nodes:\n            get_all_nodes(next_vertex, explored_nodes)  # Recursively explore the neighbors\n\n\ndef is_Cthulhu(cycles, m, all_reachable):\n    return all_reachable and m >= 3 and len(cycles) == 1 and cycles[0] >= 3  # Check if the graph is Cthulhu\n\n\n# Construct a graph\na = Graph()\nfirst_line = input()\nfirst_line = first_line.split()\nn = int(first_line[0])\nm = int(first_line[1])\n\nfor i in range(n):\n    a.add_node(i + 1)  # Add nodes to the graph\n\nfor i in range(m):\n    line = input()\n    line = line.split()\n    s = int(line[0])\n    t = int(line[1])\n    a.add_edge(s, t)  # Add edges to the graph\n    a.add_edge(t, s)  # Add edges to the graph (undirected graph)\n\ncycles = []\nexplored = {}\nall_reachable_nodes = set()\nif n >= 3:\n    get_all_nodes(a.node_list[0], all_reachable_nodes)  # Find all reachable nodes\n    if len(all_reachable_nodes) == len(a.node_list):\n        for vertex in a.node_list:\n            if vertex not in explored:\n                get_cycles(vertex, 0, explored, cycles)  # Find cycles in the graph\n\nif is_Cthulhu(cycles, m, (len(all_reachable_nodes) == len(a.node_list))):\n    print(\"FHTAGN!\")  # Print \"FHTAGN!\" if the graph is Cthulhu\nelse:\n    print(\"NO\")  # Print \"NO\" otherwise\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and edges (m) from the input.\n2. If n is not equal to m + 1, it means the graph is not connected, so it cannot be a Cthulhu, and we print \"NO\" and exit.\n3. Initialize a parent array to store the parent of each vertex in the Union-Find data structure.\n4. Iterate over each edge in the graph and perform a Union operation on the two vertices connected by the edge.\n5. After processing all edges, iterate over the parent array to count the number of distinct sets (i.e., the number of connected components).\n6. If there is more than one distinct set, it means the graph is not a Cthulhu, so we print \"NO\".\n7. If there is only one distinct set, it means the graph is connected, and we need to check if it contains a cycle.\n8. If the graph contains a cycle, it means the graph is a Cthulhu, so we print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\ndef unionSet(u,v):\n    # Find the roots of the two sets containing u and v\n    up = findSet(u)\n    vp = findSet(v)\n    \n    # If u and v are already in the same set, do nothing\n    if up == vp:\n        return\n    else:\n        # Union the two sets by making the root of one set the parent of the other\n        parent[up] = vp\n        # cnt[vp] += cnt[up]  # This line is commented out because we don't need to count the size of each set\n\ndef findSet(u):\n    # If u is not the root of its set, recursively find the root and update the parent array\n    if parent[u]!= u:\n        parent[u] = findSet(parent[u])\n    return parent[u]\n\n# Read the number of vertices (n) and edges (m) from the input\nn,m = map(int,input().split())\n\n# If n is not equal to m + 1, it means the graph is not connected, so it cannot be a Cthulhu\nif n!= m + 1:\n    print('NO')\n    exit()\n\n# Initialize a parent array to store the parent of each vertex in the Union-Find data structure\nparent = list(range(n+1))\n\n# Iterate over each edge in the graph and perform a Union operation on the two vertices connected by the edge\nfor _ in range(m):\n    u, v = map(int,input().split())\n    unionSet(u,v)  # O(n)\n\n# After processing all edges, iterate over the parent array to count the number of distinct sets\ncnt = 0\nfor i in range(1,n+1):\n    # If u is the root of its set, increment the count\n    if parent[i] == i:\n        cnt += 1\n\n# If there is more than one distinct set, it means the graph is not a Cthulhu\nif cnt > 1:\n    print('NO')\nelse:\n    # If there is only one distinct set, it means the graph is connected, and we need to check if it contains a cycle\n    # However, since we have already checked that the graph is connected and has only one distinct set, we can conclude that it is a Cthulhu\n    print('FHTAGN!')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Create an adjacency list representation of the graph, where each index represents a vertex and the corresponding value is a list of its adjacent vertices.\n3. Check if the graph has exactly one connected component and if it has n-1 edges. If not, it cannot be a Cthulhu graph.\n4. If the graph has exactly one connected component and n-1 edges, check if it can be divided into three or more rooted trees with a simple cycle connecting their roots.\n5. If the graph can be divided into three or more rooted trees with a simple cycle connecting their roots, it is a Cthulhu graph.\n\nCOMMENTED CODE:\n```python\nimport sys\n\n# Function to check if all vertices have been visited\ndef todos_visitados(list):\n    # Return True if all elements in the list are True (i.e., all vertices have been visited)\n    return len(list) == sum(list)\n\n# Function to check if a graph has only one connected component\ndef um_componente(vertices, n):\n    # Initialize a list to keep track of visited vertices\n    vizinhos = [0]\n    # Initialize a list to mark visited vertices\n    visitado = [False] * n\n\n    # Perform DFS traversal\n    while len(vizinhos)!= 0:\n        # Get the next vertex to visit\n        v = vizinhos.pop()\n        # Mark the vertex as visited\n        visitado[v] = True\n\n        # Visit all adjacent vertices\n        for u in vertices[v]:\n            # If the adjacent vertex has not been visited, add it to the list of vertices to visit\n            if not visitado[u]:\n                vizinhos.append(u)\n\n    # Return True if all vertices have been visited\n    return todos_visitados(visitado)\n\n# Main function\ndef main():\n    # Read the input values for the number of vertices (n) and the number of edges (m)\n    n, m = [int(x) for x in input().split()]\n\n    # Create an adjacency list representation of the graph\n    vertices = [[] for _ in range(n)]\n\n    # Read the edges of the graph\n    for _ in range(m):\n        # Get the vertices of the current edge\n        v, u = [int(x) - 1 for x in input().split()]\n        # Add the edge to the adjacency list\n        vertices[v].append(u)\n        vertices[u].append(v)\n\n    # Check if the graph has exactly one connected component and n-1 edges\n    somente_um_ciclo = n == m and um_componente(vertices, n)\n\n    # Print the result\n    print(\"FHTAGN!\") if somente_um_ciclo else print(\"NO\")\n\nif __name__ == '__main__':\n    main()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Initialize the parents and ranks arrays for the Union-Find data structure. The parents array is used to store the parent of each vertex, and the ranks array is used to store the rank of each vertex in the Union-Find tree.\n3. Initialize the count_p variable to store the number of connected components in the graph, which is initially set to n (the number of vertices).\n4. Iterate through each edge in the graph, and for each edge, perform the union operation on the two vertices using the unionSet function.\n5. If the union operation results in a cycle (i.e., the two vertices are already in the same connected component), increment the num_cycle variable.\n6. After iterating through all edges, check if the graph has a single connected component (count_p == 1) and if there is exactly one cycle (num_cycle == 1). If both conditions are met, print \"FHTAGN!\"; otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\ndef findSet(u):\n  # Find the root of the set that u belongs to\n  if parents[u]!= u:\n    # If u is not the root, recursively find the root\n    parents[u] = findSet(parents[u])\n  return parents[u]\n\ndef unionSet(u, v):\n  # Find the roots of the sets that u and v belong to\n  up = findSet(u)\n  vp = findSet(v)\n  \n  # If u and v are already in the same set, return True\n  if up == vp:\n    return True\n  global count_p\n  # Decrement the count of connected components\n  count_p -= 1\n  # Union the two sets based on their ranks\n  if ranks[up] > ranks[vp]:\n    # If the rank of u's set is higher, make v's set a subset of u's set\n    parents[vp] = up\n  elif ranks[up] < ranks[vp]:\n    # If the rank of v's set is higher, make u's set a subset of v's set\n    parents[up] = vp\n  else:\n    # If the ranks are equal, make v's set a subset of u's set and increment the rank of v's set\n    parents[up] = vp\n    ranks[vp] += 1\n  return False\n\n\nn, m = map(int, input().split())\n# Initialize the parents and ranks arrays\nparents = [i for i in range(n)]\nranks = [0 for i in range(n)]\n\nresult = False\n# Initialize the count of connected components and the number of cycles\ncount_p = n\nnum_cycle = 0\n# Iterate through each edge in the graph\nfor i in range(m):\n  x, y = map(int, input().split())\n  # Decrement x and y by 1 to make them 0-indexed\n  x -= 1\n  y -= 1\n  # Perform the union operation on the two vertices\n  has_cycle = unionSet(x, y)\n  # If the union operation results in a cycle, increment the num_cycle variable\n  if has_cycle:\n    result = True\n    num_cycle += 1\n    \n# Check if the graph has a single connected component and exactly one cycle\nif count_p == 1 and result and num_cycle == 1:\n  # If both conditions are met, print \"FHTAGN!\"\n  print(\"FHTAGN!\")\nelse:\n  # Otherwise, print \"NO\"\n  print(\"NO\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices `n` and the number of edges `m` from the input.\n2. Create an adjacency list `t` to represent the graph, where `t[i]` contains the vertices connected to vertex `i`.\n3. Initialize an array `p` to store the vertices with degree 1, which will be the roots of the rooted trees.\n4. Check if there are any vertices with no edges. If so, return 'NO' because the graph is not connected.\n5. While there are vertices in `p`, perform the following steps:\n   - Remove the vertex `a` from `p` and its adjacent vertex `b` from the list of adjacent vertices of `a` and vice versa.\n   - If `b` has only one adjacent vertex, add it to `p`.\n   - If `b` has no adjacent vertices, return 'NO' because the graph is not connected.\n6. Initialize an array `p` to store the vertices with degree 2, which will be the vertices in the cycle.\n7. Check if there are less than 3 vertices in `p` or if any vertex has more than 2 adjacent vertices. If so, return 'NO' because the graph is not a Cthulhu.\n8. Find a cycle in the graph by starting from a vertex in `p` and following the adjacent vertices until we return to the starting vertex.\n9. Check if the length of the cycle is equal to the number of vertices in `p`. If not, return 'NO' because the graph is not a Cthulhu.\n10. If all checks pass, return 'FHTAGN!' because the graph is a Cthulhu.\n\nCOMMENTED CODE:\n```python\ndef f():\n    # Read the number of vertices n and the number of edges m from the input\n    n, m = map(int, input().split())\n    \n    # Create an adjacency list t to represent the graph\n    t = [[] for i in range(n + 1)]\n    \n    # Initialize an array p to store the vertices with degree 1\n    p = [0] * (n + 1)\n    \n    # Read the edges from the input and update the adjacency list t\n    for i in range(m):\n        a, b = map(int, input().split())\n        t[a].append(b)\n        t[b].append(a)\n    \n    # Find the vertices with degree 1 and add them to p\n    p = [a for a in range(1, n + 1) if len(t[a]) == 1]\n    \n    # Check if there are any vertices with no edges\n    if any(len(i) == 0 for i in t[1: ]): \n        # If so, return 'NO' because the graph is not connected\n        return 'NO'\n    \n    # While there are vertices in p, perform the following steps\n    while p:\n        # Initialize an array r to store the new vertices with degree 1\n        r = []\n        \n        # For each vertex a in p\n        for a in p:\n            # Remove the vertex b from the list of adjacent vertices of a and vice versa\n            b = t[a].pop()\n            t[b].remove(a)\n            \n            # If b has only one adjacent vertex, add it to r\n            if len(t[b]) == 1: \n                r.append(b)\n            # If b has no adjacent vertices, return 'NO' because the graph is not connected\n            elif len(t[b]) == 0: \n                return 'NO'\n        \n        # Update p to the new vertices with degree 1\n        p = r\n    \n    # Initialize an array p to store the vertices with degree 2\n    p = [a for a in range(1, n + 1) if len(t[a]) == 2]\n    \n    # Check if there are less than 3 vertices in p or if any vertex has more than 2 adjacent vertices\n    if len(p) < 3: \n        # If so, return 'NO' because the graph is not a Cthulhu\n        return 'NO'\n    if any(len(i) > 2 for i in t[1: ]): \n        # If so, return 'NO' because the graph is not a Cthulhu\n        return 'NO'\n    \n    # Find a cycle in the graph by starting from a vertex in p and following the adjacent vertices until we return to the starting vertex\n    s, a = 0, p[0]\n    while True:\n        # Remove the vertex b from the list of adjacent vertices of a and vice versa\n        b = t[a].pop()\n        t[b].remove(a)\n        \n        # Update a to the new vertex\n        a = b\n        \n        # Increment the length of the cycle\n        s += 1\n        \n        # If we return to the starting vertex, break the loop\n        if a == p[0]: \n            break\n    \n    # Check if the length of the cycle is equal to the number of vertices in p\n    if s!= len(p): \n        # If not, return 'NO' because the graph is not a Cthulhu\n        return 'NO'\n    \n    # If all checks pass, return 'FHTAGN!' because the graph is a Cthulhu\n    return 'FHTAGN!'\nprint(f())\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Initialize an adjacency list representation of the graph, `graph`, with n+1 empty lists.\n3. Initialize a visited array, `visited`, with n+1 elements set to False.\n4. If the number of edges is not equal to n-1, the graph cannot be a tree, so print \"NO\".\n5. Read m pairs of integers representing edges in the graph and add them to the adjacency list.\n6. Perform a depth-first search (DFS) starting from node 1 to count the number of nodes in the connected component containing node 1.\n7. If the count is not equal to n, the graph is not connected, so print \"NO\".\n8. Otherwise, print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\ndef dfs(node):\n    # Initialize a counter for the number of nodes in the subtree rooted at node\n    cnt = 1\n    # Mark node as visited\n    visited[node] = True\n\n    # Iterate over all adjacent nodes of node\n    for adj in graph[node]:\n        # If adjacent node has not been visited, recursively visit it and add its subtree size to the counter\n        if not visited[adj]:\n            cnt += dfs(adj)\n\n    # Return the total number of nodes in the subtree rooted at node\n    return cnt\n\n\n# Read the number of vertices (n) and edges (m) from the input\nn, m = map(int, input().split())\n\n# Initialize an adjacency list representation of the graph, graph, with n+1 empty lists\ngraph = [[] for _ in range(n+1)]\n\n# Initialize a visited array, visited, with n+1 elements set to False\nvisited = [False]*(n+1)\n\n# If the number of edges is not equal to n-1, the graph cannot be a tree, so print \"NO\"\nif m!= n - 1:\n    print(\"NO\")\nelse:\n    # Read m pairs of integers representing edges in the graph and add them to the adjacency list\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    # Perform a depth-first search (DFS) starting from node 1 to count the number of nodes in the connected component containing node 1\n    print(\"NO\" if dfs(1)!= n else \"FHTAGN!\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (n) and the number of edges (m) in the graph.\n2. Initialize an adjacency list representation of the graph (g) and a boolean array (mark) to keep track of visited nodes.\n3. Check if the graph is connected by comparing the number of edges (m) with the number of vertices (n) minus one. If not, the graph is not Cthulhu, so print \"NO\".\n4. Iterate through each edge in the graph and add it to the adjacency list representation.\n5. Perform a depth-first search (DFS) starting from an arbitrary node (0) to mark all connected components in the graph.\n6. Check if all nodes in the graph have been visited. If not, the graph is not Cthulhu, so print \"NO\".\n7. If all nodes have been visited, check if the graph contains a simple cycle by verifying if the mark array contains any False values. If it does, the graph is not Cthulhu, so print \"NO\". Otherwise, print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\n# Read input values for the number of vertices (n) and the number of edges (m)\nn, m = [int(i) for i in input().split()]\n\n# Initialize an adjacency list representation of the graph (g) and a boolean array (mark)\ng = [[] for i in range(n)]\nmark = [False] * n\n\n# Check if the graph is connected\nif n!= m + 1:  # A connected graph with n vertices has n-1 edges\n    print(\"NO\")  # If not connected, the graph is not Cthulhu\n\n# Iterate through each edge in the graph and add it to the adjacency list representation\nfor i in range(m):\n    v, u = [int(x)-1 for x in input().split()]  # Subtract 1 to match 0-based indexing\n    g[v].append(u)\n    g[u].append(v)  # Since the graph is undirected, add edges in both directions\n\n# Perform a depth-first search (DFS) starting from an arbitrary node (0) to mark all connected components\ndef dfs(node):\n    mark[node] = True  # Mark the current node as visited\n    for u in g[node]:\n        if mark[u] is False:  # If the adjacent node has not been visited\n            dfs(u)  # Recursively visit the adjacent node\n\ndfs(0)  # Start the DFS from node 0\n\n# Check if all nodes in the graph have been visited\nans = True\nfor i in range(1, n):\n    if mark[i] is False:  # If any node has not been visited\n        ans = False  # The graph is not Cthulhu\n\n# Check if the graph contains a simple cycle\nif ans is True:\n    print(\"FHTAGN!\")  # If all nodes have been visited and no simple cycle is found, the graph is Cthulhu\nelse:\n    print(\"NO\")  # Otherwise, the graph is not Cthulhu\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Initialize a list (vis) of size n to keep track of visited vertices during the depth-first search (DFS).\n3. Create an adjacency list (adj) to represent the graph, where each index represents a vertex and its corresponding value is a list of adjacent vertices.\n4. Read the edges of the graph from the user and update the adjacency list accordingly.\n5. Perform a DFS traversal of the graph to find connected components. If a vertex is not visited, start a new DFS traversal from that vertex.\n6. Count the number of connected components (cnt) in the graph.\n7. Check if the graph has a single connected component (cnt == 1) and if the number of edges (m) is equal to n - 1 (i.e., the graph is a tree). If both conditions are true, print \"FHTAGN!\".\n8. Otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\n# Function to perform DFS traversal from a given vertex\ndef dfs(u):\n    # Mark the current vertex as visited\n    vis[u] = 1\n    # Recur for all adjacent vertices of the current vertex\n    for v in adj[u]:\n        if vis[v] == 0:\n            dfs(v)\n\n# Read input values for the number of vertices (n) and the number of edges (m)\nn, m = map(int, input().split())\n\n# Initialize a list (vis) to keep track of visited vertices\nvis = [0] * n\n\n# Create an adjacency list (adj) to represent the graph\nadj = [[] for w in range(n)]\n\n# Read edges of the graph from the user and update the adjacency list\nfor i in range(m):\n    u, v = map(int, input().split())\n    u -= 1  # Adjust vertex indices to 0-based\n    v -= 1\n    adj[u].append(v)\n    adj[v].append(u)\n\n# Initialize a counter for connected components\ncnt = 0\n\n# Perform DFS traversal to find connected components\nfor i in range(0, n - 1):\n    if vis[i] == 0:\n        dfs(i)\n        cnt += 1\n\n# Check if the graph has a single connected component and is a tree\nif cnt == 1 and n == m:\n    print('FHTAGN!')\nelse:\n    print('NO')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Initialize an adjacency list representation of the graph (g) and a set to keep track of visited vertices (b).\n3. Read the edges of the graph from the input and add them to the adjacency list.\n4. Perform a depth-first search (DFS) starting from an arbitrary vertex (0) to find all connected components in the graph.\n5. During the DFS, keep track of the number of cycles found (res) and remove edges from the adjacency list to avoid revisiting vertices.\n6. After the DFS, check if all vertices have been visited (len(b) == n) and if exactly one cycle has been found (res == 1).\n7. If both conditions are met, print \"FHTAGN!\", otherwise print \"NO\".\n\nCOMMENTED CODE:\n```python\ndef dfs(num, av):  # Perform depth-first search starting from vertex num\n    global res  # Access the global variable res\n    b.add(num)  # Mark vertex num as visited\n    for v in g[num]:  # Iterate over all neighbors of vertex num\n        if v!= av:  # Avoid revisiting the parent vertex\n            if v in b:  # If vertex v has already been visited\n                res += 1  # Increment the cycle count\n                g[v].remove(num)  # Remove the edge to avoid revisiting\n            else:  # If vertex v has not been visited\n                b.add(v)  # Mark vertex v as visited\n                dfs(v, num)  # Recursively visit vertex v\n\nn, m = map(int, input().split())  # Read the number of vertices and edges\ng, b, res = [[] for _ in range(n)], set(), 0  # Initialize the graph and visited set\nfor _ in range(m):  # Read the edges of the graph\n    u, v = map(int, input().split())\n    g[u-1].append(v-1)  # Add edge (u, v) to the graph\n    g[v-1].append(u-1)  # Add edge (v, u) to the graph (undirected graph)\n\ndfs(0, 0)  # Perform DFS starting from vertex 0\nif len(b) == n and res == 1:  # Check if all vertices have been visited and exactly one cycle has been found\n    print(\"FHTAGN!\")  # Print \"FHTAGN!\" if the graph is Cthulhu\nelse:\n    print(\"NO\")  # Print \"NO\" otherwise\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the first line.\n2. Initialize an empty dictionary (g) to represent the graph, where each key is a vertex and its corresponding value is an empty list to store its adjacent vertices.\n3. Iterate through each edge in the graph, and for each edge, add the adjacent vertices to the corresponding lists in the graph dictionary.\n4. Initialize a list (visited) of size n+1 with all elements set to False, where the extra element at index 0 will be used to track the visited status of the root vertex.\n5. Perform a depth-first search (DFS) traversal of the graph starting from vertex 1, marking each visited vertex as True in the visited list.\n6. If any vertex remains unvisited after the DFS traversal, it means the graph is not connected, and the output should be \"NO\".\n7. Check if the number of edges (b) is equal to n-1. If not, it means the graph is not a tree, and the output should be \"NO\".\n8. If all previous checks pass, it means the graph is a Cthulhu, and the output should be \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\n# Read the input values for the number of vertices (n) and the number of edges (m)\na, b = list(map(int, input().split(' ')))\n\n# Initialize an empty dictionary (g) to represent the graph\ng = {}\nfor i in range(1, a+1):\n    g[i] = []  # Initialize an empty list for each vertex\n\n# Iterate through each edge in the graph and add the adjacent vertices to the corresponding lists\nfor i in range(b):\n    x, y = map(int, input().split(' '))  # Read the edge vertices\n    g[x].append(y)  # Add y to the list of adjacent vertices for x\n    g[y].append(x)  # Add x to the list of adjacent vertices for y\n\n# Initialize a list (visited) to track the visited status of each vertex\nvisited = [True] + [False] * a  # Initialize all elements to False, except the first one which is set to True for the root vertex\n\n# Perform a depth-first search (DFS) traversal of the graph starting from vertex 1\ndef dfs(graph, start):\n    visited[start] = True  # Mark the current vertex as visited\n    for i in graph[start]:\n        if not visited[i]:\n            dfs(graph, i)  # Recursively visit the unvisited adjacent vertices\n\ndfs(g, 1)  # Start the DFS traversal from vertex 1\n\n# Check if any vertex remains unvisited after the DFS traversal\nif False in visited:\n    print(\"NO\")  # Output \"NO\" if the graph is not connected\n    quit()\n\n# Check if the number of edges (b) is equal to n-1\nif a!= b:\n    print(\"NO\")  # Output \"NO\" if the graph is not a tree\n    quit()\n\n# Output \"FHTAGN!\" if the graph is a Cthulhu\nprint(\"FHTAGN!\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Check if the graph is valid by ensuring it has at least 3 vertices and that the number of edges is equal to the number of vertices minus one (n-1) for a tree, or that it can be divided into multiple trees connected by a cycle.\n3. Create an adjacency list representation of the graph, where each index represents a vertex and its corresponding value is a list of its adjacent vertices.\n4. Perform a Depth-First Search (DFS) traversal of the graph starting from an arbitrary vertex (in this case, vertex 1).\n5. Check if the DFS traversal visits all vertices in the graph. If it does, it means the graph is connected and can be divided into multiple trees connected by a cycle.\n6. If the graph is connected, print \"FHTAGN!\" indicating that it is a Cthulhu graph. Otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\nn, m = map(int, input().split())  # Read input values for number of vertices and edges\n\n# Check if the graph is valid\nif n < 3 or n!= m:  # Minimum 3 vertices for a cycle\n    print(\"NO\")  # All vertices must have an edge\n\nelse:\n    # Create an adjacency list representation of the graph\n    V = []  # Adjacency list\n    S = []  # Stack for DFS traversal\n    for i in range(n+1):  # Initialize adjacency list for each vertex\n        V.append([])\n\n    # Populate the adjacency list\n    for j in range(m):\n        x, y = map(int, input().split())  # Read edge between vertices x and y\n        V[x].append(y)  # Connection from x to y\n        V[y].append(x)  # Connection from y to x\n\n    # Perform DFS traversal starting from vertex 1\n    def DFS(a):\n        S.append(a)  # Mark vertex a as visited\n        for v in V[a]:  # Iterate through adjacent vertices\n            if not v in S:  # If adjacent vertex is not visited\n                DFS(v)  # Recursively visit the adjacent vertex\n\n    DFS(1)  # Start DFS traversal from vertex 1\n\n    # Check if the DFS traversal visits all vertices\n    if len(S) == n:\n        print(\"FHTAGN!\")  # Graph is connected and can be divided into multiple trees connected by a cycle\n    else:\n        print(\"NO\")  # Graph is not connected or cannot be divided into multiple trees connected by a cycle\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and edges (m) from the input.\n2. If the number of edges is not equal to n-1, it means the graph is not connected, so it cannot be a Cthulhu, and we print \"NO\".\n3. Create a UnionFind data structure to keep track of connected components in the graph.\n4. Iterate over each edge in the graph and use the UnionFind union method to merge the two vertices into the same connected component.\n5. After processing all edges, iterate over each vertex and use the UnionFind find method to find its root. If a vertex is its own root, it means it is in a separate connected component, so we increment the counter.\n6. If the counter is equal to 1, it means the graph consists of a single connected component, which is a necessary but not sufficient condition for it to be a Cthulhu. We need to check if this component is a cycle or a tree.\n7. To check if the component is a cycle or a tree, we can use a depth-first search (DFS) or breadth-first search (BFS) algorithm. If the component is a tree, it means the graph is not a Cthulhu, and we print \"NO\". Otherwise, we print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\nclass UnionFind:\n  def __init__(self, n):\n    # Initialize the parent array with each vertex as its own parent\n    self.parent = [i for i in range(n)]\n    # Initialize the rank array with all vertices having rank 0\n    self.rank = [0 for i in range(n)]\n\n  def union(self, u, v):\n    # Find the roots of the two vertices\n    up = self.find(u)\n    vp = self.find(v)\n\n    # If the two vertices are already in the same connected component, do nothing\n    if up == vp:\n      return\n    \n    # Merge the two connected components by making one root the parent of the other\n    if self.rank[up] == self.rank[vp]:\n      # If the ranks are equal, make the root with the smaller index the parent\n      self.parent[up] = vp\n      # Increment the rank of the new parent\n      self.rank[vp] += 1\n    elif self.rank[up] < self.rank[vp]:\n      # If the rank of up is less than the rank of vp, make vp the parent\n      self.parent[up] = vp\n    else:\n      # If the rank of vp is less than the rank of up, make up the parent\n      self.parent[vp] = up\n  \n  def find(self, u):\n    # If the vertex is not its own parent, recursively find its root\n    if u!= self.parent[u]:\n      self.parent[u] = self.find(self.parent[u])\n    \n    # Return the root of the vertex\n    return self.parent[u]\n\ndef main():\n  \n  # Read the number of vertices and edges from the input\n  n, m = map(int, input().split())\n\n  # If the number of edges is not equal to n-1, the graph is not connected, so it cannot be a Cthulhu\n  if m!= n-1:\n    print('NO')\n    return\n\n  # Create a UnionFind data structure to keep track of connected components\n  uf = UnionFind(n)\n\n  # Iterate over each edge in the graph and merge the two vertices into the same connected component\n  for i in range(m):\n    u, v = map(lambda x: int(x) - 1, input().split())\n    uf.union(u, v)\n  \n  # Initialize a counter to count the number of connected components\n  counter = 0\n  # Iterate over each vertex and find its root\n  for i in range(n):\n    if i == uf.find(i):\n      # If a vertex is its own root, it means it is in a separate connected component, so increment the counter\n      counter += 1\n  \n  # If the counter is equal to 1, it means the graph consists of a single connected component, which is a necessary but not sufficient condition for it to be a Cthulhu\n  print('FHTAGN!' if counter == 1 else 'NO')\n\nmain()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Create an adjacency list representation of the graph, where each index i in the list represents a vertex, and the value at index i is a list of its neighboring vertices.\n3. Initialize two arrays, a and b, of size n+1, to keep track of the DFS traversal and the parent of each vertex, respectively. Initialize c to 0, which will be used to count the number of cycles.\n4. Define a recursive function, func(n), that performs a depth-first search (DFS) traversal of the graph, starting from vertex n. During the traversal, update the arrays a and b accordingly.\n5. Call the func(1) function to start the DFS traversal from vertex 1.\n6. After the DFS traversal, check if there are any cycles in the graph by verifying if c is greater than 1 or if there are any vertices that have not been visited (i.e., a[i] == 0 for any i).\n7. If there are any cycles or unvisited vertices, print \"NO\". Otherwise, print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\nn, m = map(int, input().split())  # Read the number of vertices and edges\nlst = [[] for i in range(n + 1)]  # Create an adjacency list representation of the graph\n\n# Populate the adjacency list\nfor i in range(m):\n    x, y = map(int, input().split())\n    lst[x].append(y)  # Add y to the list of neighbors of x\n    lst[y].append(x)  # Add x to the list of neighbors of y\n\n# Initialize arrays a and b to keep track of DFS traversal and parent of each vertex\na = [0] * (n + 1)\nb = [0] * (n + 1)\nc = 0  # Initialize cycle count to 0\n\n# Define a recursive function to perform DFS traversal\ndef func(n):\n    global a, b, c, lst  # Access global variables\n    a[n] = 1  # Mark vertex n as visited\n    for j in lst[n]:  # Iterate over the neighbors of vertex n\n        if a[j] == 1 and b[n]!= j:  # If j is visited and not a child of n\n            c += 1  # Increment cycle count\n        if not a[j]:  # If j is not visited\n            b[j] = n  # Set parent of j to n\n            func(j)  # Recursively visit j\n    a[n] = 2  # Mark vertex n as fully visited\n\n# Start DFS traversal from vertex 1\nfunc(1)\n\n# Check for cycles or unvisited vertices\nif c > 1 or 0 in a[1:]:  # If there are cycles or unvisited vertices\n    print(\"NO\")  # Print \"NO\"\nelse:\n    print(\"FHTAGN!\")  # Otherwise, print \"FHTAGN!\"\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input: The first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph. Each of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y.\n2. Create an adjacency list representation of the graph: For each vertex, store its adjacent vertices in a list.\n3. Perform a depth-first search (DFS) to find a simple cycle in the graph. If no cycle is found, the graph is not Cthulhu.\n4. If a cycle is found, mark all vertices in the cycle as visited and perform another DFS to find rooted trees. If any vertex is not visited during this DFS, the graph is not Cthulhu.\n5. If all vertices are visited, check if the graph can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle. If it can, the graph is Cthulhu; otherwise, it is not.\n\nCOMMENTED CODE:\n```python\nfrom __future__ import print_function\nimport sys\nfrom collections import *\nfrom heapq import *\nfrom functools import *\nimport re\nfrom itertools import *\n\nINF=float(\"inf\")\nNINF=float(\"-inf\")\n\ntry:\n    input=raw_input\nexcept:\n    pass\n\ndef read_string():\n    return input()\n\ndef read_string_line():\n    return [x for x in input().split(\" \")]\n\ndef read_int_line():\n    return [int(x) for x in input().split(\" \")]\n\ndef read_int():\n    return int(input())\n\nversion=2\nif version==1:\n    n,m=read_int_line()\n    adjs=[[] for _ in range(n)]\n    for _ in range(m):\n        a,b=read_int_line()\n        adjs[a-1].append(b-1)\n        adjs[b-1].append(a-1)\n    degs=[-1]*n\n    st=[]\n    circle=[]\n    def dfs(x, pre,deg):\n        # Perform DFS to find a simple cycle\n        degs[x]=deg\n        st.append(x)\n        for to in adjs[x]:\n            if to==pre:continue\n            if degs[to]==-1:\n                # If a new vertex is found, recursively call dfs\n                if dfs(to,x,deg+1):\n                    # If a cycle is found, backtrack and mark all vertices in the cycle as visited\n                    st.pop()\n                    return True\n            else:\n                # If a vertex is already visited, check if it's part of the current cycle\n                i=st.index(to)\n                assert not circle\n                circle.extend(st[i:])\n                st.pop()\n                return True\n        st.pop()\n        return False\n\n    edges=set()\n    def dfs2(x,pre,deg):\n        # Perform DFS to find rooted trees\n        #print(\"dfs2 %d, from %d, deg:%d, degs:%s\"%(x,pre,deg,degs))\n        degs[x]=deg\n        for to in adjs[x]:\n            if to==pre:continue\n            if (x,to) in edges:continue\n            if degs[to]!= -1:\n                # If a vertex is already visited, return False\n                return False\n            if not dfs2(to,x,deg+1):\n                # If a cycle is found, return False\n                return False\n        return True\n\n    dfs(0,-1,0)\n\n    if not circle:\n        # If no cycle is found, print \"NO\"\n        print(\"NO\") \n    else:\n        # Mark all vertices in the cycle as visited\n        degs[:]=[-1]*n\n        for i, a in enumerate(circle):\n            b=circle[(i+1)%len(circle)]\n            edges.add((a,b))\n            edges.add((b,a))\n        for a in circle:\n            if degs[a]!=-1:\n                # If a vertex is already visited, print \"NO\"\n                print(\"NO\")\n                break\n            if not dfs2(a,-1,0):\n                # If a cycle is found, print \"NO\"\n                print(\"NO\")\n                break\n        else:\n            # If all vertices are visited, check if the graph can be represented as a set of three or more rooted trees\n            if -1 in degs:\n                # If any vertex is not visited, print \"NO\"\n                print(\"NO\")\n            else:\n                # If the graph can be represented as a set of three or more rooted trees, print \"FHTAGN!\"\n                print(\"FHTAGN!\")\n\n\n\nelse:\n    n,m=read_int_line()\n    if n<3 or m!=n:\n        # If the graph has less than 3 vertices or the number of edges is not n-1, print \"NO\"\n        print(\"NO\")\n        exit()\n    adjs=[[] for _ in range(n)]\n    for _ in range(m):\n        a,b=read_int_line()\n        adjs[a-1].append(b-1)\n        adjs[b-1].append(a-1)\n    vis=set() \n    def dfs(x):\n        # Perform DFS to find all connected components\n        vis.add(x)\n        for y in adjs[x]:\n            if y not in vis:\n                dfs(y)\n    dfs(0)\n    if len(vis)==n:\n        # If all vertices are visited, print \"FHTAGN!\"\n        print(\"FHTAGN!\")\n    else:\n        # If not all vertices are visited, print \"NO\"\n        print(\"NO\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Create an adjacency list representation of the graph, where each index represents a vertex and its corresponding value is a list of its adjacent vertices.\n3. Perform a depth-first search (DFS) traversal of the graph starting from an arbitrary vertex (in this case, vertex 1). This will help identify all connected components in the graph.\n4. Check if the number of vertices is less than 3 or if the number of edges is not equal to n-1 (which would indicate a tree structure). If either condition is true, the graph is not a Cthulhu graph.\n5. Check if the number of visited vertices during the DFS traversal is equal to the total number of vertices. If not, the graph is not connected, and hence, it's not a Cthulhu graph.\n6. If all conditions are met, print \"FHTAGN!\" to indicate that the graph is a Cthulhu graph. Otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\n# Read the input values for the number of vertices (n) and the number of edges (m) from the user.\nn, m = map(int, input().split())\n\n# Create an adjacency list representation of the graph.\na = [[] for _ in range(n + 1)]  # Initialize an empty list for each vertex\nvis = []  # Initialize an empty list to keep track of visited vertices\n\n# Read the edges of the graph and update the adjacency list.\nfor _ in range(m):\n    x, y = map(int, input().split())  # Read the edge (x, y)\n    a[x].append(y)  # Add y to the list of adjacent vertices of x\n    a[y].append(x)  # Add x to the list of adjacent vertices of y\n\n# Perform a depth-first search (DFS) traversal of the graph starting from an arbitrary vertex (in this case, vertex 1).\ndef dfs(x):\n    # Mark the current vertex as visited.\n    vis.append(x)\n    \n    # Recursively visit all unvisited adjacent vertices.\n    for z in a[x]:\n        if not (z in vis):  # Check if the adjacent vertex has not been visited yet\n            dfs(z)  # Recursively visit the adjacent vertex\n\n# Start the DFS traversal from vertex 1.\ndfs(1)\n\n# Check if the graph is a Cthulhu graph.\nif n < 3 or n!= m or len(vis)!= n:  # Check if the number of vertices is less than 3 or if the number of edges is not equal to n-1 or if the number of visited vertices is not equal to the total number of vertices\n    print(\"NO\")  # Print \"NO\" if the graph is not a Cthulhu graph\nelse:\n    print(\"FHTAGN!\")  # Print \"FHTAGN!\" if the graph is a Cthulhu graph\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices `n` and the number of edges `m` from the first line.\n2. Create an adjacency list representation of the graph using the input edges.\n3. Perform a depth-first search (DFS) traversal of the graph to mark all visited vertices.\n4. Check if all vertices have been visited. If not, return 'NO' as the graph is not connected.\n5. If the graph is connected, check if the number of edges `m` is equal to `n - 1`. If so, return 'FHTAGN!' as the graph is a tree.\n6. If the graph is connected but not a tree, it must be a cycle. Check if the graph can be partitioned into three or more rooted trees connected by a simple cycle.\n7. If the graph can be partitioned as described, return 'FHTAGN!'. Otherwise, return 'NO'.\n\nCOMMENTED CODE:\n```python\nfrom collections import defaultdict\nfrom typing import List, Tuple\n\n\ndef solve(n: int, m: int, adj: List[Tuple[int, int]]) -> str:\n    # Initialize a visited array to keep track of visited vertices\n    visited = [0] * n\n    \n    # Create an adjacency list representation of the graph\n    graph = defaultdict(list)  # type: Dict[int, List[int]]\n    for u, v in adj:\n        # Add edges to the adjacency list\n        graph[u - 1].append(v - 1)\n        graph[v - 1].append(u - 1)\n    \n    # Perform a DFS traversal to mark all visited vertices\n    stack = [0]\n    while stack:\n        curr_node = stack.pop()\n        visited[curr_node] = 1\n        # Explore all adjacent vertices\n        for adj_node in graph[curr_node]:\n            if not visited[adj_node]:\n                stack.append(adj_node)\n    \n    # Check if all vertices have been visited\n    if sum(visited)!= n:\n        # If not, return 'NO' as the graph is not connected\n        return 'NO'\n    \n    # If the graph is connected, check if it's a tree\n    elif n == m:\n        # If the number of edges is equal to n - 1, return 'FHTAGN!' as the graph is a tree\n        return 'FHTAGN!'\n    \n    # If the graph is connected but not a tree, it must be a cycle\n    else:\n        # Check if the graph can be partitioned into three or more rooted trees connected by a simple cycle\n        # This step is not explicitly implemented in the provided code, but it's a crucial part of the solution\n        # For the sake of simplicity, we'll assume this step is already implemented and returns a boolean value\n        # is_cthulhu = is_cthulhu_graph(graph)\n        # if is_cthulhu:\n        #     return 'FHTAGN!'\n        # else:\n        #     return 'NO'\n        # Since the provided code doesn't implement this step, we'll return 'NO' for now\n        return 'NO'\n\n\nn, m = list(map(int, input().split()))\nadj = [list(map(int, input().split())) for _ in range(m)]\n\nprint(solve(n, m, adj))\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input: The first line contains the number of vertices `n` and the number of edges `m` of the graph. Each of the following `m` lines contains a pair of integers `x` and `y`, indicating an edge between vertices `x` and `y`.\n2. Create an adjacency list representation of the graph: Use a dictionary `adj` to store the edges of the graph, where `adj[i]` contains the vertices connected to vertex `i`.\n3. Perform a depth-first search (DFS) to find connected components in the graph: Initialize an array `v` to keep track of visited vertices. Iterate through each vertex `i` in the graph. If `i` has not been visited, perform a DFS from `i` to find all connected vertices and add them to a component `cmp`.\n4. Check if each component is a tree: For each component `cmp`, calculate the total number of edges `s` in the component. If `s` is equal to `len(cmp) - 1`, the component is a tree.\n5. Check if the graph can be represented as a set of rooted trees connected by a simple cycle: If the graph has more than one component, it cannot be represented as a set of rooted trees connected by a simple cycle. If any component has more than two vertices and is not a tree, the graph cannot be represented as a set of rooted trees connected by a simple cycle. If all components are trees and there is only one component, the graph can be represented as a set of rooted trees connected by a simple cycle.\n\nCOMMENTED CODE:\n```python\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nfrom collections import defaultdict\n\n# Read the input\nn, m = map(int, input().split())  # number of vertices and number of edges\nadj = defaultdict(list)  # adjacency list representation of the graph\n\n# Create an adjacency list representation of the graph\nfor i in range(m):\n    x, y = map(int, input().split())  # edge between vertices x and y\n    adj[x].append(y)\n    adj[y].append(x)\n\n# Perform a depth-first search to find connected components in the graph\nok = False  # flag to indicate if the graph can be represented as a set of rooted trees connected by a simple cycle\ncmps = []  # list of connected components\nv = [0]*(n+1)  # array to keep track of visited vertices\n\nfor i in range(1, 1+n):\n    if not v[i]:\n        q = [i]  # queue for DFS\n        cmp = []  # current connected component\n        while q:\n            e = q.pop()  # current vertex\n            if not v[e]:\n                cmp.append(e)  # add current vertex to the component\n                v[e] = 1  # mark current vertex as visited\n                \n            for j in adj[e]:\n                if not v[j]:\n                    q.append(j)  # add adjacent vertex to the queue\n                    \n        cmps.append(cmp)  # add the component to the list of components\n\n# Check if each component is a tree\nfor i in cmps:\n    if len(i) > 2:\n        s = 0  # total number of edges in the component\n        for j in i:\n            s += len(adj[j])  # count the number of edges incident to each vertex\n        s //= 2  # divide by 2 to get the total number of edges\n        if s == len(i) - 1:  # if the total number of edges is equal to the number of vertices minus 1, the component is a tree\n            ok = True\n\n# Check if the graph can be represented as a set of rooted trees connected by a simple cycle\nprint(\"FHTAGN!\" if ok and len(cmps)==1 else \"NO\")  # print the result\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Initialize an empty graph with n nodes, where each node is an instance of the Node class.\n3. Iterate through each edge in the graph, and for each edge, perform a union operation on the two nodes it connects.\n4. During the union operation, check if the two nodes belong to different connected components. If they do, increment the count of edges and update the parent node and rank of the nodes accordingly.\n5. If the union operation results in a cycle, increment the count of cycles.\n6. After processing all edges, check if the graph has exactly one cycle and if the count of edges is equal to n - 1. If both conditions are met, the graph is a Cthulhu graph, and print \"FHTAGN!\". Otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\nfrom collections import defaultdict\n\n# Read the input values for the number of vertices (n) and the number of edges (m) from the user.\nn, m = map(int, input(\"\").split())\n\n# Initialize an empty graph with n nodes, where each node is an instance of the Node class.\nclass Graph():\n    def __init__(self):\n        # Create a dictionary to store the nodes, where each key is a node ID and the value is a Node object.\n        self.nodes = {i: Node(i) for i in range(1, n + 1)}\n\n    # Find the root node of a given node.\n    def find(self, i):\n        # If the node's parent ID is not itself, recursively find the root node.\n        if self.nodes[i].parent_id!= i:\n            # Get the new parent ID by recursively calling the find method.\n            new_parent_id = self.find(self.nodes[i].parent_id)\n            # Update the node's parent ID to the new parent ID.\n            self.nodes[i].change_parent_id(new_parent_id)\n        # Return the root node's ID.\n        return self.nodes[i].parent_id\n\n    # Perform a union operation on two nodes.\n    def union(self, i, j, count, is_cycle=False):\n        # Find the root nodes of the two nodes.\n        i_parent_id = self.find(i)\n        j_parent_id = self.find(j)\n        # If the two nodes belong to different connected components, perform the union operation.\n        if i_parent_id!= j_parent_id:\n            # Decrement the count of edges.\n            count -= 1\n            # Update the parent node and rank of the nodes accordingly.\n            if self.nodes[i_parent_id].rank > self.nodes[j_parent_id].rank:\n                self.nodes[j_parent_id].change_parent_id(i_parent_id)\n            else:\n                self.nodes[i_parent_id].change_parent_id(j_parent_id)\n                # If the ranks of the two nodes are equal, increment the rank of the new parent node.\n                if self.nodes[i_parent_id].rank == self.nodes[j_parent_id].rank:\n                    self.nodes[i_parent_id].change_rank(self.nodes[j_parent_id].rank + 1)\n            # Return the updated count and a flag indicating whether a cycle was formed.\n            return is_cycle, count\n        # If the two nodes belong to the same connected component, a cycle was formed.\n        is_cycle = True\n        # Return the updated count and the flag indicating whether a cycle was formed.\n        return is_cycle, count\n\n\n# Define a Node class to represent a node in the graph.\nclass Node():\n    def __init__(self, id):\n        # Initialize the node's ID, parent ID, and rank.\n        self.id = id\n        self.parent_id = id\n        self.rank = 0\n\n    # Update the node's parent ID.\n    def change_parent_id(self, new_parent_id):\n        self.parent_id = new_parent_id\n\n    # Update the node's rank.\n    def change_rank(self, new_rank):\n        self.rank = new_rank\n\n\n# Create an instance of the Graph class.\ngraph = Graph()\n# Initialize the count of cycles and edges.\nnum_cycles = 0\ncount = n\n# Iterate through each edge in the graph.\nfor i in range(m):\n    # Read the edge's endpoints from the user.\n    a, b = map(int, input(\"\").split())\n    # Perform a union operation on the two nodes.\n    is_cycle, count = graph.union(a, b, count)\n    # If a cycle was formed, increment the count of cycles.\n    if is_cycle:\n        num_cycles += 1\n\n\n# Check if the graph is a Cthulhu graph.\nif num_cycles == 1 and count == 1:\n    # If the graph is a Cthulhu graph, print \"FHTAGN!\".\n    print('FHTAGN!')\nelse:\n    # Otherwise, print \"NO\".\n    print('NO')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The first line contains the number of vertices `n` and the number of edges `m`. Each subsequent line contains a pair of integers representing an edge between two vertices.\n2. Initialize an empty list `E` to store the edges and a set `V` to store all vertices.\n3. Iterate through each edge and add it to the list `E`. Also, remove the vertices of the current edge from the set `V`.\n4. Initialize a list `sets` to store the connected components of the graph, where each component is a set of vertices.\n5. Define a function `getSet(vertex)` to find the set that contains the given vertex.\n6. Iterate through each edge and check if the two vertices belong to different sets. If they do, it means an edge connects two different components, so increment the `in_tree` counter and merge the two sets.\n7. After iterating through all edges, check if the number of edges that connected different components (`in_tree`) is equal to `m - 1` and if the set `V` is empty. If both conditions are met, it means the graph can be represented as a set of rooted trees connected by a simple cycle, so print \"FHTAGN!\". Otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\n# Read the input\nv, e = map(int, input().split())  # number of vertices and edges\nE, V = [], set(range(1, v+1))  # initialize empty list for edges and set for vertices\n\n# Iterate through each edge and add it to the list E, removing the vertices from V\nfor _ in range(e):\n    a, b = map(int, input().split())  # read edge vertices\n    E.append([a, b])  # add edge to list E\n    if a in V: V.remove(a)  # remove vertex a from V\n    if b in V: V.remove(b)  # remove vertex b from V\n\n# Initialize list sets to store connected components\nsets = [set([vertex]) for vertex in V]  # initialize each component as a set containing a single vertex\n\n# Define function getSet(vertex) to find the set containing the given vertex\ndef getSet(vertex):\n    for s in sets:  # iterate through each set\n        if vertex in s: return s  # return the set containing the vertex\n\n# Initialize counter in_tree to count edges connecting different components\nin_tree = 0\n\n# Iterate through each edge\nfor edge in E:\n    a, b = edge  # read edge vertices\n    sa, sb = getSet(a), getSet(b)  # find sets containing vertices a and b\n\n    # Check if vertices a and b belong to different sets\n    if sa.isdisjoint(sb):\n        in_tree += 1  # increment in_tree counter\n        sa |= sb  # merge sets sa and sb\n        sets.remove(sb)  # remove set sb from list sets\n\n# Check if the graph can be represented as a set of rooted trees connected by a simple cycle\nprint('FHTAGN!' if in_tree == len(E) - 1 and len(V) == 0 else 'NO')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The number of vertices `n` and the number of edges `m` of the graph, and then read `m` pairs of integers representing the edges.\n2. Create an adjacency list representation of the graph, where each vertex is associated with a set of its neighboring vertices.\n3. Find a simple cycle in the graph using a depth-first search (DFS) approach. This cycle will be used as the root cycle for further analysis.\n4. Perform a DFS from each vertex in the root cycle to find all connected components in the graph. If any vertex is not visited, it means the graph is not a Cthulhu graph.\n5. If all vertices are visited, check if the number of visited vertices is equal to the total number of vertices in the graph. If not, the graph is not a Cthulhu graph.\n\nCOMMENTED CODE:\n```python\n# Read the input: the number of vertices n and the number of edges m\nread = lambda: map(int, input().split())\nn, m = read()\n\n# Create an adjacency list representation of the graph\ngraph = [set() for _ in range(n + 1)]\nfor __ in range(m):\n  # Read an edge and add it to the adjacency list\n  u, v = read()\n  graph[u].add(v)\n  graph[v].add(u)\n\n# Function to find a simple cycle in the graph using DFS\ndef find_cycle(start):\n  # Initialize parents array and stack for DFS\n  parents, stack = [0] * (n + 1), [(start, -1)]\n  while stack:\n    # Pop a vertex and its parent from the stack\n    vertex, parent = stack.pop()\n    # Mark the vertex as visited by setting its parent\n    parents[vertex] = parent\n    # Explore neighbors of the vertex\n    for neighbour in graph[vertex]:\n      # Skip the parent vertex\n      if neighbour!= parent:\n        # If the neighbor is already visited, it means a cycle is found\n        if parents[neighbour]:\n          # Reconstruct the cycle by backtracking from the neighbor to the start vertex\n          cycle = set()\n          cycle.add(neighbour)\n          while vertex!= neighbour:\n            cycle.add(vertex)\n            vertex = parents[vertex]\n          return cycle\n        # Add the neighbor to the stack for further exploration\n        stack.append((neighbour, vertex))\n  # If no cycle is found, return an empty set\n  return set()\n\n# Find a simple cycle in the graph\ncyc = find_cycle(1)\nif not cyc:\n  # If no cycle is found, print \"NO\" and exit\n  print('NO')\n  exit()\n\n# Function to perform DFS from each vertex in the root cycle\ndef dfs():\n  # Initialize a set to keep track of visited vertices\n  visited = set(cyc)\n  # Perform DFS from each vertex in the root cycle\n  for start in cyc:\n    # Initialize a stack for DFS\n    stack = [(v, start) for v in graph[start] if v not in cyc]\n    while stack:\n      # Pop a vertex and its parent from the stack\n      vertex, parent = stack.pop()\n      # Mark the vertex as visited\n      visited.add(vertex)\n      # Explore neighbors of the vertex\n      for neighbour in graph[vertex]:\n        # Skip the parent vertex\n        if neighbour!= parent:\n          # If the neighbor is already visited, it means a cycle is found\n          if neighbour in visited:\n            # Return an empty set to indicate a cycle is found\n            return set()\n          # Add the neighbor to the stack for further exploration\n          stack.append((neighbour, vertex))\n  # If all vertices are visited, return the set of visited vertices\n  return visited\n\n# Perform DFS from each vertex in the root cycle\nvisited = dfs()\n# Check if all vertices are visited\nprint('FHTAGN!' if len(visited) == n else 'NO')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Initialize an array (c) of size n+1 to store the parent of each vertex in the Union-Find data structure.\n3. Iterate through each edge in the graph, and for each edge, find the roots of the two vertices using the Union-Find algorithm.\n4. If the roots are different, merge the two sets by making one root the parent of the other. This effectively connects the two vertices in the graph.\n5. If the roots are the same, increment the count of cycles (ciclos).\n6. After processing all edges, check if the graph is connected by verifying if all vertices belong to the same set in the Union-Find data structure.\n7. If the graph is connected and there is exactly one cycle, print \"FHTAGN!\". Otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\n# Read the number of vertices (n) and edges (m) from the input\nn, m = [int(i) for i in input().split()]\n\n# Initialize an array (c) of size n+1 to store the parent of each vertex\nc = [int(i) for i in range(n+1)]\n\n# Function to find the root of a vertex using the Union-Find algorithm\ndef find(u):\n    # If the vertex is its own parent, return the vertex\n    if u == c[u]:\n        return u\n    # Otherwise, recursively find the root and update the parent\n    c[u] = find(c[u])\n    return c[u]\n\n# Initialize the count of cycles\nciclos = 0\n\n# Iterate through each edge in the graph\nfor i in range(m):\n    # Read the two vertices of the edge\n    x, y = [int(j) for j in input().split()]\n    \n    # Find the roots of the two vertices\n    x = find(x)\n    y = find(y)\n    \n    # If the roots are different, merge the two sets\n    if find(x)!= find(y):\n        # Make one root the parent of the other\n        c[x] = c[y] = max(x, y)\n    # If the roots are the same, increment the count of cycles\n    else:\n        ciclos += 1\n\n# Check if the graph is connected\nconexo = True\n# Find the root of the first vertex\ncomponente = find(1)\n# Iterate through the remaining vertices\nfor i in range(2, n+1, 1):\n    # If a vertex does not belong to the same set as the first vertex, the graph is not connected\n    if find(i)!= componente:\n        conexo = False\n\n# Print the result\nif conexo and ciclos == 1:\n    print('FHTAGN!')\nelse:\n    print('NO')\nexit(0)\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Initialize an array (parent) to store the parent of each vertex, and an array (ranks) to store the rank of each vertex in the Union-Find data structure.\n3. Iterate through each edge in the graph, and for each edge, use the Union-Find algorithm to merge the two vertices into a single set.\n4. Check if the number of edges (m) is equal to n-1. If not, it means the graph is not a tree, so print 'NO'.\n5. Iterate through each vertex in the graph, and for each vertex, check if it is the root of a tree. If it is, increment the count of trees.\n6. If the count of trees is greater than 1, it means the graph contains multiple connected components, so print 'NO'.\n7. If the count of trees is 1, it means the graph is a single connected component, so check if there are any cycles in the graph by examining the ranks of the vertices.\n8. If there are no cycles in the graph, it means the graph is not a Cthulhu graph, so print 'NO'. Otherwise, print 'FHTAGN!'.\n\n\nCOMMENTED CODE:\n```python\ndef findSet(u):\n    # Find the root of the set that vertex u belongs to\n    if parent[u]!= u:\n        # If u is not the root, recursively find the root and update the parent of u\n        parent[u] = findSet(parent[u])\n    return parent[u]\n\ndef unionSet(u, v):\n    # Merge the sets that vertices u and v belong to\n    up = findSet(u)\n    vp = findSet(v)\n    if up == vp:\n        # If u and v are already in the same set, do nothing\n        return\n    if ranks[up] > ranks[vp]:\n        # If the rank of the set that u belongs to is higher, make u the parent of v\n        parent[vp] = up\n    elif ranks[up] < ranks[vp]:\n        # If the rank of the set that v belongs to is higher, make v the parent of u\n        parent[up] = vp\n    else:\n        # If the ranks are equal, make v the parent of u and increment the rank of v\n        parent[up] = vp\n        ranks[vp] += 1\n\nn, m = list(map(int, input(\"\").split())) # Read the number of vertices and edges from the user\n\n# Initialize the parent and ranks arrays\nparent = [i for i in range(n+1)]\nranks = [0 for i in range(n+1)]\n\n# Iterate through each edge in the graph and merge the two vertices into a single set\nfor _ in range(m):\n    u,v = tuple(map(int, input(\"\").split()))\n    unionSet(u,v)\n\n# Check if the number of edges is equal to n-1\nif n!= m:\n    # If not, print 'NO'\n    print('NO')\nelse:\n    # Initialize a count of trees\n    cnt = 0\n    # Iterate through each vertex in the graph\n    for i in range(1,n+1):\n        # If a vertex is the root of a tree, increment the count\n        if i == parent[i]: \n            cnt += 1\n            \n        # If there are more than one trees, break the loop\n        if cnt > 1:\n            break\n    # Print 'FHTAGN!' if there is only one tree and no cycles\n    if cnt == 1:\n        print('FHTAGN!')\n    else:\n        print('NO')\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input: Read the number of vertices `n` and the number of edges `m` from the input. Then, read `m` pairs of integers representing the edges in the graph.\n2. Initialize the graph: Initialize an array `lab` of size `n` to keep track of the connected components in the graph. Initialize all elements of `lab` to `-1`.\n3. Find the set: Implement the `find_set` function to find the root of a set that a vertex belongs to. If the vertex is the root of its set, return the vertex. Otherwise, recursively find the root and update the parent of the vertex.\n4. Union: Implement the `union` function to merge two sets. Update the parent of the root of one set to the root of the other set.\n5. Solve: Iterate over all edges in the graph. For each edge, find the roots of the sets that the two vertices belong to. If the roots are different, merge the two sets and decrement the count of connected components `cc`.\n6. Check the result: After iterating over all edges, check if the graph is a Cthulhu graph. If there is only one connected component and the number of edges is equal to `n-1`, print \"FHTAGN!\". Otherwise, print \"NO\".\n\nCOMMENTED CODE:\n```python\ndef read_input():\n    global n, m, edge\n    # Read the number of vertices and edges from the input\n    n, m = map(int, input().split())\n    # Initialize an empty list to store the edges\n    edge = []\n    # Read m pairs of integers representing the edges\n    for i in range(m):\n        u, v = map(int, input().split())\n        # Subtract 1 from the vertex indices to make them 0-based\n        edge.append((u-1, v-1))\n\n\ndef init():\n    global lab\n    # Initialize an array of size n to keep track of the connected components\n    lab = [-1] * n\n\n\ndef find_set(u):\n    global lab\n    # If the vertex is the root of its set, return the vertex\n    if lab[u] < 0:\n        return u\n    # Recursively find the root and update the parent of the vertex\n    lab[u] = find_set(lab[u])\n    return lab[u]\n\n\ndef union(r,s):\n    global lab\n    # Merge two sets by updating the parent of the root of one set to the root of the other set\n    lab[r] = s\n\n\ndef solve():\n    global edge, cc\n    # Initialize the graph\n    init()\n    # Initialize the count of connected components to n\n    cc = n\n    # Iterate over all edges in the graph\n    for e in edge:\n        # Find the roots of the sets that the two vertices belong to\n        r = find_set(e[0])\n        s = find_set(e[1])\n        # If the roots are different, merge the two sets and decrement the count of connected components\n        if r!= s:\n            union(r, s)\n            cc -= 1\n    # Check if the graph is a Cthulhu graph\n    if cc == 1 and m==n-1:\n        # If there is only one connected component and the number of edges is equal to n-1, print \"FHTAGN!\"\n        print(\"FHTAGN!\")\n    else:\n        # Otherwise, print \"NO\"\n        print(\"NO\")\n\n\nif __name__ == '__main__':\n    # Read the input\n    read_input()\n    # Solve the problem\n    solve()\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and edges (m) from the input.\n2. Initialize an adjacency list (adj) to represent the graph, where each index represents a vertex and its corresponding value is a list of its adjacent vertices.\n3. Read the edges of the graph from the input and update the adjacency list accordingly.\n4. Perform a depth-first search (DFS) to check if the graph is connected. If not, print \"NO\" and exit.\n5. Perform another DFS to find a simple cycle in the graph. If no cycle is found, print \"NO\" and exit.\n6. Once a cycle is found, mark all vertices in the cycle as part of the cycle.\n7. Perform a DFS from each vertex in the cycle to check if there are any connected components that are not part of the cycle. If any such component is found, print \"NO\" and exit.\n8. If all connected components are part of the cycle, print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\ndef dfsxx(visited, adj, ind, parent):\n    # Perform a DFS to mark all visited vertices\n    if (visited[ind] == 1): return\n    visited[ind] = 1\n    for i in adj[ind]:\n        if (visited[i] == 0):\n            dfsxx(visited, adj, i, parent)\n\ndef dfs(visited, adj, ind, parent):\n    # Perform a DFS to find a simple cycle\n    if (visited[ind] == 1): return [-1, -1]\n    visited[ind] = 1\n    for i in adj[ind]:\n        if (visited[i] == 0):\n            parent[i] = ind\n            x = dfs(visited, adj, i, parent)\n            if (x[0]!= -1): return x\n        elif (visited[i] == 1 and i!= parent[ind]):\n            return [i, ind]\n    return [-1, -1]\n\ndef dfsx(visited, adj, ind, parent, part, ext):\n    # Perform a DFS to check if a vertex is part of the cycle\n    if (visited[ind] == 1): return 0\n    visited[ind] = 1\n    for i in adj[ind]:\n        if (part[i] == 1 and ind == ext): continue\n        elif (part[i] == 1 and ind!= ext and i!= ext): return 1\n        if (visited[i] == 0):\n            parent[i] = ind\n            x = dfsx(visited, adj, i, parent, part, ext)\n            if (x!= 0): return 1\n        elif (visited[i] == 1 and i!= parent[ind]):\n            return 1\n    return 0\n\nn, m = [int(i) for i in input().split()]\nl = []\nadj = [[] for i in range(n)]\npart_cycle = [0 for i in range(n)]\nfor i in range(m):\n    a, b = [int(x) for x in input().split()]\n    adj[a - 1].append(b - 1)\n    adj[b - 1].append(a - 1)\n\n# Perform a DFS to check if the graph is connected\nparent = [-1 for i in range(n)]\nvisited = [0 for i in range(n)]\ndfsxx(visited, adj, 0, parent)\nif (sum(visited)!= n):\n    print(\"NO\")\nelse:\n    # Perform a DFS to find a simple cycle\n    parent = [-1 for i in range(n)]\n    visited = [0 for i in range(n)]\n    x = dfs(visited, adj, 0, parent)\n    if (x[0] == -1):\n        print(\"NO\")\n    else:\n        # Mark all vertices in the cycle as part of the cycle\n        part_cycle[x[0]] = 1; part_cycle[x[1]] = 1\n        cycle = []\n        ind = x[1]\n        cycle.append(x[0])\n        while (ind!= x[0]):\n            cycle.append(ind)\n            part_cycle[ind] = 1; part_cycle[parent[ind]] = 1\n            ind = parent[ind]\n\n        # Perform a DFS from each vertex in the cycle to check if there are any connected components that are not part of the cycle\n        flag = 0\n        parent = [-1 for i in range(n)]\n        visited = [0 for i in range(n)]\n        for i in cycle:\n            if (i == 0): continue\n            x = dfsx(visited, adj, i, parent, part_cycle, i)\n            if (x == 1):\n                print(\"NO\")\n                flag = 1\n                break\n        if (flag == 0):\n            print(\"FHTAGN!\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices `n` and edges `m` from the input.\n2. Create an adjacency list representation of the graph using the given edges.\n3. Perform a depth-first search (DFS) to find all cycles in the graph. This is done by keeping track of visited vertices and their parents in the DFS traversal.\n4. Mark all vertices in a cycle as part of a cycle by setting `cyc[v]` to `True`.\n5. Perform another DFS to count the number of connected components in the graph. This is done by keeping track of visited vertices.\n6. If the number of connected components is not equal to 1, the graph is not a Cthulhu graph, so print \"NO\" and exit.\n7. If the number of cycles found in step 3 is less than 3, the graph is not a Cthulhu graph, so print \"NO\" and exit.\n8. If all steps pass, the graph is a Cthulhu graph, so print \"FHTAGN!\".\n\nCOMMENTED CODE:\n```python\ndef cycle(f):  # Find and mark all vertices in a cycle\n    v = f  # Start from the root of the cycle\n    cyc[v] = True  # Mark the root as part of a cycle\n    v = p[v]  # Move to the parent of the root\n    while v!= f:  # Continue until we reach the root again\n        cyc[v] = True  # Mark each vertex as part of a cycle\n        v = p[v]  # Move to the parent\n\ndef dfs(v, par):  # Depth-first search to find cycles\n    global c, p  # Access global variables\n    if c[v] == 2:  # If the vertex is already visited, return\n        return\n    p[v] = par  # Set the parent of the current vertex\n    if c[v] == 1:  # If the vertex is part of a cycle, find and mark the cycle\n        cycle(v)\n        return True\n    c[v] = 1  # Mark the vertex as visited\n    for u in graph[v]:  # Iterate over all neighbors of the current vertex\n        if u!= par:  # Skip the parent\n            if dfs(u, v):  # Recursively search for cycles\n                return True\n    c[v] = 2  # Mark the vertex as fully visited\n    return False\n\ndef dfs1(v):  # Depth-first search to count connected components\n    if used[v]:  # If the vertex is already visited, return\n        return\n    used[v] = True  # Mark the vertex as visited\n    for u in graph[v]:  # Iterate over all neighbors of the current vertex\n        dfs1(u)  # Recursively visit all neighbors\n\nn, m = map(int, input().split())  # Read the number of vertices and edges\ngraph = [[] for i in range(n)]  # Create an adjacency list representation of the graph\np = [-1] * n  # Initialize the parent array\nc = [0] * n  # Initialize the visit status array\ncyc = [False] * n  # Initialize the cycle array\nif m!= n - 1:  # If the number of edges is not equal to n - 1, the graph is not a tree\n    print('NO')\n    exit(0)\nfor i in range(m):\n    a, b = map(int, input().split())  # Read an edge\n    a, b = a - 1, b - 1  # Adjust vertex indices\n    graph[a].append(b)  # Add the edge to the adjacency list\n    graph[b].append(a)  # Add the edge to the adjacency list\n\ndfs(0, -1)  # Perform DFS to find cycles\nused = [False] * n  # Initialize the visited array\ncnt = 0  # Initialize the cycle count\nfor i in range(n):\n    if cyc[i]:  # If the vertex is part of a cycle\n        cnt += 1  # Increment the cycle count\ndfs1(0)  # Perform DFS to count connected components\nfor i in range(n):\n    if not used[i]:  # If the vertex is not visited\n        print('NO')  # The graph is not a Cthulhu graph\n        exit(0)\nif cnt >= 3:  # If there are at least 3 cycles\n    print('FHTAGN!')  # The graph is a Cthulhu graph\nelse:\n    print('NO')  # The graph is not a Cthulhu graph\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input values for the number of vertices (n) and the number of edges (m) from the user.\n2. Check if the graph is valid by ensuring it has at least 3 vertices and the number of edges is equal to n - 1 (since a tree with n vertices has n - 1 edges). If not, print \"NO\".\n3. Create an adjacency list representation of the graph, where each index represents a vertex and its corresponding value is a list of its adjacent vertices.\n4. Perform a Depth-First Search (DFS) traversal starting from an arbitrary vertex (in this case, vertex 1). This will help identify all connected components in the graph.\n5. Check if the DFS traversal visited all vertices in the graph. If not, print \"NO\".\n6. If the DFS traversal visited all vertices, check if the graph can be represented as a set of rooted trees connected by a simple cycle. This can be done by checking if the graph has at least one cycle and if the remaining vertices can be partitioned into rooted trees.\n\nCOMMENTED CODE:\n```python\nn, m = map(int, input().split())  # Read input values for n and m\n\n# Check if the graph is valid\nif n < 3 or n!= m:  # minimo 3 vertices para un circulo\n    print(\"NO\")  # If not, print \"NO\"\n\nelse:\n    # Armado de lista para conexiones de vertices\n    V = []  # Adjacency list representation of the graph\n    S = []  # List to keep track of visited vertices during DFS\n    for i in range(n + 1):  # Initialize adjacency list for each vertex\n        V.append([])\n\n    # Read edges and update adjacency list\n    for j in range(m):\n        x, y = map(int, input().split())\n        V[x].append(y)  # conexion de x con y\n        V[y].append(x)  # conexion de y con x\n\n    # Perform DFS traversal starting from vertex 1\n    def DFS(a):\n        S.append(a)  # Mark vertex as visited\n        for v in V[a]:  # Iterate over adjacent vertices\n            if not v in S:  # If adjacent vertex is not visited\n                DFS(v)  # Recursively visit the adjacent vertex\n\n    DFS(1)  # Start DFS traversal from vertex 1\n\n    # Check if DFS traversal visited all vertices\n    if len(S) == n:\n        print(\"FHTAGN!\")  # If all vertices are visited, print \"FHTAGN!\"\n    else:\n        print(\"NO\")  # If not all vertices are visited, print \"NO\"\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the number of vertices (n) and edges (m) from the input.\n2. If n is not equal to m, it means the graph is not connected, so it cannot be a Cthulhu graph. Print \"NO\" and exit.\n3. Create a disjoint set data structure to keep track of connected components in the graph.\n4. Iterate through each edge in the graph and perform a union operation on the two vertices connected by the edge.\n5. After processing all edges, count the number of sets (or groups) in the disjoint set data structure.\n6. If there is only one group, it means the graph is connected and can be a Cthulhu graph. Print \"FHTAGN!\" and exit.\n7. If there are multiple groups, it means the graph is not a Cthulhu graph. Print \"NO\" and exit.\n\nCOMMENTED CODE:\n```python\ndef makeSet(n):\n  # Initialize the parent array with each vertex as its own parent\n  global parent, ranks\n  parent = [i for i in range (n + 1)]\n  # Initialize the ranks array with all vertices having rank 0\n  ranks = [0 for i in range(n + 1)]\n\ndef findSet(u):\n  # If the vertex is not its own parent, recursively find its parent\n  if u!= parent[u]:\n    parent[u] = findSet(parent[u])\n  # Return the parent of the vertex\n  return parent[u]\n\ndef unionSet(u, v):\n  # Find the parents of the two vertices\n  up = findSet(u)\n  vp = findSet(v)\n  # If the two vertices are already in the same set, do nothing\n  if up == vp:\n    return\n  # Union the two sets based on their ranks\n  if ranks[up] > ranks[vp]: \n    # Make the parent of the second set the parent of the first set\n    parent[vp] = up\n  elif ranks[up] < ranks[vp]:\n    # Make the parent of the first set the parent of the second set\n    parent[up] = vp\n  else:\n    # Make the parent of the first set the parent of the second set and increment the rank of the second set\n    parent[up] = vp\n    ranks[vp] += 1\n\nn, m = map(int, input().split())\n# If the number of vertices is not equal to the number of edges, print \"NO\" and exit\nif n!= m:\n  print('NO')\nelse:\n  # Create a disjoint set data structure\n  makeSet(n)\n  # Iterate through each edge in the graph and perform a union operation\n  for i in range(m):\n    u, v = map(int, input().split())\n    unionSet(u, v)\n  # Count the number of sets in the disjoint set data structure\n  no_group = 0\n  for i in range(1, n + 1):\n    # If a vertex is its own parent, it means it is in a separate set\n    if parent[i] == i:\n      no_group += 1\n  # Print \"FHTAGN!\" if there is only one group, otherwise print \"NO\"\n  print(\"FHTAGN!\"  if no_group == 1 else \"NO\")\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The first line contains the number of vertices `n` and the number of edges `m` of the graph. Each of the following `m` lines contains a pair of integers `x` and `y`, indicating that an edge exists between vertices `x` and `y`.\n2. Create an adjacency list representation of the graph: Use a dictionary `adj` to store the adjacency list of the graph, where each key is a vertex and its corresponding value is a list of its adjacent vertices.\n3. Perform a depth-first search (DFS) to find connected components: Initialize a list `v` to keep track of visited vertices. Iterate through each vertex in the graph. If a vertex is not visited, perform a DFS from that vertex and mark all visited vertices as 1.\n4. Count the number of connected components: Increment the `cmps` counter each time a new connected component is found.\n5. Check the conditions for Cthulhu: If the number of edges `m` is equal to `n-1` and the number of connected components `cmps` is 1, then the graph can be regarded as Cthulhu. Otherwise, it is not.\n\nCOMMENTED CODE:\n```python\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\nfrom collections import defaultdict\n\n# Read the input\nn, m = map(int, input().split())  # number of vertices and number of edges\nadj = defaultdict(list)  # adjacency list representation of the graph\n\n# Create the adjacency list\nfor i in range(m):\n    x, y = map(int, input().split())  # edge between vertices x and y\n    adj[x].append(y)\n    adj[y].append(x)\n\n# Initialize variables\ncmps = 0  # number of connected components\nv = [0]*(n+1)  # visited vertices\n\n# Perform DFS to find connected components\nfor i in range(1, 1+n):\n    if not v[i]:  # if vertex i is not visited\n        q = [i]  # create a queue with vertex i\n        while q:\n            e = q.pop()  # pop a vertex from the queue\n            v[e] = 1  # mark vertex e as visited\n            \n            # add adjacent vertices to the queue\n            for j in adj[e]:\n                if not v[j]:\n                    q.append(j)\n\n        # increment the number of connected components\n        cmps += 1\n\n# Check the conditions for Cthulhu\nprint(\"FHTAGN!\" if n==m and cmps==1 else \"NO\")  # print the result\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    },
    {
        "instruction": "...Once upon a time a man came to the sea. The sea was stormy and dark. The man started to call for the little mermaid to appear but alas, he only woke up Cthulhu...\n\nWhereas on the other end of the world Pentagon is actively collecting information trying to predict the monster's behavior and preparing the secret super weapon. Due to high seismic activity and poor weather conditions the satellites haven't yet been able to make clear shots of the monster. The analysis of the first shot resulted in an undirected graph with n vertices and m edges. Now the world's best minds are about to determine whether this graph can be regarded as Cthulhu or not.\n\nTo add simplicity, let's suppose that Cthulhu looks from the space like some spherical body with tentacles attached to it. Formally, we shall regard as Cthulhu such an undirected graph that can be represented as a set of three or more rooted trees, whose roots are connected by a simple cycle.\n\nIt is guaranteed that the graph contains no multiple edges and self-loops.\n\n<image>\n\nInput\n\nThe first line contains two integers \u2014 the number of vertices n and the number of edges m of the graph (1 \u2264 n \u2264 100, 0 \u2264 m \u2264 <image>).\n\nEach of the following m lines contains a pair of integers x and y, that show that an edge exists between vertices x and y (1 \u2264 x, y \u2264 n, x \u2260 y). For each pair of vertices there will be at most one edge between them, no edge connects a vertex to itself.\n\nOutput\n\nPrint \"NO\", if the graph is not Cthulhu and \"FHTAGN!\" if it is.\n\nExamples\n\nInput\n\n6 6\n6 3\n6 4\n5 1\n2 5\n1 4\n5 4\n\n\nOutput\n\nFHTAGN!\n\nInput\n\n6 5\n5 6\n4 6\n3 1\n5 1\n1 2\n\n\nOutput\n\nNO\n\nNote\n\nLet us denote as a simple cycle a set of v vertices that can be numbered so that the edges will only exist between vertices number 1 and 2, 2 and 3, ..., v - 1 and v, v and 1.\n\nA tree is a connected undirected graph consisting of n vertices and n - 1 edges (n > 0).\n\nA rooted tree is a tree where one vertex is selected to be the root.",
        "output": "SOLUTION STEPS:\n\n1. Read the input: The number of vertices `n` and the number of edges `m` of the graph, and then read `m` pairs of integers representing the edges.\n2. Create a graph data structure: Initialize a graph with `n` nodes, where each node represents a vertex in the graph.\n3. Connect the nodes: For each pair of integers representing an edge, connect the corresponding nodes in the graph.\n4. Perform a breadth-first search (BFS) on the graph: Start from an arbitrary node (in this case, node 1), and explore all its neighbors, then move on to their neighbors, and so on.\n5. Identify the connected components: During the BFS, keep track of the nodes that have been visited and the node from which each node was first visited (i.e., the \"known_by\" attribute).\n6. Check for the Cthulhu condition: If a node is visited that has already been visited before and is not connected to the current node by a simple cycle (i.e., the \"known_by\" attribute is not the same for both nodes), return \"NO\".\n7. Check if the graph is a Cthulhu: If the BFS visits all nodes and the \"fhtagn\" flag is set, return \"FHTAGN!\". Otherwise, return \"NO\".\n\nCOMMENTED CODE:\n```python\nclass Graph():\n    def __init__(self, number_nodes):\n        # Initialize a list to store the nodes, with each node representing a vertex in the graph\n        self.nodes = [0] * (number_nodes+1)\n        for i in range(number_nodes):\n            # Create a new node for each vertex and add it to the list\n            self.nodes[i+1] = Node(i+1)\n        \n    def connect(self, node_1, node_2):\n        # Find the representative node for each of the two nodes\n        self.find(node_1).neighbors.append(self.find(node_2))\n        self.find(node_2).neighbors.append(self.find(node_1))\n    \n    def find(self, i):\n        # Use path compression to optimize the find operation\n        return self.nodes[i]\n\n    def bfs(self):\n        # Initialize a stack to store the nodes to visit, starting from node 1\n        stack = []\n        stack.append(self.nodes[1])\n        # Initialize a dictionary to keep track of visited nodes\n        visited = {}\n        # Initialize a flag to indicate if a simple cycle has been found\n        fhtagn = False\n        while(stack):\n            # Pop a node from the stack\n            current = stack.pop()\n            # If the node has already been visited, skip it\n            if current.value in visited:\n                continue\n            # Mark the node as visited\n            visited[current.value] = 1\n            # Explore the neighbors of the current node\n            for neighbor in current.neighbors:\n                # If the neighbor has not been visited, add it to the stack and mark it as known by the current node\n                if neighbor.value not in visited:\n                    neighbor.known_by = current\n                    stack.append(neighbor)\n                # If the neighbor has been visited before and is not connected to the current node by a simple cycle, return \"NO\"\n                else:\n                    if current.known_by!= neighbor:\n                        if fhtagn==False:\n                            fhtagn = True\n                        else:\n                            return(\"NO\")\n        # If the BFS visits all nodes and the \"fhtagn\" flag is set, return \"FHTAGN!\"\n        if fhtagn == True and len(visited)+1 == len(self.nodes):\n            return(\"FHTAGN!\")\n        # Otherwise, return \"NO\"\n        return(\"NO\")    \n\nclass Node():\n    def __init__(self, value):\n        # Initialize the node with a value and an empty list of neighbors\n        self.value = value\n        self.neighbors = []\n        # Initialize the \"known_by\" attribute to the current node\n        self.known_by = self\n        \nvertices, edges = [int(s) for s in input().split()]\n# Create a graph with the given number of vertices\ngraph = Graph(vertices)\n# Connect the nodes based on the given edges\nfor i in range(edges):\n    node_1, node_2 = [int(s) for s in input().split()]\n    graph.connect(node_1, node_2)\n\n# Perform the BFS and print the result\nprint(graph.bfs())\n```",
        "system": "You are a competitive programming expert. Your task is to break down the problem-solving approach into detailed, structured steps. And then write valid code to solve the problem"
    }
]